<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LadaBoard - Storyboard Maker</title>
<link rel="icon" type="image/x-icon" href="assets/ladaboard.ico" />
<link rel="shortcut icon" href="assets/ladaboard.ico" />
<!-- 
  STORYBOARD HTML - Onion Skin System
  
  PERUBAHAN ONION SKIN:
  - Onion skin sekarang menggunakan overlay canvas terpisah (onionCanvas)
  - Onion skin tidak pernah tercampur dengan gambar utama (drawCanvas)
  - Onion skin hanya muncul di mode edit/draw
  - Preview dan export tidak menampilkan onion skin
  - Bitmap final hanya berisi gambar utama tanpa onion skin
  
  Struktur Canvas:
  - drawCanvas (z-index: 1): Gambar utama + hasil drawing
  - onionCanvas (z-index: 2): Overlay onion skin (transparan, pointer-events: none)
-->
<link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
:root{--bg:#0f1115;--panel:#141619;--muted:#9aa3b2;--accent:#d9fa00;--accent-2:#d9fa00;}
*{box-sizing:border-box;font-family:Inter,Segoe UI,Roboto,system-ui,Arial}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0c0e 0%, #0f1115 100%);color:#e6eef8}
.app {
  display: flex; /* ubah dari grid ke flexbox */
  gap: 18px;
  padding: 18px;
  height: 100vh;
  align-items: flex-start; /* penting untuk sticky positioning */
}
.sidebar {
  display: flex;
  flex-direction: column;
  width: 360px; /* fixed width untuk sidebar */
  flex-shrink: 0; /* mencegah sidebar menyusut */
  height: 100vh; /* full height */
  background: var(--panel);
  border-radius: 10px;
  padding: 12px;
  gap: 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  overflow: hidden; /* mencegah sidebar scroll */
}
.header{display:flex;gap:8px;align-items:center}
.logo{padding:8px 12px;background:linear-gradient(90deg,var(--accent),var(--accent-2));border-radius:8px;font-weight:700;color:#000}
.controls{display:flex;gap:8px;margin-left:auto}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer; display:inline-flex; align-items:center; gap: 6px;}
.btn:hover{border-color: var(--accent); background: rgba(217,250,0,0.08); color:#fff; box-shadow: 0 6px 16px rgba(217,250,0,0.08)}
.btn:focus-visible{outline:none; box-shadow:0 0 0 2px rgba(217,250,0,0.55)}
.mode-toggle{position:relative;display:grid;grid-template-columns:1fr 1fr;align-items:center;gap:0;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:12px;padding:4px;--pos:0;min-width:160px}
.mode-toggle .toggle-thumb{position:absolute;top:4px;left:4px;width:calc(50% - 0px);height:calc(100% - 8px);background:linear-gradient(90deg,var(--accent),var(--accent-2));border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.35);transform:translateX(calc(var(--pos)*100%));transition:transform 220ms cubic-bezier(.2,.8,.2,1),width 220ms}
.mode-toggle button{position:relative;z-index:1;background:transparent;border:none;cursor:pointer;padding:8px 14px;border-radius:8px;color:var(--muted);font-weight:700}
.mode-toggle .active{color:#071017}
.list {
  flex: 1;
  overflow-y: auto;       /* biar bisa digulir */
  padding: 6px;
  background: linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
  border-radius: 8px;
  scroll-behavior: smooth; /* smooth scrolling */

  /* sembunyikan scrollbar */
  scrollbar-width: none;  /* Firefox */
}
.list::-webkit-scrollbar { 
  display: none;          /* Chrome, Edge, Safari */
}
.frame{display:grid;grid-template-columns:56px 1fr 64px;gap:10px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:8px;border:1px solid rgba(255,255,255,0.02);transition: all 0.2s ease;}
.frame.selected{background:rgba(217,250,0,0.08);border-color:var(--accent);}
.frame.selected input:focus{background:rgba(255,255,255,0.1);}
.thumb{width:56px;height:40px;border-radius:4px;background:#0a0a0b;display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:12px;overflow:hidden}
.meta{display:flex;flex-direction:column;gap:6px}
.meta input[type=text]{width:100%;background:transparent;border:none;color:inherit;outline:none}
.small{font-size:12px;color:var(--muted)}
.side-right {
  background: var(--panel);
  border-radius: 10px;
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  position: sticky;
  top: 18px; /* biar nempel di atas */
  flex: 1; /* ambil sisa ruang yang tersedia */
  max-width: calc(100vw - 396px); /* 360px sidebar + 18px gap + 18px padding */
  height: fit-content; /* tinggi sesuai konten */
  overflow: visible; /* pastikan tidak ada overflow yang mengganggu sticky */
}
.canvas-stage{background:#050607;border-radius:8px;aspect-ratio:16/9;width:100%;max-height:70vh;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
.canvas-stage canvas{width:100%;height:100%;object-fit:contain;background:#000;border-radius:4px}
.toolbar{display:flex;gap:8px;align-items:center}
.input{padding:8px;border-radius:6px;background:#0b0c0d;border:1px solid rgba(255,255,255,0.03);color:var(--muted);font-family:inherit}
.row{display:flex;gap:8px;align-items:center}
.footer{display:flex;justify-content:space-between;align-items:center;padding-top:8px}
.file-actions{display:flex;gap:8px}
/* File dropdown styles */
.toolbar .dropdown{position:relative}
.dropdown-menu{position:absolute;top:100%;left:0;background:var(--panel);border:1px solid rgba(255,255,255,0.06);border-radius:8px;padding:6px;display:none;min-width:200px;box-shadow:0 12px 30px rgba(0,0,0,0.6);z-index:1300}
.dropdown.open .dropdown-menu{display:block}
.dropdown-menu .btn{width:100%;justify-content:flex-start}
.badge{background:rgba(255,255,255,0.04);padding:6px 8px;border-radius:6px;color:var(--muted)}
.dialog{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:999}
.dialog.open{display:flex;touch-action:none}
.modal{width:920px;background:var(--panel);border-radius:8px;padding:8px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}
.modal{display:inline-flex;flex-direction:column;align-items:center;width:auto;max-width:calc(100vw - 40px);background:var(--panel);border-radius:8px;padding:8px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}
.canvas-toolbar{display:flex;gap:8px;align-items:center;padding:8px}
.toolbtn{padding:6px;border-radius:6px;border:none;background:transparent;color:var(--muted);cursor:pointer; font-size: 20px; width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center;}
.toolbtn:hover{background: rgba(217,250,0,0.08); color:#fff; box-shadow: 0 6px 16px rgba(217,250,0,0.08)}
.toolbtn:focus-visible{outline:none; box-shadow:0 0 0 2px rgba(217,250,0,0.55)}
.toolbtn.active{background:rgba(255,255,255,0.03);color:#fff}
.slider{width:150px}
.color-swatch{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
.small-muted{font-size:12px;color:var(--muted)}
.icon-bx{width:24px;height:24px;display:inline-flex;align-items:center;justify-content:center;font-size:20px; color: var(--muted);}
.truncate{max-width:500px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
textarea.input{resize:both;min-height:44px;max-height:140px;min-width:120px}
.bx { vertical-align: middle; }
.small-edit{padding:4px 6px;font-size:12px;border-radius:6px}
/* Empty state inside the frames list */
.empty-state {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:18px;
  height:180px; /* adjust if you want larger */
  border-radius:8px;
  background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
  color: var(--muted);
}
.empty-state .big-btn {
  --cta1: #d9fa00;
  --cta2: #d9fa00;
  background: linear-gradient(135deg, var(--cta1), var(--cta2));
  color: #071017;
  border: 1px solid rgba(0,0,0,0.15);
  padding: 12px 20px;
  border-radius: 12px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.2);
  width: 70%;
  max-width: 260px;
  transition: transform .2s ease, box-shadow .2s ease, filter .2s ease;
}
.empty-state .big-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 14px 40px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.2);
}
.empty-state .big-btn:active {
  transform: translateY(0);
  filter: brightness(.98);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45) inset, 0 6px 18px rgba(0,0,0,0.35);
}
.empty-state .big-btn:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px rgba(217,250,0,0.55), 0 10px 30px rgba(0,0,0,0.5);
}
.empty-state .small-line {
  font-size: 13px;
  color: var(--muted);
  text-align:center;
  max-width: 280px;
}
/* small canvas overlay text style - not required but keeps consistent look */
.guide-label {
  font-family: "Segoe UI", sans-serif;
  font-size: 12px;
  fill: #fff;
  pointer-events: none;
}
/* Guide panel styles */
.guide-panel {
  position: absolute;
  top: 56px; /* adjust if toolbar height differs */
  right: 24px; /* align under toolbar area (change as needed) */
  width: 680px;
  max-width: calc(100% - 40px);
  background: linear-gradient(180deg, rgba(20,20,20,0.98), rgba(16,16,16,0.96));
  border-radius: 10px;
  padding: 12px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  z-index: 1200;
  display: none;
  gap: 8px;
  color: var(--muted);
}

/* show state */
.guide-panel.open { display: block; }

/* panel contents */
.guide-row { display:flex; gap:12px; align-items:flex-start; }
.bx-icon { width:48px; height:48px; display:flex; align-items:center; justify-content:center; background:linear-gradient(90deg,var(--accent),var(--accent-2)); border-radius:8px; color:#071017; font-size:20px; }

/* make inputs compact in panel */
.guide-panel .input { padding:6px; font-size:13px; }
.guide-panel .small-edit { padding:6px 8px; font-size:13px; }

/* responsive: if narrow screen, panel becomes full width below toolbar */
@media (max-width: 900px) {
  .guide-panel { left:12px; right:12px; top:64px; width:auto; }
}
/* new: compact group for seconds+frames inputs */
.duration-group { display:flex; align-items:center; gap:6px; }
/* icon-only tiny button (for Edit) */
.icon-btn { padding:4px; width:28px; height:28px; border:none; background:transparent; color:var(--muted); border-radius:6px; display:inline-flex; align-items:center; justify-content:center; }
.icon-btn:hover { background:rgba(255,255,255,0.05); color:#fff; }
/* Confirm button accent style */
#confirmDraw {
  background: linear-gradient(90deg, var(--accent), var(--accent-2));
  color: #071017;
  border: none;
  font-weight: 700;
  box-shadow: 0 6px 20px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.25);
}
#confirmDraw:hover { filter: brightness(1.04); }
#confirmDraw:focus-visible { outline: none; box-shadow: 0 0 0 3px rgba(217,250,0,0.55), 0 6px 20px rgba(0,0,0,0.45); }

/* --- NEW: Animated hero logo + shining CTA + intro overlay --- */
.hero-logo{position:relative; width:68px; height:68px; border-radius:16px; background:linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow: 0 8px 24px rgba(217,250,0,0.2); display:flex; align-items:center; justify-content:center; color:#071017;}
.hero-logo i{font-size:32px;}
.hero-logo.lg{width:96px; height:96px; border-radius:20px;}

.big-animated{position:relative; animation: pulseGlow 3s ease-in-out infinite;}

@keyframes pulseGlow{0%,100%{box-shadow: 0 8px 24px rgba(217,250,0,0.25);}50%{box-shadow: 0 12px 32px rgba(217,250,0,0.4);}}

/* Intro overlay styles removed */

/* Draw wrapper responsive styles */
.draw-wrapper .canvas-toolbar {
  max-width: 100%;
}

.canvas-area canvas {
  max-width: 100%;
  height: auto;
}

/* Frame music button styling */
.frame-music-btn { 
  padding:4px; 
  width:28px; 
  height:28px; 
  border:none; 
  background:transparent; 
  color:var(--muted); 
  border-radius:6px; 
  display:inline-flex; 
  align-items:center; 
  justify-content:center; 
  cursor:pointer;
  transition: color 0.2s ease;
}
.frame-music-btn:hover { 
  background:rgba(255,255,255,0.05); 
  color:#fff; 
}
.frame-music-btn.has-music { 
  color: rgb(217, 255, 0); /* hijau kalau ada musik */
}
.frame-music-btn.has-music:hover { 
  color: #f55; /* merah kalau hover */
}

/* Improve input focus states within frames */
.frame input:focus {
  outline: none;
  background: rgba(255,255,255,0.08);
  border-color: rgba(217,250,0,0.3);
}

.frame.selected input:focus {
  background: rgba(255,255,255,0.12);
  border-color: rgba(217,250,0,0.5);
}

/* Submenu gaya Photoshop */
.submenu {
  position: relative;
}

.submenu-toggle {
  width: 100%;
  text-align: left;
}

.submenu-menu {
  position: absolute;
  top: 0;
  left: 100%;
  background: var(--panel);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 8px;
  padding: 6px;
  display: none;
  min-width: 200px;
  box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  z-index: 1400;
}

.submenu:hover .submenu-menu {
  display: block;
}

/* ---------- Frame list scrollable tanpa scrollbar (copy this) ---------- */
/* Pastikan ini ada di dalam tag <style> di storyboard.html */

/* Make sidebar column layout reliable */
.sidebar {
  display: flex;
  flex-direction: column;
  height: 100%; /* sekarang ikut .app yang fixed */
  background: var(--panel);
  border-radius: 10px;
  padding: 12px;
  gap: 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.6);
}

.list {
  flex: 1;
  overflow-y: auto;       /* biar bisa digulir */
  padding: 6px;
  background: linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
  border-radius: 8px;

  /* sembunyikan scrollbar */
  scrollbar-width: none;  /* Firefox */
}
.list::-webkit-scrollbar { 
  display: none;          /* Chrome, Edge, Safari */
}

/* Area kanan (toolbar + preview + footer) tetap di tempat (stay) */
.side-right {
  /* agar sticky bekerja, parent harus punya tinggi (app punya height:100vh di filemu) */
  position: sticky;
  top: 0;
  align-self: start;  /* agar tidak mengisi baris vertikal fleksibel */
  display: flex;
  flex-direction: column;
  gap: 10px;
  background:var(--panel);border-radius:10px;padding:14px
}

/* optional: membuat konten kanan tidak ikut mengkerut */
.side-right > .canvas-stage,
.side-right > .toolbar,
.side-right > .footer {
  flex-shrink: 0;
}

/* (opsional) smoother scroll behavior */
.list {
  scroll-behavior: smooth;
}

/* -------- Responsive Enhancements (non-destructive) -------- */
.mobile-only { display: none; }

@media (max-width: 1600px) {
  .app { gap: 16px; padding: 16px; }
  .sidebar { width: 340px; }
  .canvas-stage { max-height: 68vh; }
}

@media (max-width: 1366px) {
  /* Ensure 100% zoom equivalent layout fits 1366p width */
  .app { gap: 12px; padding: 10px; }
  .sidebar { width: 280px; }
  .toolbar { flex-wrap: wrap; row-gap: 8px; overflow-x: auto; }
  .mode-toggle { min-width: 140px; }
  .canvas-stage { max-height: 66vh; }
  .truncate { max-width: 360px; }
}

@media (max-width: 1024px) {
  .app { flex-direction: column; gap: 12px; padding: 12px; height: auto; }
  .side-right { position: relative; top: 0; max-width: 100%; }
  .canvas-stage { max-height: 48vh; }
  .mobile-only { display: inline-flex; }

  /* Off-canvas sidebar */
  .sidebar {
    position: fixed;
    left: 0; top: 0; bottom: 0;
    width: min(92vw, 420px);
    max-width: 420px;
    height: 100vh;
    transform: translateX(-110%);
    transition: transform .25s ease;
    z-index: 1750;
    box-shadow: 0 20px 60px rgba(0,0,0,0.7);
  }
  body.sidebar-open .sidebar { transform: translateX(0); }

  .mobile-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    z-index: 1700;
    display: none;
  }
  body.sidebar-open .mobile-backdrop { display: block; }

  /* Mobile File dropdown: full-width fixed panel + vertical submenus */
  .toolbar .dropdown { position: static; }
  #fileDropdown .dropdown-menu {
    position: fixed;
    left: 0;
    right: 0;
    top: 56px; /* sit below top toolbar */
    width: 100vw;
    min-width: 0;
    border-radius: 0 0 12px 12px;
    padding: 10px;
    max-height: 70vh;
    overflow-y: auto;
    z-index: 2000; /* above sidebar backdrop */
  }
  /* stack submenu content vertically on mobile */
  #fileDropdown .submenu-menu {
    position: static;
    top: auto; left: auto;
    background: transparent;
    border: none;
    border-radius: 0;
    padding: 6px 0 0 0;
    margin: 4px 0 0 0;
    box-shadow: none;
    min-width: 0;
    display: none; /* shown via .submenu.open */
  }
  #fileDropdown .submenu.open .submenu-menu { display: block; }
  #fileDropdown .submenu .bx-chevron-right { transition: transform .2s ease; }
  #fileDropdown .submenu.open .bx-chevron-right { transform: rotate(90deg); }
  #fileDropdown .submenu:hover .submenu-menu { display: none !important; }
}

@media (max-width: 480px) {
  .btn { padding: 6px 8px; }
  .input { padding: 6px; }
  .mode-toggle { min-width: 120px; }
}
/* -------- End Responsive Enhancements -------- */


/* Mobile-specific dropdown layout fixes */
@media (max-width: 1024px) {
  .dropdown { position: static; }
  .dropdown-menu {
    position: fixed;
    left: 12px;
    right: 12px;
    top: 72px;
    min-width: unset;
    max-height: 60vh;
    overflow-y: auto;
    z-index: 1900;
    padding: 8px;
    border-radius: 12px;
  }
  /* Stack submenu content below parent on mobile */
  .submenu-menu {
    position: static;
    display: none;
    min-width: 100%;
    box-shadow: none;
    margin-top: 6px;
  }
  .submenu.open .submenu-menu { display: block; }
  .dropdown-menu .btn { padding: 10px 12px; }
}

/* ===== Timeline (Adobe Animate-like) ===== */
.timeline-container { 
  background: var(--panel);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 10px;
  margin-top: 22px; /* push down a bit so stamps not cramped */
  overflow: hidden;
}
.timeline-toolbar { 
  display:flex; align-items:center; justify-content:space-between; 
  padding:4px 8px; border-bottom:1px solid rgba(255,255,255,0.06);
}
.timeline-toolbar .tl-label { font-weight:700; color:#e6eef8; margin-right:8px; font-size:11px; letter-spacing:.2px; }
.timeline-scroller { overflow: auto; background: #161616; }
#timelineCanvas { display:block; height: 124px; min-width: 100%; }
/* Hide scrollbar height wise */
.timeline-scroller::-webkit-scrollbar { height: 8px; }
.timeline-scroller::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.08); border-radius: 6px; }
/* ===== End Timeline ===== */

/* Reorder animation for sidebar frames */
@keyframes framePop {
  0% { transform: scale(0.98); box-shadow: 0 0 0 rgba(217,250,0,0); }
  60% { transform: scale(1.02); box-shadow: 0 10px 26px rgba(217,250,0,0.18); }
  100% { transform: scale(1); box-shadow: 0 0 0 rgba(217,250,0,0); }
}
.frame.reordered { animation: framePop 320ms ease; }
/* Playback highlight in sidebar */
@keyframes playingPulse { from { box-shadow: 0 0 0 rgba(217,250,0,0.00); } to { box-shadow: 0 0 16px rgba(217,250,0,0.18); } }
.frame.playing { border-color: rgba(217,250,0,0.65); background: rgba(217,250,0,0.05); animation: playingPulse 1.2s ease-in-out infinite alternate; }
</style>
</head>
<body>
<div class="app">
  <div class="sidebar">
    <div class="header">
      <div class="logo"><i class='bx bxs-story'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 268 343.18" width="15" height="15"><defs><style>.cls-1{fill:#000;}</style></defs><g id="Layer_2" data-name="Layer 2"><g id="Layer_2-2" data-name="Layer 2"><path class="cls-1" d="M256,119.65,200,73.56a32.13,32.13,0,0,0-15.48-12.74L115,3.53c-6.6-5.44-12-4.48-12,2.12v53H32a32,32,0,0,0-32,32v196a32,32,0,0,0,32,32H173a32.07,32.07,0,0,0,30.48-22.26L256,339.65c6.6,5.43,12,4.48,12-2.12v-196C268,134.93,262.6,125.08,256,119.65Zm-91,159H40v-180h63v103c0,6.6,5.4,16.44,12,21.88l50,41.18Z"/></g></g></svg>
      </i> LadaBoard</div>
      <div class="controls">
        <div class="mode-toggle" id="modeToggle">
          <span class="toggle-thumb" aria-hidden="true"></span>
          <button class="active" data-mode="draw">Draw</button>
          <button data-mode="upload">Upload</button>
        </div>
      </div>
    </div>

    <div class="row">

      <input id="projectTitle" class="input truncate" placeholder="Project title..." autocomplete="off" />
      <div class="badge" id="fpsBadge">24 FPS</div>
      
    </div>

    <div class="row">
      <button class="btn" id="addFrame"><i class='bx bx-plus'></i> New Frame</button>
      <button class="btn" id="duplicateFrame"><i class='bx bx-copy'></i> Duplicate</button>
      <button class="btn" id="removeFrame"><i class='bx bx-trash'></i> Delete</button>
    </div>

    <div class="list" id="framesList" ondragover="event.preventDefault()"></div>

    <div class="row"><div class="small-muted">Drag thumbnails to reorder</div></div>

    <!-- File actions moved into File dropdown in top toolbar -->
  </div>

  <div class="side-right">
    <div class="toolbar">
      <button class="btn mobile-only" id="openSidebar"><i class='bx bx-menu'></i> Frames</button>
      <!-- File dropdown placed to the left of FPS setting -->
      <div class="dropdown" id="fileDropdown">
        <button class="btn" id="fileMenuBtn"><i class='bx bx-file'></i> File</button>
        <div class="dropdown-menu" id="fileMenu">
          <button class="btn" id="saveProject"><i class='bx bx-save'></i> Save</button>
          <button class="btn" id="loadProject"><i class='bx bx-folder-open'></i> Load</button>

          <!-- Submenu Export Spread -->
          <div class="submenu">
            <button class="btn submenu-toggle">
              <i class='bx bx-spreadsheet'></i> Export Storyboard
              <i class='bx bx-chevron-right' style="margin-left:auto;"></i>
            </button>
            <div class="submenu-menu">
              <button class="btn" id="exportSpreadPng">PNG</button>
              <button class="btn" id="exportSpreadPdf">PDF</button>
            </div>
          </div>

          <!-- Submenu Export Video -->
          <div class="submenu">
            <button class="btn submenu-toggle">
              <i class='bx bx-film'></i> Export Video
              <i class='bx bx-chevron-right' style="margin-left:auto;"></i>
            </button>
            <div class="submenu-menu">
              <button class="btn" id="exportVideoWebm">WebM (with audio)</button>
              <button class="btn" id="exportVideoMp4">MP4 (with audio)</button>
            </div>
          </div>
        </div>
      </div>
      <div class="row"><label class="small-muted">FPS</label><input id="fpsInput" class="input" type="number" value="24" min="1" max="60" style="width:80px" autocomplete="off" /></div>
      <div class="row">
        <label class="small-muted">Default Duration</label>
        <input id="defaultDuration" class="input" type="number" value="24" min="1" style="width:80px" autocomplete="off" />
        <button id="openShortcuts" class="icon-btn" title="Keyboard Shortcuts">
          <i class='bx bx-help-circle'></i>
        </button>
      </div>
      <div style="margin-left:auto" class="row">
        <button class="btn" id="loopToggle" title="Loop"><i class='bx bx-repeat'></i> Loop</button>
        <button class="btn" id="restartPlay" title="Play from start"><i class='bx bx-rewind'></i> Restart</button>
        <button class="btn" id="playAll"><i class='bx bx-play'></i> Play</button>
      </div>
    </div>

    <div class="canvas-stage" id="stage">
      <!-- External rulers for preview -->
      <canvas id="previewRulerTop" style="position:absolute; left:22px; top:0; pointer-events:none; width:calc(100% - 22px); height:22px; background:transparent;"></canvas>
      <canvas id="previewRulerLeft" style="position:absolute; left:0; top:22px; pointer-events:none; width:22px; height:calc(100% - 22px); background:transparent;"></canvas>
      <div id="previewRulerCorner" style="position:absolute; left:0; top:0; width:22px; height:22px; background:rgba(0,0,0,0.55); pointer-events:none;"></div>
      <canvas id="preview" width="1280" height="720" style="position:absolute; left:22px; top:22px; width:calc(100% - 22px); height:calc(100% - 22px);"></canvas>
    </div>

    <!-- NEW: Timeline container (Adobe Animate-like) -->
    <div id="timelineContainer" class="timeline-container">
      <div class="timeline-toolbar">
        <div class="tl-left">
          <span class="tl-label">Timeline</span>
          <span id="tlTimecode" class="small-muted" style="margin-left:8px; font-weight:700; letter-spacing:.3px;"></span>
          <button id="tlZoomOut" class="icon-btn" title="Zoom Out (-)"><i class='bx bx-zoom-out'></i></button>
          <button id="tlZoomIn" class="icon-btn" title="Zoom In (+)"><i class='bx bx-zoom-in'></i></button>
        </div>
        <!-- NEW: center controls for Onion Skin + Guides -->
        <div class="tl-center" style="display:flex;align-items:center;gap:8px;flex:1;justify-content:center;">
          <!-- Onion skin quick toggle + counts -->
          <button id="tlToggleOnion" class="btn" title="Toggle Onion Skin"><i class='bx bx-layer'></i> Onion</button>
          <label class="small-muted" title="Backward frames"><i class='bx bx-chevrons-left' style="vertical-align: middle;"></i></label>
          <input id="tlOnionBack" class="input" type="number" value="2" min="0" max="10" style="width:50px" />
          <label class="small-muted" title="Forward frames"><i class='bx bx-chevrons-right' style="vertical-align: middle;"></i></label>
          <input id="tlOnionFwd" class="input" type="number" value="2" min="0" max="10" style="width:50px" />

          <!-- Divider -->
          <span style="width:1px;height:18px;background:rgba(255,255,255,0.08);display:inline-block;margin:0 4px"></span>

          <!-- Guides settings -->
          <button id="tlToggleGuides" class="btn small-edit" title="Toggle Guides"><i class='bx bx-grid-alt'></i> Guides</button>
          <button id="tlToggleRulers" class="btn small-edit" title="Toggle Rulers"><i class='bx bx-ruler'></i> Rulers</button>
          <label class="small-muted" style="margin-left:6px">Aspect</label>
          <select id="tlGuideAspect" class="input" style="width:120px;">
            <option value="1920x1080">16:9 (1920×1080)</option>
            <option value="1280x720">16:9 (1280×720)</option>
            <option value="1024x768">4:3 (1024×768)</option>
          </select>
          <label class="small-muted">Title</label>
          <input id="tlTitleSafePct" class="input" type="number" min="50" max="100" value="90" style="width:64px" />%
          <label class="small-muted">Action</label>
          <input id="tlActionSafePct" class="input" type="number" min="50" max="100" value="95" style="width:64px" />%
        </div>
        <div class="tl-right">
          <span id="tlScaleText" class="small-muted"></span>
        </div>
      </div>
      <div id="timelineScroller" class="timeline-scroller">
        <canvas id="timelineCanvas"></canvas>
      </div>
    </div>

    <!-- Hidden original bottom meta row preserved for compatibility -->
    <div class="row" id="bottomMetaRow" style="display:none">
      <div style="flex:1">
        <textarea id="descInput" class="input" placeholder="Description for selected frame" autocomplete="off"></textarea>
      </div>
      <div class="duration-group">
        <input id="durationSec" class="input" type="number" min="0" step="0.1" value="0" style="width:70px" autocomplete="off" />
        <span class="small-muted">s</span>
        <input id="durationFrm" class="input" type="number" min="0" step="1" style="width:56px" value="" autocomplete="off" />
        <span class="small-muted">f</span>
      </div>
    </div>

    <div class="footer" id="bottomFooter" style="display:none">
      <div class="small-muted">Total Frames: <span id="totalFrames">0</span></div>
      <div class="small-muted">Project length: <span id="projectLength">0s</span></div>
    </div>
  </div>
</div>
<div class="mobile-backdrop" id="mobileBackdrop"></div>

<!-- Drawing modal -->
<div class="dialog" id="drawDialog">
  <div class="modal">
    <div class="draw-wrapper" style="display:inline-flex; flex-direction:column; align-items:center; gap:8px; width:auto;">
      <div class="canvas-toolbar" style="width:100%; display:flex; align-items:center; gap:8px;">
        <button data-tool="pen" class="toolbtn active" title="Pen"><i class='bx bx-pencil'></i></button>
        <button data-tool="eraser" class="toolbtn" title="Eraser"><i class='bx bx-eraser'></i></button>
        <button data-tool="rect" class="toolbtn" title="Rectangle"><i class='bx bx-rectangle'></i></button>
        <button data-tool="ellipse" class="toolbtn" title="Ellipse"><i class='bx bxs-circle'></i></button>
        <button data-tool="bucket" class="toolbtn" title="Paint Bucket"><i class='bx bxs-color-fill'></i></button>

        <div style="display:flex;align-items:center;gap:8px;margin-left:6px">
          <input type="color" id="colorPicker" value="#000000" style="margin-left:8px" />
          <input type="range" id="sizeRange" min="1" max="80" value="6" class="slider" />
        </div>

        <button class="toolbtn" id="undoBtn" title="Undo"><i class='bx bx-undo'></i></button>
        <button class="toolbtn" id="redoBtn" title="Redo"><i class='bx bx-redo'></i></button>
        <button class="toolbtn" id="clearBtn" title="Clear Canvas"><i class='bx bx-brush-alt'></i></button>
        <button id="addImageBtn" class="btn" title="Add Image"><i class='bx bx-image-add'></i></button>
        <button id="applyImageBtn" class="btn" title="Apply Image" style="display:none"><i class='bx bx-check'></i></button>


        <!-- Onion skin controls (paste di canvas-toolbar) -->
        <div style="display:flex;align-items:center;gap:8px;margin-left:auto">
          <button id="toggleOnion" class="btn" title="Toggle Onion Skin"><i class='bx bx-layer'></i></button>
        
          <div style="display:flex;align-items:center;gap:8px;padding-left:6px;">
            <label class="small-muted" title="Backward frames"><i class='bx bx-chevrons-left' style="vertical-align: middle;"></i></label>
            <input id="onionBackInput" class="input" type="number" value="2" min="0" max="10" style="width:50px" />
            
            <label class="small-muted" title="Forward frames"><i class='bx bx-chevrons-right' style="vertical-align: middle;"></i></label>
            <input id="onionFwdInput" class="input" type="number" value="2" min="0" max="10" style="width:50px" />
          </div>
        </div>
        <!-- Single Guide button (replace previous guide controls) -->
        <button id="guideBtn" class="btn" title="Open Guides"><i class='bx bx-grid-alt'></i> </button>

        <!-- floating panel that appears under toolbar -->
        <div id="guidePanel" class="guide-panel" aria-hidden="true">
          <div class="guide-row">
            <div class="bx-icon"><i class='bx bx-camera-movie'></i></div>
            <div style="flex:1">
              <div style="display:flex;gap:8px;align-items:center">
                <button id="toggleGuides" class="btn small-edit"><i class='bx bx-grid-alt'></i> Guides</button>
                <button id="toggleRulers" class="btn small-edit"><i class='bx bx-ruler'></i> Rulers</button>

                <label class="small-muted" style="margin-left:6px">Aspect</label>
                <select id="guideAspect" class="input" style="width:120px;">
                  <option value="1920x1080">16:9 (1920×1080)</option>
                  <option value="1280x720">16:9 (1280×720)</option>
                  <option value="1024x768">4:3 (1024×768)</option>
                </select>
              </div>

              <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
                <label class="small-muted">Title</label>
                <input id="titleSafePct" class="input" type="number" min="50" max="100" value="90" style="width:64px" />%
                <label class="small-muted" style="margin-left:8px">Action</label>
                <input id="actionSafePct" class="input" type="number" min="50" max="100" value="95" style="width:64px" />%
                <div style="margin-left:auto;display:flex;gap:6px">
                  <button id="closeGuidePanel" class="btn small-edit">Close</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="canvas-area" style="position:relative; display:inline-block; margin-left:22px; margin-top:22px;">
        <canvas id="drawCanvas" width="1024" height="576" style="position:relative; z-index:1; background:transparent; border-radius:6px;"></canvas>
        <canvas id="onionCanvas" width="1024" height="576" style="position:absolute; z-index:2; left:0; top:0; background:transparent; pointer-events:none;"></canvas>
        
        <canvas id="guideCanvas" width="1024" height="576" style="position:absolute; z-index:3; left:0; top:0; background:transparent; pointer-events:none;"></canvas>
        <canvas id="insertCanvas" width="1024" height="576" style="position:absolute; z-index:4; left:0; top:0; background:transparent; pointer-events:none;"></canvas>
        
        <!-- External rulers outside the white stage -->
        <canvas id="rulerTop" width="1024" height="22" style="position:absolute; left:0; top:-22px; pointer-events:none;"></canvas>
        <canvas id="rulerLeft" width="22" height="576" style="position:absolute; left:-22px; top:0; pointer-events:none;"></canvas>
      </div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;padding:8px">
      <button class="btn" id="cancelDraw"><i class='bx bx-x'></i> Cancel</button>
      <button class="btn" id="confirmDraw"><i class='bx bx-check'></i> Confirm</button>
    </div>
  </div>
</div>

<input type="file" id="uploader" accept="image/*" style="display:none" multiple />
<input type="file" id="insertImageInput" accept="image/*" style="display:none" />
<input type="file" id="loadProjectInput" accept="application/json" style="display:none" />

<!-- Shortcuts Help Modal -->
<div class="dialog" id="shortcutsDialog">
  <div class="modal" style="min-width: 520px; max-width: calc(100vw - 40px);">
    <div style="display:flex; align-items:center; justify-content:space-between; width:100%; padding:8px 4px 12px 4px;">
      <div style="display:flex; align-items:center; gap:8px; color:#e6eef8; font-weight:700;">
        <i class='bx bx-keyboard'></i>
        <span>Keyboard Shortcuts</span>
      </div>
      <button id="closeShortcuts" class="icon-btn" title="Close"><i class='bx bx-x'></i></button>
    </div>
    <div style="width:100%; color: var(--muted);">
      <div class="small-muted" style="margin:6px 0 4px; font-weight:700; color:#e6eef8;">Global</div>
      <div style="display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;">
        <div>Undo</div><div><code>Ctrl</code> + <code>Z</code></div>
        <div>Redo</div><div><code>Ctrl</code> + <code>Shift</code> + <code>Z</code></div>
        <div>Redo (alt)</div><div><code>Ctrl</code> + <code>Y</code></div>
        <div>Save project</div><div><code>Ctrl</code> + <code>S</code></div>
        <div>Copy selected frame(s)</div><div><code>Ctrl</code> + <code>C</code></div>
        <div>Cut selected frame(s)</div><div><code>Ctrl</code> + <code>X</code></div>
        <div>Paste frame(s)</div><div><code>Ctrl</code> + <code>V</code></div>
        <div>Delete selected frame(s)</div><div><code>Delete</code></div>
        <div>Next/Prev frame</div><div><code>→</code> / <code>←</code></div>
        <div>Play/Pause (when not typing)</div><div><code>Enter</code></div>
        <div>New frame</div><div><code>Shift</code> + <code>D</code></div>
      </div>
      <div class="small-muted" style="margin:12px 0 4px; font-weight:700; color:#e6eef8;">Draw/Edit Modal</div>
      <div style="display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;">
        <div>Undo drawing</div><div><code>Ctrl</code> + <code>Z</code></div>
        <div>Redo drawing</div><div><code>Ctrl</code> + <code>Shift</code> + <code>Z</code></div>
        <div>Redo drawing (alt)</div><div><code>Ctrl</code> + <code>Y</code></div>
        <div>Confirm</div><div><code>Enter</code> / <code>Tab</code></div>
        <div>Confirm + New frame</div><div><code>Shift</code> + <code>D</code></div>
        <div>Cancel</div><div><code>Esc</code></div>
      </div>
      <div class="small-muted" style="margin:12px 0 4px; font-weight:700; color:#e6eef8;">Timeline</div>
      <div style="display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;">
        <div>Select all frames</div><div><code>Ctrl</code> + <code>A</code></div>
      </div>
    </div>
  </div>
</div>

<!-- INTRO OVERLAY -->
<!-- Removed intro overlay popup -->

<!-- ---------- Frame cache & preload helpers ----------
let frameCache = []; // parallel array, same length as state.frames. Each entry: { bmp: ImageBitmap|HTMLImageElement, src: original src }

concurrency control
const PRELOAD_CONCURRENCY = 6; // tweak: 4..12 depending memory/network
const PRELOAD_BATCH_SIZE = PRELOAD_CONCURRENCY;

function isDataUrl(s) { return typeof s === 'string' && s.startsWith('data:'); }

async function createBitmapFromSrc(src) {
  try {
    if (window.createImageBitmap) {
      const res = await fetch(src);
      const blob = await res.blob();
      const bmp = await createImageBitmap(blob);
      return bmp;
    } else {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    }
  } catch (err) {
    try {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    } catch(e){
      console.warn('createBitmapFromSrc failed for', src, e);
      return null;
    }
  }
}

async function preloadFramesWithProgress(frames, onProgress = ()=>{}) {
  const n = frames.length;
  frameCache = new Array(n).fill(null);

  function getSrc(f) {
    if (!f) return null;
    return f.thumb || f.src || null;
  }

  const tasks = frames.map((f, idx) => async () => {
    const src = getSrc(f);
    if (!src) { frameCache[idx] = null; onProgress(idx+1, n); return; }
    try {
      const bmpOrImg = await createBitmapFromSrc(src);
      frameCache[idx] = { bmp: bmpOrImg, src };
      onProgress(idx+1, n);
    } catch (err) {
      console.warn('preload failed', idx, err);
      frameCache[idx] = null;
      onProgress(idx+1, n);
    }
  });

  let i = 0;
  const runners = new Array(Math.min(PRELOAD_BATCH_SIZE, tasks.length)).fill(0).map(async () => {
    while (i < tasks.length) {
      const task = tasks[i++];
      await task();
    }
  });

  await Promise.all(runners);
  return frameCache;
}

// optional small progress overlay
function showPreloadOverlay(text) {
  let el = document.getElementById('preloadOverlay');
  if (!el) {
    el = document.createElement('div');
    el.id = 'preloadOverlay';
    Object.assign(el.style, {
      position: 'fixed', left: '12px', bottom: '12px', padding: '8px 12px',
      background: 'rgba(0,0,0,0.7)', color: '#fff', borderRadius: '8px', zIndex: 2000,
      fontSize: '13px'
    });
    document.body.appendChild(el);
  }
  el.textContent = text;
  el.style.display = 'block';
}
function hidePreloadOverlay() {
  const el = document.getElementById('preloadOverlay');
  if (el) el.style.display = 'none';
}

let _cacheUpdatePending = null;
function scheduleUpdateFrameCache(debounceMs = 200) {
  if (_cacheUpdatePending) clearTimeout(_cacheUpdatePending);
  _cacheUpdatePending = setTimeout(() => {
    _cacheUpdatePending = null;
    updateFrameCache();
  }, debounceMs);
}

async function updateFrameCache() {
  if (!state.frames || state.frames.length === 0) {
    frameCache = [];
    return;
  }
  try {
    showPreloadOverlay('Preloading frames... 0/' + state.frames.length);
    await preloadFramesWithProgress(state.frames, (done, total) => {
      showPreloadOverlay(`Preloading frames... ${done}/${total}`);
    });
  } catch (err) {
    console.warn('updateFrameCache error', err);
  } finally {
    hidePreloadOverlay();
  }
}
// ---------- End of Frame cache & preload helpers ---------- -->

<script>
// LadaBoard Planner — improved eraser & edit behavior
const state = { frames: [], selected: -1, fps: 24, defaultDuration: 24, mode: 'draw' };
let editIndex = null; // Used for the drawing modal
let selectedFrames = new Set();
let clipboardFrames = [];
// When true, after confirming a draw/edit, reopen a fresh draw modal for a new frame
let chainNewFrameAfterConfirm = false;
// Stable ref index for onion-skin redraws during async image decodes
let currentOnionRefIndex = null;
// Prevent overlapping confirm actions (e.g. when spamming Shift+D)
let confirmInProgress = false;

// Variabel global untuk musik
let musicAudio = null;
let currentMusicUrl = null;

const framesList = document.getElementById('framesList');
const preview = document.getElementById('preview'); const pctx = preview.getContext('2d');
const fpsInput = document.getElementById('fpsInput'); const fpsBadge = document.getElementById('fpsBadge');
const defaultDurationInput = document.getElementById('defaultDuration');
const totalFramesEl = document.getElementById('totalFrames'); const projectLength = document.getElementById('projectLength');
const descInput = document.getElementById('descInput'); const durationSecInput = document.getElementById('durationSec'); const durationFrmInput = document.getElementById('durationFrm');

// wiring for File dropdown
const fileDropdownEl = document.getElementById('fileDropdown');
const fileMenuBtn = document.getElementById('fileMenuBtn');
const fileMenu = document.getElementById('fileMenu');
function closeAllSubmenus(){
  try {
    if (!fileDropdownEl) return;
    fileDropdownEl.querySelectorAll('.submenu.open').forEach((el)=> el.classList.remove('open'));
  } catch(_){}
}
function closeFileDropdown(){
  try {
    if (!fileDropdownEl) return;
    fileDropdownEl.classList.remove('open');
    closeAllSubmenus();
  } catch(_){}
}
if (fileMenuBtn) {
  fileMenuBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    const willOpen = !fileDropdownEl.classList.contains('open');
    if (willOpen) {
      fileDropdownEl.classList.add('open');
    } else {
      closeFileDropdown();
    }
  });
  // prevent accidental close when interacting inside the menu
  if (fileMenu) {
    ['click','touchstart'].forEach((evt)=>{
      fileMenu.addEventListener(evt, (ev)=> ev.stopPropagation(), { passive: false });
    });
  }
  // close on outside interaction / escape
  ['click','touchstart'].forEach((evt)=>{
    document.addEventListener(evt, ()=> closeFileDropdown(), { passive: true });
  });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeFileDropdown(); });

  // toggle submenus on tap for mobile, and close others when opening one
  const submenuToggles = fileDropdownEl.querySelectorAll('.submenu-toggle');
  submenuToggles.forEach((toggle)=>{
    toggle.addEventListener('click', (e)=>{
      const isMobile = window.innerWidth <= 1024;
      if (!isMobile) return; // keep hover behavior on desktop
      e.preventDefault();
      e.stopPropagation();
      const parent = toggle.closest('.submenu');
      const willOpen = !parent.classList.contains('open');
      // close others
      fileDropdownEl.querySelectorAll('.submenu.open').forEach((el)=>{ if (el !== parent) el.classList.remove('open'); });
      if (willOpen) { parent.classList.add('open'); } else { parent.classList.remove('open'); }
    }, { passive: false });
  });

  // reset submenu state when switching back to desktop
  window.addEventListener('resize', ()=>{ if (window.innerWidth > 1024) closeAllSubmenus(); });
}

// Mobile submenu toggle handling
(function setupMobileSubmenu(){
  const isMobile = () => window.innerWidth <= 1024;
  const submenuRoots = document.querySelectorAll('#fileMenu .submenu');
  submenuRoots.forEach(root => {
    const toggleBtn = root.querySelector('.submenu-toggle');
    if (!toggleBtn) return;
    toggleBtn.addEventListener('click', (ev) => {
      // On mobile, toggle inline submenu instead of hover
      if (isMobile()) {
        ev.preventDefault();
        ev.stopPropagation();
        root.classList.toggle('open');
      }
    });
  });

  // Prevent dropdown from closing when clicking inside menu on mobile
  const fileMenu = document.getElementById('fileMenu');
  if (fileMenu) {
    fileMenu.addEventListener('click', (ev) => {
      if (isMobile()) ev.stopPropagation();
    });
  }

  // Close submenus when dropdown itself closes
  document.addEventListener('click', () => {
    if (!isMobile()) return;
    document.querySelectorAll('#fileMenu .submenu.open').forEach(el => el.classList.remove('open'));
  });

  // Also close on Escape
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      document.querySelectorAll('#fileMenu .submenu.open').forEach(el => el.classList.remove('open'));
    }
  });
})();

// drawing modal elements
const drawDialog = document.getElementById('drawDialog'); 
const drawCanvas = document.getElementById('drawCanvas'); 
const dctx = drawCanvas.getContext('2d');
const onionCanvas = document.getElementById('onionCanvas');
const octx = onionCanvas.getContext('2d');

// TAMBAHKAN DUA BARIS DI BAWAH INI
const guideCanvas = document.getElementById('guideCanvas');
const gctx = guideCanvas.getContext('2d');
const insertCanvas = document.getElementById('insertCanvas');
const ictx = insertCanvas.getContext('2d');

// Main drawing canvas - everything will be drawn here as bitmap
let drawingHistory = []; // Array of canvas states for undo/redo
let currentHistoryIndex = -1;
let maxHistorySize = 50; // Limit history size to prevent memory issues

// Initialize drawing canvas
function initDrawingCanvas() {
  // Clear any existing history
  drawingHistory = [];
  currentHistoryIndex = -1;
  
  // Save initial blank state
  saveCanvasState();
}

function saveCanvasState() {
  // Create a copy of current canvas state
  const imageData = dctx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
  
  // Remove any future states if we're not at the end
  if (currentHistoryIndex < drawingHistory.length - 1) {
    drawingHistory = drawingHistory.slice(0, currentHistoryIndex + 1);
  }
  
  // Add new state
  drawingHistory.push(imageData);
  currentHistoryIndex++;
  
  // Limit history size
  if (drawingHistory.length > maxHistorySize) {
    drawingHistory.shift();
    currentHistoryIndex--;
  }
  
  // Update undo/redo button states
  updateUndoRedoButtons();
}

function restoreCanvasState(index) {
  if (index < 0 || index >= drawingHistory.length) return;
  
  const imageData = drawingHistory[index];
  dctx.putImageData(imageData, 0, 0);
  currentHistoryIndex = index;
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if (undoBtn) undoBtn.disabled = currentHistoryIndex <= 0;
  if (redoBtn) redoBtn.disabled = currentHistoryIndex >= drawingHistory.length - 1;
}

function undo() {
  if (currentHistoryIndex > 0) {
    restoreCanvasState(currentHistoryIndex - 1);
  }
}

function redo() {
  if (currentHistoryIndex < drawingHistory.length - 1) {
    restoreCanvasState(currentHistoryIndex + 1);
  }
}

function clearCanvas() {
  dctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
  dctx.fillStyle = '#fff';
  dctx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
  saveCanvasState();
}

// Remove old brush layer system - everything will be drawn directly on main canvas
let lastBrushPoint = null;
let brushSize = 8; // default size
let brushColor = '#000000';

// Remove old brush layer functions
// function initBrushLayer() { ... }
// function clearBrushLayer() { ... }
// function drawBrushDot() { ... }
// function drawBrushStroke() { ... }

// New bitmap-based drawing functions
function drawBrushDot(p, pressure) {
  const r = (brushSize * (pressure > 0 ? pressure : 0.5)) / 2;
  dctx.save();
  dctx.globalCompositeOperation = 'source-over';
  dctx.fillStyle = brushColor;
  dctx.beginPath();
  dctx.arc(p.x, p.y, Math.max(0.5, r), 0, Math.PI * 2);
  dctx.fill();
  dctx.restore();
}

function drawBrushStroke(p1, p2, pressure) {
  const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
  const steps = Math.max(1, Math.ceil(dist / 0.5));
  for (let i = 0; i < steps; i++) {
    const t = i / steps;
    const x = p1.x + (p2.x - p1.x) * t;
    const y = p1.y + (p2.y - p1.y) * t;
    drawBrushDot({ x, y }, pressure);
  }
}

// New eraser function for bitmap-based erasing
function eraseDot(p) {
  dctx.save();
  dctx.globalCompositeOperation = 'destination-out';
  const r = Math.max(0.5, (size || 1) / 2);
  dctx.beginPath();
  dctx.arc(p.x, p.y, r, 0, Math.PI * 2);
  dctx.fill();
  dctx.restore();
}

function drawEraserStroke(p1, p2) {
  dctx.save();
  dctx.globalCompositeOperation = 'destination-out';
  const r = Math.max(0.5, (size || 1) / 2);
  const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
  const steps = Math.max(1, Math.ceil(dist / 0.75));
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const x = p1.x + (p2.x - p1.x) * t;
    const y = p1.y + (p2.y - p1.y) * t;
  dctx.beginPath();
    dctx.arc(x, y, r, 0, Math.PI * 2);
    dctx.fill();
  }
  dctx.restore();
}

// ===== Compact Guide panel logic =====
const guideBtn = document.getElementById('guideBtn');
const guidePanel = document.getElementById('guidePanel');
const closeGuidePanel = document.getElementById('closeGuidePanel');

// single shared guides state (keperluan drawGuides function)
const guidesState = window.guidesState || {
  enabled: true,
  rulers: true,
  artW: 1920, artH: 1080,
  titleSafePct: 90,
  actionSafePct: 95
};
// expose globally if not already
window.guidesState = guidesState;

// wire UI elements
const tgl = document.getElementById('toggleGuides');
const tr = document.getElementById('toggleRulers');
const aspect = document.getElementById('guideAspect');
const titleInp = document.getElementById('titleSafePct');
const actionInp = document.getElementById('actionSafePct');

function applyGuideUI() {
  if (!tgl || !tr || !aspect || !titleInp || !actionInp) {
    // continue to sync TL controls even if modal controls not present
  }
  // Modal controls (inside draw dialog)
  if (tgl) tgl.style.borderColor = guidesState.enabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  if (tr) tr.style.borderColor = guidesState.rulers ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  if (aspect) aspect.value = `${guidesState.artW}x${guidesState.artH}`;
  if (titleInp) titleInp.value = Math.round(guidesState.titleSafePct);
  if (actionInp) actionInp.value = Math.round(guidesState.actionSafePct);

  // TL controls (outside, in timeline toolbar)
  const tlTgl = document.getElementById('tlToggleGuides');
  const tlTr = document.getElementById('tlToggleRulers');
  const tlAspect = document.getElementById('tlGuideAspect');
  const tlTitle = document.getElementById('tlTitleSafePct');
  const tlAction = document.getElementById('tlActionSafePct');
  if (tlTgl) tlTgl.style.borderColor = guidesState.enabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  if (tlTr) tlTr.style.borderColor = guidesState.rulers ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  if (tlAspect) tlAspect.value = `${guidesState.artW}x${guidesState.artH}`;
  if (tlTitle) tlTitle.value = Math.round(guidesState.titleSafePct);
  if (tlAction) tlAction.value = Math.round(guidesState.actionSafePct);

  // update outside rulers if modal is open
  try { if (drawDialog.classList.contains('open')) drawOutsideRulers(); } catch(_){ }
}

// toggle panel visibility
function openGuidePanel() {
  guidePanel.classList.add('open');
  guidePanel.setAttribute('aria-hidden', 'false');
  applyGuideUI();
}
function closeGuidePanelFn() {
  guidePanel.classList.remove('open');
  guidePanel.setAttribute('aria-hidden', 'true');
}

// attach events
if (guideBtn) {
  guideBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (guidePanel.classList.contains('open')) closeGuidePanelFn(); else openGuidePanel();
  });
}
// close button
if (closeGuidePanel) closeGuidePanel.addEventListener('click', () => closeGuidePanelFn());

// click outside to close panel
document.addEventListener('click', (e) => {
  if (!guidePanel) return;
  if (!guidePanel.classList.contains('open')) return;
  if (guidePanel.contains(e.target) || guideBtn.contains(e.target)) return;
  closeGuidePanelFn();
});

// wire controls inside panel to guidesState and re-render
if (tgl) tgl.addEventListener('click', ()=>{ guidesState.enabled = !guidesState.enabled; applyGuideUI(); try { redrawPaths(); drawPreview(); drawOutsideRulers(); } catch(e){} });
if (tr) tr.addEventListener('click', ()=>{ guidesState.rulers = !guidesState.rulers; applyGuideUI(); try { redrawPaths(); drawPreview(); drawOutsideRulers(); } catch(e){} });
if (aspect) aspect.addEventListener('change', ()=>{
  const v = (aspect.value || '1920x1080').split('x');
  guidesState.artW = Number(v[0]) || 1920; guidesState.artH = Number(v[1]) || 1080;
  try { applyGuideUI(); redrawPaths(); drawPreview(); drawOutsideRulers(); } catch(e) {}
});
if (titleInp) titleInp.addEventListener('change', ()=>{ guidesState.titleSafePct = Math.max(50, Math.min(100, Number(titleInp.value)||90)); try { applyGuideUI(); redrawPaths(); drawPreview(); drawOutsideRulers(); } catch(e){} });
if (actionInp) actionInp.addEventListener('change', ()=>{ guidesState.actionSafePct = Math.max(50, Math.min(100, Number(actionInp.value)||95)); try { applyGuideUI(); redrawPaths(); drawPreview(); drawOutsideRulers(); } catch(e){} });

// ensure UI initial state
applyGuideUI();

// If you already implemented drawGuides(ctx, w, h) earlier, it will use window.guidesState.
// If not, include the drawGuides() implementation provided previously (the function that draws artboard, safe areas and rulers).

// drawGuides: draws artboard box, safe areas and rulers on given ctx & canvas size
function drawGuides(ctx, canvasW, canvasH) {
  // compute artboard fit
  const artW = guidesState.artW, artH = guidesState.artH;
  const scale = Math.min(canvasW / artW, canvasH / artH);
  const aw = Math.round(artW * scale), ah = Math.round(artH * scale);
  const ox = Math.round((canvasW - aw) / 2), oy = Math.round((canvasH - ah) / 2);

  ctx.save();

  // Safe areas (independent from rulers)
  if (guidesState.enabled) {
    const titlePadX = aw * ((100 - guidesState.titleSafePct) / 200);
    const titlePadY = ah * ((100 - guidesState.titleSafePct) / 200);
    const actionPadX = aw * ((100 - guidesState.actionSafePct) / 200);
    const actionPadY = ah * ((100 - guidesState.actionSafePct) / 200);

    // action safe (outer)
    ctx.strokeStyle = 'rgba(90,200,180,0.95)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.strokeRect(ox + actionPadX + 0.5, oy + actionPadY + 0.5, aw - actionPadX*2 -1, ah - actionPadY*2 -1);

    // title safe (inner)
    ctx.strokeStyle = 'rgba(240,200,80,0.95)';
    ctx.lineWidth = 2;
    ctx.setLineDash([4,2]);
    ctx.strokeRect(ox + titlePadX + 0.5, oy + titlePadY + 0.5, aw - titlePadX*2 -1, ah - titlePadY*2 -1);

    // labels
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(240,200,80,0.95)';
    ctx.font = '12px "Segoe UI", sans-serif';
    ctx.fillText('Title Safe ' + guidesState.titleSafePct + '%', ox + titlePadX + 8, oy + titlePadY + 14);
    ctx.fillStyle = 'rgba(90,200,180,0.95)';
    ctx.fillText('Action Safe ' + guidesState.actionSafePct + '%', ox + actionPadX + 8, oy + actionPadY + 14);
  }

  // Rulers are handled externally for both modal and preview now

  ctx.restore();
}

// Draw external rulers for draw modal (outside stage)
function drawOutsideRulers() {
  const rt = document.getElementById('rulerTop');
  const rl = document.getElementById('rulerLeft');
  if (!rt || !rl) return;

  const show = !!guidesState.rulers;
  rt.style.display = show ? 'block' : 'none';
  rl.style.display = show ? 'block' : 'none';
  if (!show) return;

  // sync sizes
  rt.width = drawCanvas.width; rt.height = 22;
  rl.width = 22; rl.height = drawCanvas.height;

  const rtx = rt.getContext('2d');
  const rlx = rl.getContext('2d');
  rtx.clearRect(0,0,rt.width,rt.height);
  rlx.clearRect(0,0,rl.width,rl.height);

  // backgrounds
  rtx.fillStyle = 'rgba(0,0,0,0.4)';
  rtx.fillRect(0,0,rt.width,rt.height);
  rlx.fillStyle = 'rgba(0,0,0,0.4)';
  rlx.fillRect(0,0,rl.width,rl.height);

  // artboard mapping
  const artW = guidesState.artW, artH = guidesState.artH;
  const scale = Math.min(drawCanvas.width / artW, drawCanvas.height / artH);
  const ppu = scale;

  // choose minor unit
  const candidates = [1,2,5,10,20,50,100,200,500,1000,2000];
  const targetPx = 14;
  let minorUnit = 10;
  let bestDiff = Infinity;
  for (const u of candidates) {
    const d = Math.abs(ppu * u - targetPx);
    if (ppu * u >= 8 && d < bestDiff) { bestDiff = d; minorUnit = u; }
  }
  const majorEvery = 10;

  // styles
  rtx.strokeStyle = 'rgba(255,255,255,0.75)';
  rtx.fillStyle = 'rgba(255,255,255,0.75)';
  rtx.lineWidth = 1;
  rtx.font = '10px "Segoe UI", sans-serif';

  rlx.strokeStyle = 'rgba(255,255,255,0.75)';
  rlx.fillStyle = 'rgba(255,255,255,0.75)';
  rlx.lineWidth = 1;
  rlx.font = '10px "Segoe UI", sans-serif';

  // top ruler ticks across stage width mapped to art units
  for (let u = 0; u <= artW; u += minorUnit) {
    const x = Math.round(u * ppu) + 0.5;
    if (x > rt.width + 0.5) break;
    const isMajor = (Math.round(u) % (minorUnit * majorEvery) === 0);
    const len = isMajor ? 12 : 6;
    rtx.beginPath();
    rtx.moveTo(x, rt.height - len + 0.5);
    rtx.lineTo(x, rt.height + 0.5);
    rtx.stroke();
    if (isMajor) rtx.fillText(String(Math.round(u)), x + 2, 10);
  }

  // left ruler ticks across stage height mapped to art units
  for (let v = 0; v <= artH; v += minorUnit) {
    const y = Math.round(v * ppu) + 0.5;
    if (y > rl.height + 0.5) break;
    const isMajor = (Math.round(v) % (minorUnit * majorEvery) === 0);
    const len = isMajor ? 12 : 6;
    rlx.beginPath();
    rlx.moveTo(rl.width - len + 0.5, y);
    rlx.lineTo(rl.width + 0.5, y);
    rlx.stroke();
    if (isMajor) {
      rlx.save();
      rlx.translate(4, y - 2);
      rlx.rotate(-Math.PI/2);
      rlx.fillText(String(Math.round(v)), 0, 0);
      rlx.restore();
    }
  }
}

// Draw external rulers for preview (outside stage)
function drawPreviewOutsideRulers() {
  const previewEl = document.getElementById('preview');
  const rt = document.getElementById('previewRulerTop');
  const rl = document.getElementById('previewRulerLeft');
  const corner = document.getElementById('previewRulerCorner');
  if (!previewEl || !rt || !rl || !corner) return;

  const show = !!guidesState.rulers;
  rt.style.display = show ? 'block' : 'none';
  rl.style.display = show ? 'block' : 'none';
  corner.style.display = show ? 'block' : 'none';
  if (!show) return;

  // compute display size and set hi-dpi canvas sizes
  const rect = previewEl.getBoundingClientRect();
  const cssW = Math.max(0, Math.floor(rect.width));
  const cssH = Math.max(0, Math.floor(rect.height));
  const dpr = window.devicePixelRatio || 1;

  // set CSS size (already via style width/height), set pixel size and scale
  rt.width = Math.max(1, Math.floor(cssW * dpr));
  rt.height = Math.max(1, Math.floor(22 * dpr));
  rl.width = Math.max(1, Math.floor(22 * dpr));
  rl.height = Math.max(1, Math.floor(cssH * dpr));

  const rtx = rt.getContext('2d');
  const rlx = rl.getContext('2d');
  rtx.setTransform(dpr,0,0,dpr,0,0);
  rlx.setTransform(dpr,0,0,dpr,0,0);
  rtx.clearRect(0,0,cssW,22);
  rlx.clearRect(0,0,22,cssH);

  // backgrounds
  rtx.fillStyle = 'rgba(0,0,0,0.4)';
  rtx.fillRect(0,0,cssW,22);
  rlx.fillStyle = 'rgba(0,0,0,0.4)';
  rlx.fillRect(0,0,22,cssH);

  // artboard mapping in CSS pixels
  const artW = guidesState.artW, artH = guidesState.artH;
  const ppu = Math.min(cssW / artW, cssH / artH);
  const aw = Math.round(artW * ppu), ah = Math.round(artH * ppu);
  const ox = Math.round((cssW - aw) / 2), oy = Math.round((cssH - ah) / 2);

  // choose minor unit
  const candidates = [1,2,5,10,20,50,100,200,500,1000,2000];
  const targetPx = 14;
  let minorUnit = 10;
  let bestDiff = Infinity;
  for (const u of candidates) {
    const d = Math.abs(ppu * u - targetPx);
    if (ppu * u >= 8 && d < bestDiff) { bestDiff = d; minorUnit = u; }
  }
  const majorEvery = 10;

  // styles
  rtx.strokeStyle = 'rgba(255,255,255,0.75)';
  rtx.fillStyle = 'rgba(255,255,255,0.75)';
  rtx.lineWidth = 1;
  rtx.font = '10px "Segoe UI", sans-serif';

  rlx.strokeStyle = 'rgba(255,255,255,0.75)';
  rlx.fillStyle = 'rgba(255,255,255,0.75)';
  rlx.lineWidth = 1;
  rlx.font = '10px "Segoe UI", sans-serif';

  // ticks top
  for (let u = 0; u <= artW; u += minorUnit) {
    const x = Math.round(ox + u * ppu) + 0.5;
    if (x > cssW + 0.5) break;
    const isMajor = (Math.round(u) % (minorUnit * majorEvery) === 0);
    const len = isMajor ? 12 : 6;
    rtx.beginPath();
    rtx.moveTo(x, 22 - len + 0.5);
    rtx.lineTo(x, 22 + 0.5);
    rtx.stroke();
    if (isMajor) rtx.fillText(String(Math.round(u)), x + 2, 10);
  }

  // ticks left
  for (let v = 0; v <= artH; v += minorUnit) {
    const y = Math.round(oy + v * ppu) + 0.5;
    if (y > cssH + 0.5) break;
    const isMajor = (Math.round(v) % (minorUnit * majorEvery) === 0);
    const len = isMajor ? 12 : 6;
    rlx.beginPath();
    rlx.moveTo(22 - len + 0.5, y);
    rlx.lineTo(22 + 0.5, y);
    rlx.stroke();
    if (isMajor) {
      rlx.save();
      rlx.translate(4, y - 2);
      rlx.rotate(-Math.PI/2);
      rlx.fillText(String(Math.round(v)), 0, 0);
      rlx.restore();
    }
  }
}

// ========== Onion Skin Feature ==========
// state variables (add near other drawing vars)
let onionEnabled = JSON.parse(localStorage.getItem('ladaboard.onionEnabled') || 'true');
let onionBackCount = 2;
let onionFwdCount = 2;
// Track onion overlay state to avoid flicker on partial async loads
let lastOnionRefIndex = null;
let onionDrawnNeighbors = new Set();
function resetOnionOverlayState() {
  try { octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height); } catch(_) {}
  lastOnionRefIndex = null;
  onionDrawnNeighbors = new Set();
}

// helper to clamp
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// attach UI listeners (run once after DOM ready)
(function initOnionUI(){
  const toggle = document.getElementById('toggleOnion');
  const backInput = document.getElementById('onionBackInput');
  const fwdInput = document.getElementById('onionFwdInput');

  if(!toggle || !backInput || !fwdInput) {
    // still allow TL controls to manage state
  }

  function updateUI(){
    if (toggle) toggle.style.borderColor = onionEnabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
    if (backInput) backInput.value = String(onionBackCount);
    if (fwdInput) fwdInput.value = String(onionFwdCount);
    // also sync TL controls
    try { syncOnionUIElements(); } catch(_){ }
    // redraw edit canvas if open; otherwise refresh preview
    if(drawDialog.classList.contains('open')) { try { redrawPaths(); } catch(_){} }
    else { try { drawPreview(); } catch(_){} }
  }

  if (toggle) toggle.addEventListener('click', ()=>{ 
    onionEnabled = !onionEnabled;
    localStorage.setItem('ladaboard.onionEnabled', onionEnabled); // Save state
    resetOnionOverlayState();
    updateUI();
  });
  if (backInput) backInput.addEventListener('change', ()=>{ onionBackCount = clamp(Number(backInput.value), 0, 10); resetOnionOverlayState(); updateUI(); });
  if (fwdInput) fwdInput.addEventListener('change', ()=>{ onionFwdCount = clamp(Number(fwdInput.value), 0, 10); resetOnionOverlayState(); updateUI(); });
  updateUI();
})();

// NEW: External Onion UI (Timeline toolbar) + sync helper
function syncOnionUIElements(){
  const tlToggle = document.getElementById('tlToggleOnion');
  const tlBack = document.getElementById('tlOnionBack');
  const tlFwd = document.getElementById('tlOnionFwd');
  if (tlToggle) tlToggle.style.borderColor = onionEnabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  if (tlBack) tlBack.value = String(onionBackCount);
  if (tlFwd) tlFwd.value = String(onionFwdCount);
}

(function initTimelineOnion(){
  const tlToggle = document.getElementById('tlToggleOnion');
  const tlBack = document.getElementById('tlOnionBack');
  const tlFwd = document.getElementById('tlOnionFwd');
  if (tlToggle) tlToggle.addEventListener('click', ()=>{
    onionEnabled = !onionEnabled;
    localStorage.setItem('ladaboard.onionEnabled', onionEnabled);
    resetOnionOverlayState();
    syncOnionUIElements();
    // also reflect to modal button if present
    const toggle = document.getElementById('toggleOnion');
    if (toggle) toggle.style.borderColor = onionEnabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
    if(drawDialog.classList.contains('open')) { try { redrawPaths(); } catch(_){} } else { try { drawPreview(); } catch(_){} }
  });
  if (tlBack) tlBack.addEventListener('change', ()=>{
    onionBackCount = clamp(Number(tlBack.value), 0, 10);
    resetOnionOverlayState();
    syncOnionUIElements();
    const backInput = document.getElementById('onionBackInput');
    if (backInput) backInput.value = String(onionBackCount);
    if(drawDialog.classList.contains('open')) { try { redrawPaths(); } catch(_){} } else { try { drawPreview(); } catch(_){} }
  });
  if (tlFwd) tlFwd.addEventListener('change', ()=>{
    onionFwdCount = clamp(Number(tlFwd.value), 0, 10);
    resetOnionOverlayState();
    syncOnionUIElements();
    const fwdInput = document.getElementById('onionFwdInput');
    if (fwdInput) fwdInput.value = String(onionFwdCount);
    if(drawDialog.classList.contains('open')) { try { redrawPaths(); } catch(_){} } else { try { drawPreview(); } catch(_){} }
  });
  syncOnionUIElements();
})();

// draw single thumbnail image to ctx using existing drawImageCover util
function drawThumbInto(ctx, img, alpha, tint) {
  if(!img) return;
  ctx.save();
  ctx.globalAlpha = alpha;
  const cw = ctx.canvas && ctx.canvas.width ? ctx.canvas.width : drawCanvas.width;
  const ch = ctx.canvas && ctx.canvas.height ? ctx.canvas.height : drawCanvas.height;
  try { drawImageCover(ctx, img, cw, ch); } catch(e){}
  if(tint){
    ctx.fillStyle = tint;
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillRect(0,0,cw,ch);
  }
  ctx.restore();
}

// ensure Image object for a frame (cache it on frame._img)
function ensureFrameImage(frame){
  if(!frame) return null;
  if(frame._img && frame._img.src === frame.thumb) return frame._img;
  if(!frame.thumb) return null;
  const im = new Image();
  im.src = frame.thumb;
  // when loaded, request a redraw of the draw canvas if it's open and preview otherwise
  im.onload = ()=>{ 
    if(drawDialog.classList.contains('open')) { 
      try { 
        redrawPaths(); 
        // Prefer stable ref index captured by openDraw
        const idx = (typeof currentOnionRefIndex === 'number' && currentOnionRefIndex >= 0)
          ? currentOnionRefIndex
          : ((typeof editIndex === 'number' && editIndex != null) ? editIndex : state.frames.length);
        renderOnionSkinsOverlay(idx);
      } catch(_){} 
    }
    else { try { drawPreview(); } catch(_){} }
  };
  frame._img = im;
  return im;
}

// main onion rendering — draws backward (older) and forward frames to any ctx
function renderOnionSkinsToContext(ctx, refIndex){
  if(!onionEnabled) return;
  if(typeof refIndex !== 'number' || refIndex < 0) return;

  // backward frames: tinted warm lines
  for(let i = 1; i <= onionBackCount; i++){
    const idx = refIndex - i;
    if(idx < 0 || !state.frames[idx]) continue;
    const f = state.frames[idx];
    // prefer decoded bitmap, fallback to HTMLImage
    const srcImg = f._bmp || ensureFrameImage(f);
    if (!f._bmp) ensureFrameBitmap(f, refIndex); // kick async decode
    const alpha = 0.45 * (1 - (i-1) / Math.max(1, onionBackCount));
    const ok = drawOnionTintedCached(ctx, f, true, alpha);
    if (!ok) drawThumbInto(ctx, srcImg, alpha, 'rgba(255,120,90,0.18)');
  }

  // forward frames: tinted cool lines
  for(let i = 1; i <= onionFwdCount; i++){
    const idx = refIndex + i;
    if(idx >= state.frames.length || !state.frames[idx]) continue;
    const f = state.frames[idx];
    const srcImg = f._bmp || ensureFrameImage(f);
    if (!f._bmp) ensureFrameBitmap(f, refIndex);
    const alpha = 0.45 * (1 - (i-1) / Math.max(1, onionFwdCount));
    const ok = drawOnionTintedCached(ctx, f, false, alpha);
    if (!ok) drawThumbInto(ctx, srcImg, alpha, 'rgba(110,230,200,0.16)');
  }
}

// Fungsi baru untuk render onion skin ke overlay canvas terpisah
// Fungsi ini memastikan onion skin tidak tercampur dengan gambar utama dan tidak menimpa garis aktif
function renderOnionSkinsOverlay(refIndex) {
  if (!onionEnabled) {
    try { octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height); } catch(_) {}
    lastOnionRefIndex = null;
    onionDrawnNeighbors.clear();
    return;
  }
  if (typeof refIndex !== 'number' || refIndex < 0) return;

  // Build desired neighbor indices
  const desired = [];
  for (let i = 1; i <= onionBackCount; i++) { const idx = refIndex - i; if (idx >= 0 && idx < state.frames.length) desired.push(idx); }
  for (let i = 1; i <= onionFwdCount; i++) { const idx = refIndex + i; if (idx >= 0 && idx < state.frames.length) desired.push(idx); }
  const desiredSet = new Set(desired);

  // If ref index changed or set contains indices we no longer want, force a clean redraw
  let needFullRedraw = (lastOnionRefIndex !== refIndex);
  if (!needFullRedraw) {
    for (const drawn of onionDrawnNeighbors) {
      if (!desiredSet.has(drawn)) { needFullRedraw = true; break; }
    }
  }

  // Determine readiness
  const isReady = (idx)=>{
    const f = state.frames[idx];
    if (!f) return false;
    if (f._bmp) return true;
    if (f._img && f._img.complete && f._img.naturalWidth > 0) return true;
    return false;
  };
  const readySet = new Set(desired.filter(isReady));
  const allReady = desired.length > 0 ? desired.every(isReady) : true;

  if (needFullRedraw) {
    // Full clear and redraw what we have ready right now (avoid stale neighbors)
    octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
    onionDrawnNeighbors.clear();
    lastOnionRefIndex = refIndex;
    for (const idx of readySet) {
      try {
        const f = state.frames[idx];
        const srcImg = f._bmp || f._img;
        const rank = Math.abs(refIndex - idx);
        const alpha = 0.45 * (1 - (rank-1) / Math.max(1, rank <= onionBackCount ? onionBackCount : onionFwdCount));
        const warm = idx < refIndex;
        const ok = drawOnionTintedCached(octx, f, warm, alpha);
        if (!ok) drawThumbInto(octx, srcImg, alpha, warm ? 'rgba(255,120,90,0.18)' : 'rgba(110,230,200,0.16)');
        onionDrawnNeighbors.add(idx);
      } catch(_) {}
    }
  } else {
    // Incremental: draw only newly-ready neighbors, do not clear to avoid flicker
    for (const idx of readySet) {
      if (onionDrawnNeighbors.has(idx)) continue;
      try {
        const f = state.frames[idx];
        const srcImg = f._bmp || f._img;
        const rank = Math.abs(refIndex - idx);
        const alpha = 0.45 * (1 - (rank-1) / Math.max(1, rank <= onionBackCount ? onionBackCount : onionFwdCount));
        const warm = idx < refIndex;
        const ok = drawOnionTintedCached(octx, f, warm, alpha);
        if (!ok) drawThumbInto(octx, srcImg, alpha, warm ? 'rgba(255,120,90,0.18)' : 'rgba(110,230,200,0.16)');
        onionDrawnNeighbors.add(idx);
      } catch(_) {}
    }
    // If later all neighbors are ready, do a clean pass to normalize overlay
    if (allReady) {
      octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
      onionDrawnNeighbors.clear();
      for (const idx of desired) {
        try {
          const f = state.frames[idx];
          const srcImg = f._bmp || f._img;
          const rank = Math.abs(refIndex - idx);
          const alpha = 0.45 * (1 - (rank-1) / Math.max(1, rank <= onionBackCount ? onionBackCount : onionFwdCount));
          const warm = idx < refIndex;
          const ok = drawOnionTintedCached(octx, f, warm, alpha);
          if (!ok) drawThumbInto(octx, srcImg, alpha, warm ? 'rgba(255,120,90,0.18)' : 'rgba(110,230,200,0.16)');
          onionDrawnNeighbors.add(idx);
        } catch(_) {}
      }
    }
  }

  // punch out current strokes so active lines stay crisp (optional, mask is empty by default)
  try {
    const mask = createStrokeMaskCanvasFromContext(dctx, drawCanvas.width, drawCanvas.height);
    octx.save();
    octx.globalCompositeOperation = 'destination-out';
    octx.drawImage(mask, 0, 0);
    octx.restore();
  } catch(_){ }
}
let tool='pen', color='#000', size=6, drawing=false;
let baseImage = null; // Image object for background when editing an existing frame
let eraserMode = 'stroke'; // legacy, eraser mode toggle removed

// utilities
function createFrame(img=null){ return { thumb: img || null, desc: '', duration: Number(state.defaultDuration) || 24, music: null }; }
function safeNumber(v, fallback=0){ const n = Number(v); return Number.isFinite(n) ? n : fallback; }
function safeString(v){ return (typeof v === 'string') ? v : (v==null?'':String(v)); }
function normalizeFrames(arr){ if(!Array.isArray(arr)) return []; return arr.map(it => { if(!it) return createFrame(null); if(typeof it === 'string') return createFrame(it); return { thumb: it.thumb || null, desc: safeString(it.desc), duration: Math.max(1, safeNumber(it.duration, state.defaultDuration)), music: it.music || null }; }); }
function ellipsize(s, len){ if(!s) return ''; const st=String(s); return st.length>len?st.slice(0,len-1)+'…':st; }
function sanitizeFilename(s){ return String(s||'').replace(/[<>:"/\\|?*]+/g,'').slice(0,120); }
function pad2(n){ return String(n).padStart(2,'0'); }

// --- New helper: word-wrapping for canvas text ---
function wrapText(ctx, text, maxWidth) {
  const words = String(text || '').split(/\s+/);
  const lines = [];
  let currentLine = '';
  
  // Variabel baru untuk melacak lebar maksimum yang terukur
  let measuredMaxWidth = 0;

  for (let word of words) {
    const testLine = currentLine ? currentLine + ' ' + word : word;
    const metrics = ctx.measureText(testLine);
    
    if (metrics.width > maxWidth && currentLine !== '') {
      lines.push(currentLine);
      // Perbarui lebar maksimal dengan lebar baris saat ini
      measuredMaxWidth = Math.max(measuredMaxWidth, ctx.measureText(currentLine).width);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  
  if (currentLine) {
    lines.push(currentLine);
    // Perbarui lebar maksimal untuk baris terakhir
    measuredMaxWidth = Math.max(measuredMaxWidth, ctx.measureText(currentLine).width);
  }

  // Kembalikan objek yang berisi 'lines' dan 'maxWidth' yang sudah dihitung
  return { lines, maxWidth: measuredMaxWidth };
}

// --- Helper for creating bitmap from source ---
async function createBitmapFromSrc(src) {
  try {
    if (window.createImageBitmap) {
      const res = await fetch(src);
      const blob = await res.blob();
      const bmp = await createImageBitmap(blob);
      return bmp;
      } else {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    }
  } catch (err) {
    try {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    } catch(e){
      console.warn('createBitmapFromSrc failed for', src, e);
      return null;
    }
  }
}

// --- Generator halaman A4 Jepang 100% ---
async function generateStoryboardPages() {
  const dpi = 300;
  const mmToPx = mm => Math.round(mm * dpi / 25.4);
  const pageW = mmToPx(210); // 2480 px
  const pageH = mmToPx(297); // 3508 px

  const perPage = 5;
  const thumbW = mmToPx(90);
  const thumbH = mmToPx(50.6);
  const marginX = mmToPx(10);
  const startY = mmToPx(25);
  const rowH = mmToPx(55);

  const canvases = [];

  // timeline helpers
  const fpsNow = Math.max(1, state.fps || 24);
  const totalFramesCount = state.frames.reduce((a,b)=> a + Math.max(1, safeNumber(b?.duration, state.defaultDuration)), 0);
  const totalSecAll = totalFramesCount / fpsNow;
  const formatTimeMMSS = (sec)=>{ sec = Math.max(0, Math.floor(sec||0)); const m = Math.floor(sec/60); const s = sec % 60; return pad2(m)+":"+pad2(s); };

  for (let p = 0; p < Math.ceil(state.frames.length / perPage); p++) {
    const c = document.createElement('canvas');
    c.width = pageW;
    c.height = pageH;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, pageW, pageH);

    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;

    // Kolom: CUT, 画面, 動き, セリフ・音, 秒
    const colCut = mmToPx(15);
    const colImg = thumbW + mmToPx(5);
    const colAction = mmToPx(50);
    const colDialogue = mmToPx(50);
    const colSec = mmToPx(15);
    const colX = [
      marginX,
      marginX + colCut,
      marginX + colCut + colImg,
      marginX + colCut + colImg + colAction,
      marginX + colCut + colImg + colAction + colDialogue,
      pageW - marginX
    ];

    // Garis vertikal
    for (let x of colX) {
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, startY + perPage * rowH);
      ctx.stroke();
    }

    // Garis horizontal
    for (let r = 0; r <= perPage; r++) {
      const y = startY + r * rowH;
      ctx.beginPath();
      ctx.moveTo(marginX, y);
      ctx.lineTo(pageW - marginX, y);
      ctx.stroke();
    }

    // Label kolom (Jepang saja)
    ctx.font = `${mmToPx(4)}px sans-serif`;
    ctx.fillStyle = '#000';
    ctx.fillText('カット', colX[0] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('画面', colX[1] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('動き', colX[2] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('セリフ・音', colX[3] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('秒', colX[4] + mmToPx(2), startY - mmToPx(2));

    // Isi baris
    for (let r = 0; r < perPage; r++) {
      const idx = p * perPage + r;
      if (idx >= state.frames.length) break;
      const f = state.frames[idx];
      const y = startY + r * rowH;

      // Cut number
      ctx.font = `${mmToPx(4.5)}px sans-serif`;
      ctx.fillText(String(idx + 1).padStart(2, '0'), colX[0] + mmToPx(2), y + mmToPx(5));

      // Frame image + grid merah
      ctx.strokeStyle = '#000';
      ctx.strokeRect(colX[1] + mmToPx(1), y + mmToPx(1), thumbW, thumbH);
      ctx.strokeStyle = 'rgba(255,0,0,0.5)';
      ctx.lineWidth = 1;
      for (let gx = 1; gx < 3; gx++) {
        ctx.beginPath();
        ctx.moveTo(colX[1] + mmToPx(1) + (thumbW / 3) * gx, y + mmToPx(1));
        ctx.lineTo(colX[1] + mmToPx(1) + (thumbW / 3) * gx, y + mmToPx(1) + thumbH);
        ctx.stroke();
      }
      for (let gy = 1; gy < 3; gy++) {
        ctx.beginPath();
        ctx.moveTo(colX[1] + mmToPx(1), y + mmToPx(1) + (thumbH / 3) * gy);
        ctx.lineTo(colX[1] + mmToPx(1) + thumbW, y + mmToPx(1) + (thumbH / 3) * gy);
        ctx.stroke();
      }
      if (f.thumb) {
        const img = await createBitmapFromSrc(f.thumb);
        ctx.drawImage(img, colX[1] + mmToPx(1), y + mmToPx(1), thumbW, thumbH);
      }

      // 動き
      ctx.fillStyle = '#000';
      ctx.font = `${mmToPx(3.5)}px sans-serif`;
      wrapText(ctx, f.desc || '', colAction - mmToPx(4)).lines.forEach((line, li) => {
        ctx.fillText(line, colX[2] + mmToPx(2), y + mmToPx(4) + li * mmToPx(4));
      });

      // セリフ・音
      if (f.music) {
        const name = (f.musicName && String(f.musicName)) || (f.music.split('/').pop().split('?')[0]);
        const startFrames = state.frames.slice(0, idx).reduce((a,b)=> a + Math.max(1, safeNumber(b?.duration, state.defaultDuration)), 0);
        const startSec = startFrames / fpsNow;
        const endSec = (typeof f.musicDurationSec === 'number' && isFinite(f.musicDurationSec))
          ? Math.min(totalSecAll, startSec + f.musicDurationSec)
          : null;
        const timeText = endSec == null
          ? `played at ${formatTimeMMSS(startSec)} to end`
          : `played at ${formatTimeMMSS(startSec)} to ${formatTimeMMSS(endSec)}`;
        wrapText(ctx, `BGM: ${name} ${timeText}`, colDialogue - mmToPx(4)).lines.forEach((line, li) => {
          ctx.fillText(line, colX[3] + mmToPx(2), y + mmToPx(4) + li * mmToPx(4));
        });
      }

      // 秒
      const secs = splitDurationFrames(f.duration, state.fps).sec;
      ctx.font = `${mmToPx(4)}px sans-serif`;
      ctx.fillText(`${secs}`, colX[4] + mmToPx(2), y + mmToPx(5));
    }

    canvases.push(c);
  }
  return canvases;
}

// list rendering (edit button only for selected frame and smaller)
function renderList(){ 
  framesList.innerHTML=''; 
  state.frames = normalizeFrames(state.frames); 

  // Empty state: jika belum ada frame sama sekali
  if (!state.frames || state.frames.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'empty-state';
    empty.innerHTML = `
      <div class="small-line">No frames yet</div>
      <button class="big-btn big-animated" id="createFirstFrame"><i class='bx bx-plus'></i> Create New Frame</button>
      <div class="small-line">Click to draw a new frame or upload an image</div>
    `;
    framesList.appendChild(empty);

    // sambungkan tombol besar ke tombol addFrame (pakai existing behavior)
    const createBtn = document.getElementById('createFirstFrame');
    if (createBtn) {
      createBtn.addEventListener('click', () => {
        // trigger the same action as the existing +New Frame button
        document.getElementById('addFrame').click();
      });
    }

    updateProjectInfo(); 
    highlightSelected();
    return;
  }

  // jika ada frames -> rendering normal (lanjutkan dengan kode semula)
  state.frames.forEach((f,i)=>{
    const el=document.createElement('div'); el.className='frame'; el.draggable=true; el.dataset.index=i;
    const thumbHTML = f.thumb 
    ? `<img src="${f.thumb}" style="width:100%;height:100%;object-fit:cover"/>` 
    : 'Empty';

    const showEdit = (i === state.selected);
    el.innerHTML = `
    <div class="thumb">${thumbHTML}</div>
    <div class="meta">
      <input class="frame-title truncate" type="text" value="${escapeHtml(f.desc)}" placeholder="Desc" autocomplete="off" />
      ${showEdit?`<div style="display:flex;gap:4px;margin-top:4px">
        <button class="icon-btn edit-frame" title="Edit"><i class='bx bx-edit'></i></button>
        <button class="icon-btn frame-music-btn ${f.music ? 'has-music' : ''}" title="${f.music ? 'Remove Music' : 'Add Music'}"><i class='bx ${f.music ? 'bx-music' : 'bx-music'}'></i></button>
      </div>`:''}
    </div>
    <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
      <div class="small-muted">${i+1}</div>
      <div class="duration-group">
        <input class="input dur-sec" type="number" min="0" step="0.1" style="width:56px" value="${(function(){ const d=splitDurationFrames(safeNumber(f.duration,state.defaultDuration), state.fps); return d.sec; })()}" autocomplete="off" />
        <span class="small-muted">s</span>
        <input class="input dur-frm" type="number" min="0" step="1" style="width:56px" value="${(function(){ const d=splitDurationFrames(safeNumber(f.duration,state.defaultDuration), state.fps); return d.frm; })()}" autocomplete="off" />
        <span class="small-muted">f</span>
      </div>
    </div>`;
    framesList.appendChild(el);
    
    // Event delegation: any click within the frame card selects the frame first
    el.addEventListener('mousedown', (e) => {
      // Only select frame if clicking on non-interactive elements or if no frame is currently selected
      const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
      const isButton = e.target.tagName === 'BUTTON' || e.target.closest('button');
      
      if (!isInput && !isButton) {
        // Clicking on non-interactive areas always selects frame
        selectFrame(i, e);
      } else if (state.selected !== i) {
        // Clicking on inputs/buttons selects frame only if it's not already selected
        selectFrame(i, e);
      }
    });
    
    // Keep the old click handler for better compatibility
    el.addEventListener('click', (e) => {
      // Only handle frame selection if not clicking on interactive elements
      const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
      const isButton = e.target.tagName === 'BUTTON' || e.target.closest('button');
      
      if (!isInput && !isButton) {
        selectFrame(i, e);
      }
    });
    
    el.addEventListener('dragstart',e=>{
      const a = document.activeElement;
      const inputting = a && (a.tagName === 'INPUT' || a.tagName === 'TEXTAREA' || a.isContentEditable);
      if (inputting) { e.preventDefault(); return; }
      e.dataTransfer.setData('text/plain',i);
    });
    el.addEventListener('dragover',e=>e.preventDefault());
    el.addEventListener('drop',e=>{e.preventDefault(); const from=Number(e.dataTransfer.getData('text/plain')); const to=Number(el.dataset.index); reorder(from,to);});
    
    const ti = el.querySelector('.frame-title');
    if (ti) {
      // Remove stopPropagation from mousedown since we want frame selection to happen first
      // ti.addEventListener('mousedown', ev => ev.stopPropagation());
      ti.addEventListener('click', ev => ev.stopPropagation());
      ti.addEventListener('focus', ev => ev.stopPropagation());
      ti.addEventListener('input', ev => {
        state.frames[i].desc = ev.target.value;
        if (i === state.selected) descInput.value = ev.target.value;
        saveAuto();
        // Update preview secara real-time jika frame yang diedit adalah yang sedang dipilih
        if (i === state.selected) {
          drawPreview();
        }
      });
    }

    const secEl = el.querySelector('.dur-sec');
    const frmEl = el.querySelector('.dur-frm');
    if (secEl && frmEl) {
      // Remove stopPropagation from mousedown since we want frame selection to happen first
      // const stop = ev => ev.stopPropagation();
      // secEl.addEventListener('mousedown', stop);
      // frmEl.addEventListener('mousedown', stop);
      secEl.addEventListener('click', ev => ev.stopPropagation());
      secEl.addEventListener('focus', ev => ev.stopPropagation());
      const syncAndSave = () => {
        const newDur = Math.max(1, composeDurationFrames(secEl.value, frmEl.value, state.fps));
        state.frames[i].duration = newDur;
        const parts = splitDurationFrames(newDur, state.fps);
        secEl.value = String(parts.sec);
        frmEl.value = String(parts.frm);
        if (i === state.selected) {
          durationSecInput.value = String(parts.sec);
          durationFrmInput.value = String(parts.frm);
        }
        updateProjectInfo();
        saveAuto();
      };
      secEl.addEventListener('change', syncAndSave);
      frmEl.addEventListener('change', syncAndSave);
      secEl.addEventListener('blur', syncAndSave);
      frmEl.addEventListener('blur', syncAndSave);
      const onEnter = ev => { if (ev.key === 'Enter') { ev.preventDefault(); syncAndSave(); secEl.blur(); frmEl.blur(); } };
      secEl.addEventListener('keydown', onEnter);
      frmEl.addEventListener('keydown', onEnter);
    }
    
    // Handle edit button
    const editBtn = el.querySelector('.edit-frame');
    if(editBtn){
      editBtn.addEventListener('click', e => {
        e.stopPropagation();
        editIndex = i;
        // reuse cached Image object (ensureFrameImage will create or return frame._img)
        const img = ensureFrameImage(state.frames[i]);
        // pass Image to openDraw -> openDraw handles complete/onload
        openDraw(img);
      });
    }
    
    // Handle music button
    const musicBtn = el.querySelector('.frame-music-btn');
    if(musicBtn){
      // Hover effects for music button
      musicBtn.addEventListener('mouseenter', () => {
        if (f.music) {
          musicBtn.innerHTML = "<i class='bx bx-x'></i>";
          musicBtn.title = "Remove Music";
        }
      });
      
      musicBtn.addEventListener('mouseleave', () => {
        if (f.music) {
          musicBtn.innerHTML = "<i class='bx bx-music'></i>";
          musicBtn.title = "Remove Music";
        }
      });
      
      // Click handler for music button
      musicBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (f.music) {
          // Remove music
          // Stop audio if it's currently playing from this frame
          if (musicAudio && currentMusicUrl === f.music) {
            musicAudio.pause();
            musicAudio = null;
            currentMusicUrl = null;
          }
          f.music = null;
          f.musicName = null;
          f.musicDurationSec = null;
          saveAuto();
          renderList();
        } else {
          // Add music
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = 'audio/*';
          input.style.display = 'none';
          input.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            const objectUrl = URL.createObjectURL(file);
            f.music = objectUrl;
            f.musicName = file.name || null;
            // Probe duration
            try {
              const au = document.createElement('audio');
              au.preload = 'metadata';
              au.src = objectUrl;
              au.onloadedmetadata = () => {
                if (isFinite(au.duration)) {
                  f.musicDurationSec = au.duration;
                  saveAuto();
                }
              };
            } catch(_) {}
            saveAuto();
            renderList();
          });
          document.body.appendChild(input);
          input.click();
          input.remove();
        }
      });
    }
  }); 
  updateProjectInfo(); 
  highlightSelected(); 
}

function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

// helper conversions between frames and s+f
function splitDurationFrames(totalFrames, fps){
  const f = Math.max(1, Number(totalFrames)||0);
  const rate = Math.max(1, Number(fps)||24);
  const sec = Math.floor(f / rate);
  const frm = f - sec * rate;
  return { sec, frm };
}
function composeDurationFrames(sec, frm, fps){
  const rate = Math.max(1, Number(fps)||24);
  const s = Number(sec) || 0;
  const fr = Math.max(0, Math.floor(Number(frm) || 0));
  return Math.max(1, Math.round(s * rate) + fr);
}

// parse flexible text like "02", "02s", "35f" according to defaultKind ("sec" or "frm")
function valueTextToFrames(text, fps, defaultKind){
  const rate = Math.max(1, Number(fps)||24);
  const raw = String(text||'').trim().toLowerCase();
  if (!raw) return 0;
  let kind = defaultKind === 'frm' ? 'frm' : 'sec';
  let numStr = raw;
  if (raw.endsWith('s')) { kind = 'sec'; numStr = raw.slice(0,-1); }
  else if (raw.endsWith('f')) { kind = 'frm'; numStr = raw.slice(0,-1); }
  const n = Number(numStr);
  if (!Number.isFinite(n)) return 0;
  if (kind === 'sec') {
    // seconds can be fractional; convert to frames
    return Math.max(0, Math.round(n * rate));
  } else {
    // frames; integer
    return Math.max(0, Math.floor(n));
  }
}
function normalizePairToFrames(secText, frmText, fps){
  const fromSec = valueTextToFrames(secText, fps, 'sec');
  const fromFrm = valueTextToFrames(frmText, fps, 'frm');
  const total = Math.max(1, fromSec + fromFrm);
  return total;
}

function reorder(from,to){ 
  if(from===to) return; 
  if(from<0||to<0||from>=state.frames.length||to>state.frames.length) return; 
  // Capture timeline positions before reorder for move animation
  let beforeMap = null;
  try { beforeMap = computeFramePositions(); } catch(_){}
  pushHistory(); 
  const [it] = state.frames.splice(from,1); 
  state.frames.splice(to,0,it); 
  renderList(); 
  selectFrame(Math.min(to,state.frames.length-1)); 
  saveAuto(); 
  try { setTimelineSize(); } catch(_){ }
  // Setup move animation on timeline
  try {
    const afterMap = computeFramePositions();
    tl.moveAnim = { fromMap: beforeMap || new Map(), toMap: afterMap, start: performance.now(), duration: 320 };
    animateTimelineMove();
  } catch(_){}
  try { renderTimeline(); } catch(_){ }
  // Sidebar reorder pop animation
  try {
    setTimeout(()=>{
      const el = framesList.children[to];
      if (el) {
        el.classList.add('reordered');
        el.addEventListener('animationend', ()=> el.classList.remove('reordered'), { once: true });
      }
    }, 0);
  } catch(_){}
  // Timeline flash highlight (handled in render via tl.flashUntil)
  try {
    tl.flashIndex = to; tl.flashUntil = performance.now() + 450; animateTimelineFlash();
  } catch(_){}
}

function highlightSelected(){
  Array.from(framesList.children).forEach((el, idx) => {
    if (selectedFrames.has(idx)) { el.classList.add('selected'); } else { el.classList.remove('selected'); }
    if (playing && idx === currentFrameIndex) { el.classList.add('playing'); } else { el.classList.remove('playing'); }
  });
}

function clampIndex(i){ if(typeof i!=='number' || !Number.isFinite(i)) return -1; if(state.frames.length===0) return -1; return Math.min(Math.max(0,i), state.frames.length-1); }

function selectFrame(i, e = {}) {
    const isShift = e.shiftKey;
    const isCtrl = e.ctrlKey || e.metaKey;
    const clickedElement = e.target;

    // Handle selection logic
    if (isShift && selectedFrames.size > 0) {
        const lastSelected = state.selected;
        const start = Math.min(lastSelected, i);
        const end = Math.max(lastSelected, i);
        selectedFrames.clear();
        for (let j = start; j <= end; j++) {
            selectedFrames.add(j);
        }
    } else if (isCtrl) {
        if (selectedFrames.has(i)) {
            selectedFrames.delete(i);
        } else {
            selectedFrames.add(i);
        }
    } else {
        selectedFrames.clear();
        if (i >= 0) selectedFrames.add(i);
    }

    state.selected = clampIndex(i); // The last clicked frame is the primary selection

    // Handle musik untuk frame yang dipilih (jika sedang dalam playback)
    if (playing && state.selected >= 0) {
        handleMusicForFrame(state.selected);
    }

    // Re-render the whole list to update button visibility and highlights
    renderList(); 

    // Update the side panel inputs
    if (state.selected === -1) {
        descInput.value = '';
        durationSecInput.value = '0';
        durationFrmInput.value = String(state.defaultDuration);
    } else {
        const f = state.frames[state.selected] || createFrame(null);
        descInput.value = f.desc || '';
        const parts = splitDurationFrames(safeNumber(f.duration, state.fps), state.fps);
        durationSecInput.value = String(parts.sec);
        durationFrmInput.value = String(parts.frm);
    }
    
    // If clicking on an input element, focus it after selection
    if (clickedElement && (clickedElement.tagName === 'INPUT' || clickedElement.tagName === 'TEXTAREA')) {
        if (document.activeElement !== clickedElement) {
            setTimeout(() => {
                try {
                    clickedElement.focus();
                    if (clickedElement.type === 'text' || clickedElement.type === 'number') {
                        clickedElement.select();
                    }
                } catch (e) {}
            }, 0);
        }
    }
    
    drawPreview();

    // Keep timeline selection in sync without moving playhead
    try {
      if (typeof tl !== 'undefined') {
        tl.selection = new Set(Array.from(selectedFrames));
        renderTimeline();
      }
    } catch(_) { }

    // Auto-close sidebar on mobile after selection for better UX
    try { if (window.innerWidth <= 1024) { document.body.classList.remove('sidebar-open'); } } catch(_){}
}


function updateProjectInfo(){ totalFramesEl.textContent = String(state.frames.length); const totalFramesCount = state.frames.reduce((a,b)=>a + safeNumber(b?.duration,0),0); const seconds = Math.floor(totalFramesCount/Math.max(1,state.fps)); projectLength.textContent = seconds+'s'; }

// drawing to canvas helpers
function drawImageCover(ctx,img,w,h){ const ar = (img.width||1)/(img.height||1); const ar2 = w/h; let sx=0,sy=0,sw=img.width||w,sh=img.height||h; if(ar>ar2){ const nw=(img.height||h)*ar2; sx=((img.width||w)-nw)/2; sw=nw; } else { const nh = (img.width||w)/ar2; sy=((img.height||h)-nh)/2; sh=nh; } try{ ctx.drawImage(img,sx,sy,sw,sh,0,0,w,h); }catch(e){} }

// ----- Replaced drawOverlayCanvas with wrapping-capable version -----
function drawOverlayCanvas(title, elapsedMs) {
  const ctx = pctx;
  ctx.save();

  // Title (top-left)
  ctx.textBaseline = 'top';
  ctx.font = 'bold 44px "Impact", "Segoe UI", sans-serif';
  ctx.lineWidth = 8;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const tx = 18, ty = 12;
  ctx.strokeText(title, tx, ty);
  ctx.fillText(title, tx, ty);

  // Time (bottom-left)
  const seconds = Math.floor(elapsedMs / 1000);
  const framesSinceStart = Math.floor(elapsedMs * state.fps / 1000);
  const frameInSecond = framesSinceStart % state.fps;
  const timeText = pad2(seconds) + 's + ' + String(frameInSecond).padStart(2,'0') + 'f';
  ctx.font = 'bold 52px "Segoe UI", sans-serif';
  ctx.lineWidth = 10;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const bx = 18, by = preview.height - 100;
  ctx.strokeText(timeText, bx, by);
  ctx.fillText(timeText, bx, by);

  // small fps under it
  const fpsText = 'FPS ' + state.fps;
  ctx.font = 'bold 28px "Segoe UI", sans-serif';
  ctx.lineWidth = 8;
  ctx.strokeText(fpsText, bx, by + 68);
  ctx.fillText(fpsText, bx, by + 68);

  // compute reserved left width (timestamp area) so description won't overlap
  let reservedLeft = 18; // left margin
  ctx.font = 'bold 52px "Segoe UI", sans-serif';
  const wTime = ctx.measureText(timeText).width;
  ctx.font = 'bold 28px "Segoe UI", sans-serif';
  const wFps = ctx.measureText(fpsText).width;
  reservedLeft += Math.max(wTime, wFps) + 24; // add gap after timestamp

  // Description (bottom-right) - multiline wrapping + auto box sizing
  const desc = state.frames[state.selected]?.desc || '';
  if (desc) {
    ctx.font = '24px "Segoe UI", sans-serif';
    const pad = 16;
    const lineHeight = 32; // increased for readability
    const maxBoxAllowed = Math.max(120, preview.width - reservedLeft - 18); // keep clear of timestamp
    const maxLineWidth = Math.max(120, maxBoxAllowed - pad*2);

    const wrap = wrapText(ctx, desc, maxLineWidth);
    const lines = wrap.lines;
    const textW = wrap.maxWidth;

    const boxW = Math.min(maxBoxAllowed, Math.max(120, textW + pad*2));
    const boxH = lines.length * lineHeight + pad * 2;

    const rx = preview.width - boxW - 18;
    const ry = preview.height - boxH - 18;

    // background (semi translucent)
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(rx, ry, boxW, boxH);

    // draw each line
    ctx.fillStyle = '#fff';
    for (let i = 0; i < lines.length; i++) {
      const ly = ry + pad + i * lineHeight + 4;
      ctx.fillText(lines[i], rx + pad, ly);
    }
  }

  ctx.restore();
}

// main preview draw
function drawPreview(){ 
  const sel = state.selected; 
  if(sel<0||!state.frames[sel]){ 
    // nothing selected → draw empty bg + guides/overlays
    pctx.clearRect(0,0,preview.width,preview.height);
    pctx.fillStyle='#0b0b0b'; 
    pctx.fillRect(0,0,preview.width,preview.height); 
    try { drawPreviewOutsideRulers(); } catch(_){ }
    try {
      const temp = document.createElement('canvas'); temp.width = preview.width; temp.height = preview.height; const tx = temp.getContext('2d');
      renderOnionSkinsToContext(tx, 0);
      pctx.drawImage(temp,0,0);
    } catch(_){ }
    drawGuides(pctx, preview.width, preview.height);
    drawOverlayCanvas('No cut selected',0); 
    return; 
  }

  const f = state.frames[sel]; 
  primeCacheAround(sel);
  const img = f.thumb ? ensureFrameImage(f) : null;
  const ready = !!(img && img.complete && img.naturalWidth > 0);

  // choose base image to draw to avoid flicker while new image is decoding
  const baseToDraw = ready ? img : (lastPreviewImage || null);

  pctx.clearRect(0,0,preview.width,preview.height);
  if (baseToDraw) {
    try { drawImageCover(pctx, baseToDraw, preview.width, preview.height); } catch(_){ }
  } else { 
    pctx.fillStyle='#111'; 
    pctx.fillRect(0,0,preview.width,preview.height); 
  }

  // Render onion skins above base
    try {
      const temp = document.createElement('canvas'); temp.width = preview.width; temp.height = preview.height; const tx = temp.getContext('2d');
      renderOnionSkinsToContext(tx, sel);
      pctx.drawImage(temp,0,0);
    } catch(_){ }

  // Guides + rulers + overlay
    drawGuides(pctx, preview.width, preview.height);
  try { drawPreviewOutsideRulers(); } catch(_){ }
    drawOverlayCanvas('Cut no. ' + (sel+1), 0); 

  if (ready) { lastPreviewImage = img; lastPreviewIndex = sel; }
}

// drawing modal (improved)
function openDraw(initial = null){
  drawDialog.classList.add('open');
  resetOnionOverlayState();
  // reset drawing state and initialize new bitmap system
  baseImage = null;
  
  // Clear onion skin overlay saat modal dibuka
  octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
  
  // Pastikan ukuran semua kanvas overlay sama
  onionCanvas.width = drawCanvas.width;
  onionCanvas.height = drawCanvas.height;
  guideCanvas.width = drawCanvas.width;
  guideCanvas.height = drawCanvas.height;
  insertCanvas.width = drawCanvas.width;
  insertCanvas.height = drawCanvas.height;
  
  // Initialize new bitmap drawing system
  initDrawingCanvas();

  // clear canvas background
  dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  dctx.fillStyle = '#fff';
  dctx.fillRect(0,0,drawCanvas.width,drawCanvas.height);
  // ensure visual background is white so eraser holes don't look black
  try { drawCanvas.style.background = '#ffffff'; } catch(_){}

  // Prefetch onion neighbors for the frame being edited (prioritize immediate)
  try { 
    const idx = (typeof editIndex === 'number' && editIndex != null) ? editIndex : state.frames.length;
    currentOnionRefIndex = idx;
    if (idx != null) primeOnionNeighbors(idx);
  } catch(_){}

  // draw initial onion
  try { 
    const idx = (typeof editIndex === 'number' && editIndex != null) ? editIndex : state.frames.length;
    currentOnionRefIndex = idx;
    renderOnionSkinsOverlay(idx); 
  } catch(_){ }

  // sync and draw external rulers
  try { drawOutsideRulers(); } catch(_){ }

  function scheduleRedraw() {
    // draw after browser paint; fallback in 40ms for rare races
    requestAnimationFrame(() => {
      try { 
        redrawPaths(); 
        const idx = (typeof editIndex === 'number' && editIndex != null) ? editIndex : state.frames.length;
        currentOnionRefIndex = idx;
        renderOnionSkinsOverlay(idx); 
        drawOutsideRulers(); 
      } catch(e){}
      setTimeout(() => {
        try { 
          redrawPaths(); 
          const idx = (typeof editIndex === 'number' && editIndex != null) ? editIndex : state.frames.length;
          currentOnionRefIndex = idx;
          renderOnionSkinsOverlay(idx); 
          drawOutsideRulers(); 
        } catch(e){}
      }, 40);
    });
  }

  if (initial instanceof HTMLImageElement) {
    baseImage = initial;
    if (baseImage.complete) {
      scheduleRedraw();
    } else {
      baseImage.onload = () => scheduleRedraw();
    }
  } else if (typeof initial === 'string' && initial) {
    // if passed a URL, create image but prefer reuse via ensureFrameImage outside
    baseImage = new Image();
    // optional: baseImage.crossOrigin = 'anonymous'; // if remote and CORS allowed
    baseImage.onload = () => scheduleRedraw();
    baseImage.src = initial;
  } else {
    scheduleRedraw();
  }

  // Save initial state after everything is set up
  setTimeout(() => {
    saveCanvasState();
  }, 100);

  // focus canvas so keyboard shortcuts work
  try { drawCanvas.focus(); } catch(e){}
}
function closeDraw(){ 
  drawDialog.classList.remove('open'); 
  baseImage = null; 
  // Clear onion skin dan guide overlay saat modal ditutup
  octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
  gctx.clearRect(0, 0, guideCanvas.width, guideCanvas.height); // <-- Baris baru
  ictx.clearRect(0, 0, insertCanvas.width, insertCanvas.height);
  insertImage = null;
  applyImageBtn && (applyImageBtn.style.display = 'none');
  // restore visual background
  try { drawCanvas.style.background = 'transparent'; } catch(_){}
  // hide outside rulers
  try { const rt = document.getElementById('rulerTop'); const rl = document.getElementById('rulerLeft'); if (rt) rt.style.display = 'none'; if (rl) rl.style.display = 'none'; } catch(_){ }
  // clear stable ref index
  currentOnionRefIndex = null;
  resetOnionOverlayState();
}

// toolbar events
document.querySelectorAll('.canvas-toolbar [data-tool]').forEach(b=>b.addEventListener('click',()=>{ document.querySelectorAll('.canvas-toolbar [data-tool]').forEach(x=>x.classList.remove('active')); b.classList.add('active'); tool=b.dataset.tool; }));
document.getElementById('colorPicker').addEventListener('input',e=>{color=e.target.value; brushColor = color;});
document.getElementById('sizeRange').addEventListener('input',e=>{size=Number(e.target.value)||6; brushSize = size;});

// eraser mode toggle button
// eraser mode toggle removed by request

function hexToRgba(hex) {
    let c;
    if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
        c= hex.substring(1).split('');
        if(c.length== 3){
            c= [c[0], c[0], c[1], c[1], c[2], c[2]];
        }
        c= '0x'+c.join('');
        return { r: (c>>16)&255, g: (c>>8)&255, b: c&255, a: 255 };
    }
    const rgba = hex.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if(rgba){
      return { r: parseInt(rgba[1]), g: parseInt(rgba[2]), b: parseInt(rgba[3]), a: rgba[4] ? Math.round(parseFloat(rgba[4])*255) : 255 };
    }
    return {r:0,g:0,b:0,a:255};
}

function floodFill(ctx, x, y, fillColor) {
    const canvas = ctx.canvas;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const { width, height } = canvas;
    const stack = [[Math.floor(x), Math.floor(y)]];
    const targetColor = getColorAtPixel(imageData, Math.floor(x), Math.floor(y));
    const visited = new Uint8Array(width * height);

    if (colorsMatch(targetColor, fillColor)) {
        return;
    }

    const tolerance = 32; // color matching tolerance

    while (stack.length) {
        const [px, py] = stack.pop();
        if (px < 0 || px >= width || py < 0 || py >= height) {
            continue;
        }
        const offset = py * width + px;
        if(visited[offset]) continue;

        const currentColor = getColorAtPixel(imageData, px, py);
        if (colorsMatch(currentColor, targetColor, tolerance)) {
            setColorAtPixel(imageData, px, py, fillColor);
            visited[offset] = 1;
            stack.push([px + 1, py]);
            stack.push([px - 1, py]);
            stack.push([px, py + 1]);
            stack.push([px, py - 1]);
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

function getColorAtPixel(imageData, x, y) {
    const { width, data } = imageData;
    const index = (y * width + x) * 4;
    return { r: data[index], g: data[index + 1], b: data[index + 2], a: data[index + 3] };
}

function setColorAtPixel(imageData, x, y, color) {
    const { width, data } = imageData;
    const index = (y * width + x) * 4;
    data[index] = color.r;
    data[index + 1] = color.g;
    data[index + 2] = color.b;
    data[index + 3] = color.a;
}

function colorsMatch(a, b, tolerance=0) {
    return Math.abs(a.r - b.r) <= tolerance && Math.abs(a.g - b.g) <= tolerance && Math.abs(a.b - b.b) <= tolerance && Math.abs(a.a - b.a) <= tolerance;
}

// pointer handlers — enhanced for eraser "pick" mode and baseImage retention
drawCanvas.addEventListener('pointerdown',async e=>{
  if (tool === 'pen') {
    const p = toLocal(e);
    lastBrushPoint = p;
    drawing = true;
    drawCanvas.setPointerCapture(e.pointerId);
    // Don't save state here - wait until drawing is complete
    return;
  }
  
  if (tool === 'eraser') {
    const p = toLocal(e);
    lastBrushPoint = p;
    drawing = true;
    drawCanvas.setPointerCapture(e.pointerId);
    
    if (eraserMode === 'pick') {
      // Save state before erasing for pick mode
      saveCanvasState();
      // For bitmap-based system, we'll use a simple circular eraser at the click point
      // This creates a circular transparent area
      eraseDot(p);
      return;
    } else {
      // Stroke mode - start erasing with an initial dot to avoid missing the first tap
      eraseDot(p);
      return;
    }
  }
  
  const p=toLocal(e);
  if(tool === 'bucket'){
    // Save state before flood fill
    saveCanvasState();
    const rgbaColor = hexToRgba(color);
    floodFill(dctx, p.x, p.y, rgbaColor);
    return;
  }

  // For rectangle and ellipse tools, we'll implement bitmap-based drawing
  if (tool === 'rect' || tool === 'ellipse') {
    drawing=true; 
    drawCanvas.setPointerCapture(e.pointerId);
    // Store the starting point for the shape
    lastBrushPoint = p;
    return;
  }
});
 
// --- Localized Pointer Events for Drawing (Fix for sticky pen bug) ---
const stopDrawing = (e) => {
  if (!drawing) return;
  drawing = false;
  drawCanvas.releasePointerCapture(e.pointerId);
  
  // Don't save state here - it's handled by specific tool handlers
};

drawCanvas.addEventListener('pointermove', e => {
  if (tool === 'pen') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      drawBrushStroke(lastBrushPoint, p, e.pressure || 0.5);
      lastBrushPoint = p;
      // Don't save state here - wait until drawing is complete
    }
    return;
  }
  
  if (tool === 'eraser') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      drawEraserStroke(lastBrushPoint, p);
      lastBrushPoint = p;
      // Don't save state here - wait until drawing is complete
    }
    return;
  }
  
  // For rectangle and ellipse tools, show preview while drawing
  if (tool === 'rect' || tool === 'ellipse') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      // Clear the canvas and restore the last saved state
      if (drawingHistory.length > 0 && currentHistoryIndex >= 0) {
        const lastState = drawingHistory[currentHistoryIndex];
        dctx.putImageData(lastState, 0, 0);
      }
      
      // Draw the shape preview
      dctx.save();
      dctx.strokeStyle = color;
      dctx.lineWidth = size;
      dctx.beginPath();
      
      const x = Math.min(lastBrushPoint.x, p.x);
      const y = Math.min(lastBrushPoint.y, p.y);
      const w = Math.abs(p.x - lastBrushPoint.x);
      const h = Math.abs(p.y - lastBrushPoint.y);
      
      if (tool === 'rect') {
        dctx.rect(x, y, w, h);
      } else {
        dctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
      }
      dctx.stroke();
      dctx.restore();
    }
    return;
  }
});
drawCanvas.addEventListener('pointerup', e => { 
  if (tool === 'pen') { 
    // Save canvas state after completing pen drawing
    if (drawing) {
      saveCanvasState();
    }
    lastBrushPoint = null; 
  } 
  if (tool === 'eraser') {
    // Save canvas state after completing eraser operation
    if (drawing) {
      saveCanvasState();
    }
    lastBrushPoint = null;
  }
  
  // For rectangle and ellipse tools, finalize the drawing
  if (tool === 'rect' || tool === 'ellipse') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      
      // Clear the canvas and restore the last saved state
      if (drawingHistory.length > 0 && currentHistoryIndex >= 0) {
        const lastState = drawingHistory[currentHistoryIndex];
        dctx.putImageData(lastState, 0, 0);
      }
      
      // Draw the final shape
      dctx.save();
      dctx.strokeStyle = color;
      dctx.lineWidth = size;
      dctx.beginPath();
      
      const x = Math.min(lastBrushPoint.x, p.x);
      const y = Math.min(lastBrushPoint.y, p.y);
      const w = Math.abs(p.x - lastBrushPoint.x);
      const h = Math.abs(p.y - lastBrushPoint.y);
      
      if (tool === 'rect') {
        dctx.rect(x, y, w, h);
      } else {
        dctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
      }
      dctx.stroke();
      dctx.restore();
      
      // Save the canvas state after drawing the shape
      saveCanvasState();
      lastBrushPoint = null;
    }
  }
  
  stopDrawing(e); 
});
drawCanvas.addEventListener('pointerleave', stopDrawing); // Stop drawing if pointer leaves canvas

function toLocal(e){ const r=drawCanvas.getBoundingClientRect(); return { x:(e.clientX-r.left)*(drawCanvas.width/r.width||1), y:(e.clientY-r.top)*(drawCanvas.height/r.height||1), pressure: e.pressure } }

function redrawPaths(){ 
  // 1. Gambar utama di dctx (drawCanvas)
  dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); 
  dctx.fillStyle='#fff'; 
  dctx.fillRect(0,0,drawCanvas.width,drawCanvas.height);

  if(baseImage){
    dctx.save();
    try{ drawImageCover(dctx, baseImage, drawCanvas.width, drawCanvas.height); }catch(e){}
    dctx.restore();
  }

  // 2. Gambar Onion Skin di octx (onionCanvas)
  let refIndex;
  if (drawDialog.classList.contains('open') && (editIndex == null || !(typeof editIndex === 'number' && editIndex >= 0))) {
    // New draw frame: use virtual index after the last frame so immediate previous shows up
    refIndex = state.frames.length;
  } else if (typeof editIndex === 'number' && editIndex >= 0) {
    refIndex = editIndex;
  } else {
    refIndex = clampIndex(state.selected);
  }
  if (refIndex < 0) refIndex = Math.max(0, state.frames.length - 1);
  if (drawDialog.classList.contains('open')) {
    renderOnionSkinsOverlay(refIndex);
  } else {
    octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
  }

  // 3. Gambar Guides di gctx (guideCanvas)
  gctx.clearRect(0, 0, guideCanvas.width, guideCanvas.height); // Bersihkan kanvas panduan
  drawGuides(gctx, guideCanvas.width, guideCanvas.height);    // Gambar panduan di atasnya
}

function hitTestPath(s,p,threshold){ if(!s||!s.points) return false; const th = Math.max(8, threshold||6);
  if(s.tool==='rect' || s.tool==='ellipse'){ const a=s.points[0], b=s.points[s.points.length-1]; const x=Math.min(a.x,b.x), y=Math.min(a.y,b.y), w=Math.abs(a.x-b.x), h=Math.abs(a.y-b.y); if(s.tool==='rect'){ return (p.x>=x-th && p.x<=x+w+th && p.y>=y-th && p.y<=y+h+th); } else { // ellipse approximate
      const cx = x + w/2, cy = y + h/2; const rx = Math.max(2,w/2), ry = Math.max(2,h/2); const nx = (p.x-cx)/rx, ny = (p.y-cy)/ry; return (nx*nx + ny*ny) <= 1.4; }
  }
  // path stroke: check each segment point distance
  for(const pt of s.points){ const dx = pt.x - p.x, dy = pt.y - p.y; if(Math.sqrt(dx*dx+dy*dy) <= th + (s.size||0)/2) return true; }
  return false;
}

// test pixel opacity on baseImage by drawing to temp canvas
function isOpaqueAt(img, x, y){ return new Promise(r=>{ const tc = document.createElement('canvas'); tc.width = drawCanvas.width; tc.height = drawCanvas.height; const tctx = tc.getContext('2d'); try{ drawImageCover(tctx, img, tc.width, tc.height); const px = Math.floor(x), py = Math.floor(y); const d = tctx.getImageData(Math.max(0,px), Math.max(0,py), 1, 1).data; r(d[3] > 16); }catch(e){ r(false); } }); }

// undo / redo / clear
document.getElementById('undoBtn').addEventListener('click',()=>{ 
  if (drawDialog.classList.contains('open')) {
    // In drawing modal, use drawing-specific undo
    if (currentHistoryIndex > 0) {
      restoreCanvasState(currentHistoryIndex - 1);
    }
  } else {
    // Outside drawing modal, use global undo
    undo(); 
  }
});
document.getElementById('redoBtn').addEventListener('click',()=>{ 
  if (drawDialog.classList.contains('open')) {
    // In drawing modal, use drawing-specific redo
    if (currentHistoryIndex < drawingHistory.length - 1) {
      restoreCanvasState(currentHistoryIndex + 1);
    }
  } else {
    // Outside drawing modal, use global redo
    redo(); 
  }
});
document.getElementById('clearBtn').addEventListener('click',()=>{ clearCanvas(); });
document.getElementById('cancelDraw').addEventListener('click',()=>{ closeDraw(); });
document.getElementById('confirmDraw').addEventListener('click',async ()=>{
  if (confirmInProgress) return;
  confirmInProgress = true;
  try {
    pushHistory();
    
    // Buat temporary canvas untuk menyimpan gambar final tanpa onion skin
    const temp = document.createElement('canvas');
    temp.width = drawCanvas.width;
    temp.height = drawCanvas.height;
    const tctx = temp.getContext('2d');
  
    // Fill white background so eraser reveals white instead of black/transparent
    tctx.fillStyle = '#ffffff';
    tctx.fillRect(0, 0, temp.width, temp.height);
  
    // baseImage is not drawn here to ensure eraser holes remain effective in edit mode
     
    // Gambar konten utama dari drawCanvas terlebih dahulu (sudah termasuk background putih dan coretan)
    tctx.drawImage(drawCanvas,0,0);
    
    // Jika ada gambar yang sedang di-insert (belum di-Apply), komposit TERAKHIR supaya tidak ketutup
    if (insertImage) {
      drawTransformedImageOnly(tctx);
    }
    
    // Ambil data URL dari temporary canvas (tanpa onion skin)
    const data = temp.toDataURL('image/png');
    
    // Determine index being saved (before modifying frames)
    const targetIndex = (editIndex !== null) ? editIndex : state.frames.length;
  
    // Try to create a bitmap upfront to avoid onion-skin decode flicker on next modal
    let bmp = null;
    try {
      if (window.createImageBitmap) {
        bmp = await createImageBitmap(temp);
      }
    } catch(_) {}
    // Fallback to using the canvas itself so we can draw immediately without decode delay
    if (!bmp) bmp = temp;
    
    if(editIndex !== null){ 
      state.frames[editIndex].thumb = data;
      state.frames[editIndex]._img = null;
      delete state.frames[editIndex]._onionCache;
      if (bmp) state.frames[editIndex]._bmp = bmp;
      selectFrame(editIndex);
      editIndex = null;
    } else {
      state.frames.push({ thumb: data, desc: '', duration: Math.max(1,safeNumber(state.defaultDuration,24)) });
      if (bmp) state.frames[targetIndex]._bmp = bmp;
      delete state.frames[targetIndex]._onionCache;
      selectFrame(state.frames.length-1);
    }
    renderList();
    saveAuto();
  
    // If chaining is requested (Shift+D in modal), start a fresh frame without closing the dialog to avoid blink
    if (chainNewFrameAfterConfirm) {
      chainNewFrameAfterConfirm = false;
      // Fresh blank canvas
      baseImage = null;
      insertImage = null; // stop active insert
      try { ictx.clearRect(0, 0, insertCanvas.width, insertCanvas.height); } catch(_) {}
      try { if (applyImageBtn) applyImageBtn.style.display = 'none'; } catch(_) {}
  
      // Reset drawing history and canvas content
      dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
      dctx.fillStyle = '#fff';
      dctx.fillRect(0,0,drawCanvas.width,drawCanvas.height);
      initDrawingCanvas();
  
      // Update onion ref to the new (next) frame index
      currentOnionRefIndex = state.frames.length; // next frame logical index
      try { primeOnionNeighbors(currentOnionRefIndex); } catch(_) {}
      try { renderOnionSkinsOverlay(currentOnionRefIndex); } catch(_) {}
      try { drawOutsideRulers(); } catch(_) {}
  
      // Focus canvas so keys keep working
      try { drawCanvas.focus(); } catch(_) {}
      return; // keep modal open
    }
  
    // Not chaining: close modal as usual
    closeDraw();
  } finally {
    confirmInProgress = false;
  }
});

// mode and add frame
const modeToggle = document.getElementById('modeToggle');
// default position to left (Draw)
if (modeToggle) modeToggle.style.setProperty('--pos','0');
modeToggle.addEventListener('click', e => {
  const btn = e.target.closest('button[data-mode]');
  if (!btn) return;
  const mode = btn.dataset.mode;
  state.mode = mode;
  document.querySelectorAll('#modeToggle button').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  modeToggle.style.setProperty('--pos', mode === 'upload' ? '1' : '0');
});
document.getElementById('addFrame').addEventListener('click',()=>{
  if(state.mode==='draw') { 
    editIndex = null; // Ensure it's a new frame
    openDraw(); 
  } else { 
    document.getElementById('uploader').click(); 
  }
});

// uploader
const uploader = document.getElementById('uploader'); uploader.addEventListener('change',async(e)=>{
  const files = Array.from(e.target.files||[]); 
  if (files.length > 0) pushHistory();
  for(const f of files){ 
    const data = await readFileAsDataURL(f); 
    state.frames.push({ thumb: data, desc: '', duration: Math.max(1,safeNumber(state.defaultDuration,24)) }); 
  } 
  renderList(); 
  selectFrame(state.frames.length-1); 
  saveAuto(); 
  uploader.value=''; 
  scheduleUpdateFrameCache(); // start caching newly added frames
});
function readFileAsDataURL(file){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=()=>res(null); r.readAsDataURL(file);} ); }

// ====================
// History Stack System
// ====================
let history = [];
let historyIndex = -1;

function pushHistory() {
    history = history.slice(0, historyIndex + 1);
    history.push(JSON.stringify(state.frames));
    historyIndex++;
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        state.frames = normalizeFrames(JSON.parse(history[historyIndex]));
        renderList();
        selectFrame(clampIndex(state.selected));
    }
}

function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        state.frames = normalizeFrames(JSON.parse(history[historyIndex]));
        renderList();
        selectFrame(clampIndex(state.selected));
    }
}

// =======================================
// Frame Operations (Copy, Cut, Paste etc)
// =======================================
function copyFrames() {
    if (selectedFrames.size === 0) return;
    const sortedIndices = [...selectedFrames].sort((a, b) => a - b);
    clipboardFrames = sortedIndices.map(i => JSON.parse(JSON.stringify(state.frames[i])));
}

function cutFrames() {
    if (selectedFrames.size === 0) return;
    pushHistory();
    copyFrames();
    const sortedIndices = [...selectedFrames].sort((a, b) => b - a);
    for (const index of sortedIndices) {
        state.frames.splice(index, 1);
    }
    selectedFrames.clear();
    renderList();
    selectFrame(-1);
    saveAuto();
}

function pasteFrames() {
    if (clipboardFrames.length === 0) return;
    pushHistory();
    const insertPos = state.selected >= 0 ? state.selected + 1 : state.frames.length;
    const copies = clipboardFrames.map(f => JSON.parse(JSON.stringify(f)));
    state.frames.splice(insertPos, 0, ...copies);
    selectedFrames.clear();
    for(let i=0; i<copies.length; i++) {
        selectedFrames.add(insertPos + i);
    }
    state.selected = insertPos + copies.length - 1;
    renderList();
    selectFrame(state.selected);
    saveAuto();
}

function deleteSelectedFrames() {
    if (selectedFrames.size === 0) return;
    pushHistory();
    const sortedIndices = [...selectedFrames].sort((a, b) => b - a);
    for (const index of sortedIndices) {
        state.frames.splice(index, 1);
    }
    const newSel = state.frames.length ? Math.max(0, Math.min(sortedIndices[sortedIndices.length-1], state.frames.length - 1)) : -1;
    selectedFrames.clear();
    renderList();
    selectFrame(newSel);
    saveAuto();
}

function duplicateSelectedFrames() {
    if (selectedFrames.size === 0) return;
    pushHistory();
    const sortedIndices = [...selectedFrames].sort((a, b) => a - b);
    const copies = sortedIndices.map(i => JSON.parse(JSON.stringify(state.frames[i])));
    const insertPos = sortedIndices[sortedIndices.length - 1] + 1;
    state.frames.splice(insertPos, 0, ...copies);
    selectedFrames.clear();
    for(let i=0; i<copies.length; i++) {
        selectedFrames.add(insertPos + i);
    }
    state.selected = insertPos + copies.length - 1;
    renderList();
    selectFrame(state.selected);
    saveAuto();
}


// duplicate / remove buttons
document.getElementById('duplicateFrame').addEventListener('click', () => duplicateSelectedFrames());
document.getElementById('removeFrame').addEventListener('click', () => deleteSelectedFrames());

// fps & durations
fpsInput.addEventListener('change',e=>{ state.fps = Math.max(1, Number(e.target.value)||24); fpsBadge.textContent = state.fps + ' FPS'; saveAuto(); updateProjectInfo(); renderList(); if(state.selected>=0){ const parts = splitDurationFrames(state.frames[state.selected].duration, state.fps); durationSecInput.value = String(parts.sec); durationFrmInput.value = String(parts.frm); } });
defaultDurationInput.addEventListener('change',e=>{ state.defaultDuration = Math.max(1, Number(e.target.value)||24); });
descInput.addEventListener('input',e=>{ 
  if(state.selected>=0 && state.frames[state.selected]){ 
    state.frames[state.selected].desc = e.target.value; 
    renderList(); 
    saveAuto(); 
    // Update preview secara real-time saat deskripsi berubah
    drawPreview();
  } 
});
// replace old single duration input with dual inputs listeners
function updateSelectedDurationFromSide(){
  if(state.selected>=0 && state.frames[state.selected]){
    const d = normalizePairToFrames(durationSecInput.value, durationFrmInput.value, state.fps);
    state.frames[state.selected].duration = d;
    const parts = splitDurationFrames(d, state.fps);
    durationSecInput.value = String(parts.sec);
    durationFrmInput.value = String(parts.frm);
    renderList();
    saveAuto();
    try { setTimelineSize(); renderTimeline(); } catch(_){}
  }
}
durationSecInput.addEventListener('change', updateSelectedDurationFromSide);
durationFrmInput.addEventListener('change', updateSelectedDurationFromSide);
durationSecInput.addEventListener('blur', updateSelectedDurationFromSide);
durationFrmInput.addEventListener('blur', updateSelectedDurationFromSide);
durationSecInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); updateSelectedDurationFromSide(); durationSecInput.blur(); }});
durationFrmInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); updateSelectedDurationFromSide(); durationFrmInput.blur(); }});

// save/load
function saveAuto(){ try{ const payload = { meta: { fps: state.fps, defaultDuration: state.defaultDuration, title: document.getElementById('projectTitle').value||'' }, frames: state.frames }; localStorage.setItem('ladaboard.autosave', JSON.stringify(payload)); }catch(e){ console.warn('autosave failed',e); } }

// Helper function to convert blob to base64 data URL
async function blobToDataURL(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Helper function to convert base64 data URL back to blob
function dataURLToBlob(dataURL) {
  const [header, base64Data] = dataURL.split(",");
  const mime = header.match(/:(.*?);/)[1];
  const byteString = atob(base64Data);
  const arrayBuffer = new ArrayBuffer(byteString.length);
  const uint8Array = new Uint8Array(arrayBuffer);
  for (let i = 0; i < byteString.length; i++) {
    uint8Array[i] = byteString.charCodeAt(i);
  }
  return new Blob([uint8Array], { type: mime });
}

function download(filename, blob){ const a=document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000); }

// Enhanced save function that converts music blobs to base64
document.getElementById('saveProject').addEventListener('click', async ()=>{
  try {
    const project = {
      meta: { 
        title: document.getElementById('projectTitle').value||'', 
        fps: state.fps, 
        defaultDuration: state.defaultDuration 
      },
      frames: []
    };

    // Process each frame and convert music blobs to base64
    for (let f of state.frames) {
      const frameCopy = { ...f };

      // If music exists and is a blob URL, convert to base64
      if (f.music && f.music.startsWith('blob:')) {
        try {
          // Fetch the blob from the URL
          const response = await fetch(f.music);
          const blob = await response.blob();
          frameCopy.musicData = await blobToDataURL(blob);
          delete frameCopy.music; // Remove the blob URL to avoid JSON errors
        } catch (err) {
          console.warn('Failed to convert music to base64:', err);
          // Keep the original music if conversion fails
        }
      }
      // Persist original filename and detected duration if available
      if (f.musicName) frameCopy.musicName = f.musicName;
      if (typeof f.musicDurationSec === 'number' && isFinite(f.musicDurationSec)) {
        frameCopy.musicDurationSec = f.musicDurationSec;
      }

      project.frames.push(frameCopy);
    }

    const json = JSON.stringify(project, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    download(sanitizeFilename(document.getElementById('projectTitle').value||'LadaBoard')+'.json', blob);
  } catch (err) {
    alert('Save failed: ' + (err && err.message ? err.message : String(err)));
  }
});

document.getElementById('loadProject').addEventListener('click',()=>document.getElementById('loadProjectInput').click());

// Enhanced load function that converts base64 music back to blobs
const loadProjectInput = document.getElementById('loadProjectInput'); 
loadProjectInput.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  
  try {
    const txt = await f.text();
    const data = JSON.parse(txt);
    
    // Process frames and convert base64 music back to blobs
    if (data.frames && Array.isArray(data.frames)) {
      for (let frame of data.frames) {
        if (frame.musicData) {
          try {
            // Convert base64 back to blob
            frame.music = URL.createObjectURL(dataURLToBlob(frame.musicData));
            delete frame.musicData; // Clean up the base64 data
          } catch (err) {
            console.warn('Failed to convert music from base64:', err);
            frame.music = null; // Set to null if conversion fails
          }
        }
        // Ensure optional fields exist
        if (typeof frame.musicName !== 'string') frame.musicName = null;
        if (!(typeof frame.musicDurationSec === 'number' && isFinite(frame.musicDurationSec))) {
          frame.musicDurationSec = null;
        }
      }
    }
    
    state.frames = normalizeFrames(data.frames||[]);
    state.fps = safeNumber(data.meta?.fps, state.fps);
    state.defaultDuration = safeNumber(data.meta?.defaultDuration, state.defaultDuration);
    document.getElementById('projectTitle').value = data.meta?.title || '';
    try { document.title = (document.getElementById('projectTitle').value || 'LadaBoard - Storyboard Maker'); } catch(_) {}
    fpsInput.value = state.fps;
    fpsBadge.textContent = state.fps + ' FPS';
    defaultDurationInput.value = state.defaultDuration;
    renderList();
    selectFrame(state.frames.length?0:-1);
    pushHistory();
    saveAuto();
  } catch(err) {
    alert('Invalid project file: ' + (err && err.message ? err.message : String(err)));
  }
  e.target.value = '';
});

// export spread
document.getElementById('exportSpreadPng').addEventListener('click', async () => {
  if (!state.frames.length) return alert('No frames');
  
  const pages = await generateStoryboardPages();
  pages.forEach((c, i) => {
    const a = document.createElement('a');
    a.href = c.toDataURL('image/png');
    a.download = `storyboard_page${i + 1}.png`;
    a.click();
  });
});

document.getElementById('exportSpreadPdf').addEventListener('click', async () => {
  const { jsPDF } = window.jspdf;

  const pageWmm = 210;
  const pageHmm = 297;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });

  const perPage = 5;
  const thumbWmm = 90;
  const thumbHmm = 50.6;
  const marginXmm = 10;
  const startYmm = 25;
  const rowHmm = 55;

  const colCut = 15;
  const colImg = thumbWmm + 5;
  const colAction = 50;
  const colDialogue = 50;
  const colSec = 15;
  const colX = [
    marginXmm,
    marginXmm + colCut,
    marginXmm + colCut + colImg,
    marginXmm + colCut + colImg + colAction,
    marginXmm + colCut + colImg + colAction + colDialogue,
    pageWmm - marginXmm
  ];

  // timeline helpers for pdf
  const fpsNow = Math.max(1, state.fps || 24);
  const totalFramesCount = state.frames.reduce((a,b)=> a + Math.max(1, safeNumber(b?.duration, state.defaultDuration)), 0);
  const totalSecAll = totalFramesCount / fpsNow;
  const formatTimeMMSS = (sec)=>{ sec = Math.max(0, Math.floor(sec||0)); const m = Math.floor(sec/60); const s = sec % 60; return pad2(m)+":"+pad2(s); };

  for (let p = 0; p < Math.ceil(state.frames.length / perPage); p++) {
    if (p > 0) pdf.addPage();

    // Garis vertikal
    for (let x of colX) {
      pdf.line(x, startYmm, x, startYmm + perPage * rowHmm);
    }

    // Garis horizontal
    for (let r = 0; r <= perPage; r++) {
      const y = startYmm + r * rowHmm;
      pdf.line(marginXmm, y, pageWmm - marginXmm, y);
    }

    // Label kolom (Inggris)
    pdf.setFont("helvetica", "normal");
    pdf.setFontSize(8);
    pdf.text('Cut', colX[0] + 2, startYmm - 2);
    pdf.text('Picture', colX[1] + 2, startYmm - 2);
    pdf.text('Action / Notes', colX[2] + 2, startYmm - 2);
    pdf.text('Dialogue / Sound', colX[3] + 2, startYmm - 2);
    pdf.text('Sec', colX[4] + 2, startYmm - 2);

    // Isi baris
    for (let r = 0; r < perPage; r++) {
      const idx = p * perPage + r;
      if (idx >= state.frames.length) break;
      const f = state.frames[idx];
      const y = startYmm + r * rowHmm;

      // Cut number
      pdf.setFontSize(9);
      pdf.text(String(idx + 1).padStart(2, '0'), colX[0] + 2, y + 5);

      // Frame image
      if (f.thumb) {
        const img = await createBitmapFromSrc(f.thumb);
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = img.width;
        tmpCanvas.height = img.height;
        tmpCanvas.getContext('2d').drawImage(img, 0, 0);
        const imgData = tmpCanvas.toDataURL('image/jpeg', 0.8);
        pdf.addImage(imgData, 'JPEG', colX[1] + 1, y + 1, thumbWmm, thumbHmm);
      }

      // Action / Notes
      pdf.setFontSize(8);
      let actionLines = pdf.splitTextToSize(f.desc || '', colAction - 4);
      pdf.text(actionLines, colX[2] + 2, y + 4);

      // Dialogue / Sound
      if (f.music) {
        const name = (f.musicName && String(f.musicName)) || (f.music.split('/').pop().split('?')[0]);
        const startFrames = state.frames.slice(0, idx).reduce((a,b)=> a + Math.max(1, safeNumber(b?.duration, state.defaultDuration)), 0);
        const startSec = startFrames / fpsNow;
        const endSec = (typeof f.musicDurationSec === 'number' && isFinite(f.musicDurationSec))
          ? Math.min(totalSecAll, startSec + f.musicDurationSec)
          : null;
        const timeText = endSec == null
          ? `played at ${formatTimeMMSS(startSec)} to end`
          : `played at ${formatTimeMMSS(startSec)} to ${formatTimeMMSS(endSec)}`;
        let musicLines = pdf.splitTextToSize(`BGM: ${name} ${timeText}`, colDialogue - 4);
        pdf.text(musicLines, colX[3] + 2, y + 4);
      }

      // Sec
      const secs = splitDurationFrames(f.duration, state.fps).sec;
      pdf.setFontSize(9);
      pdf.text(`${secs}`, colX[4] + 2, y + 5);
    }
  }

  pdf.save('storyboard.pdf');
});

function blankImageData(w,h){ const c=document.createElement('canvas'); c.width=w;c.height=h; const cx=c.getContext('2d'); cx.fillStyle='#222'; cx.fillRect(0,0,w,h); return c.toDataURL('image/png'); }

// ---------- Safe export binding (no console logs) ----------
(function attachVideoExportBindings(){
  const webmBtn = document.getElementById('exportVideoWebm');
  const mp4Btn = document.getElementById('exportVideoMp4');
  if (webmBtn) {
    const handle = async () => {
      try {
        webmBtn.disabled = true;
        webmBtn.innerHTML = "Processing...";
        await exportVideoWithAudio('webm');
      } catch (err) {
        alert('Export failed: ' + (err && err.message ? err.message : String(err)));
      } finally {
        webmBtn.disabled = false;
        webmBtn.innerHTML = "WebM (with audio)";
      }
    };
    webmBtn.replaceWith(webmBtn.cloneNode(true));
    document.getElementById('exportVideoWebm').addEventListener('click', handle);
  }
  if (mp4Btn) {
    const handle = async () => {
      try {
        mp4Btn.disabled = true;
        mp4Btn.innerHTML = "Processing...";
        await exportVideoWithAudio('mp4');
      } catch (err) {
        alert('Export failed: ' + (err && err.message ? err.message : String(err)));
      } finally {
        mp4Btn.disabled = false;
        mp4Btn.innerHTML = "MP4 (with audio)";
      }
    };
    mp4Btn.replaceWith(mp4Btn.cloneNode(true));
    document.getElementById('exportVideoMp4').addEventListener('click', handle);
  }
})();

// ---------- Helpers for export (no console logs) ----------
function chooseSupportedMime() {
  const options = [
    'video/webm;codecs=vp9',
    'video/webm;codecs=vp8',
    'video/webm'
  ];
  for (const m of options) {
    try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; } catch(e) {}
  }
  return 'video/webm';
}
function chooseSupportedMp4Mime() {
  const options = [
    'video/mp4;codecs=avc1.42E01E,mp4a.40.2', // H.264 Baseline + AAC
    'video/mp4;codecs=avc1.4D401E,mp4a.40.2', // H.264 Main + AAC
    'video/mp4;codecs=avc1,mp4a.40.2',
    'video/mp4;codecs=h264,aac',
    'video/mp4'
  ];
  for (const m of options) {
    try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; } catch(e) {}
  }
  return null;
}
function waitMs(ms){ return new Promise(r=>setTimeout(r, ms)); }

function drawOverlayForExport(ctx, elapsedMs, frameIndex, w, h, fps, desc) {
  ctx.save();
  // Cut no. (top-left)
  ctx.textBaseline = 'top';
  ctx.font = 'bold 36px "Segoe UI", sans-serif';
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const tx = 16, ty = 10;
  ctx.strokeText('Cut no. ' + (frameIndex + 1), tx, ty);
  ctx.fillText('Cut no. ' + (frameIndex + 1), tx, ty);

  // Time (bottom-left)
  const seconds = Math.floor(elapsedMs / 1000);
  const framesSinceStart = Math.floor(elapsedMs * fps / 1000);
  const frameInSecond = framesSinceStart % fps;
  const timeText = String(seconds).padStart(2,'0') + 's +' + String(frameInSecond).padStart(2,'0') + 'f';
  ctx.font = 'bold 40px "Segoe UI", sans-serif';
  ctx.lineWidth = 8;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const bx = 16, by = h - 110;
  ctx.strokeText(timeText, bx, by);
  ctx.fillText(timeText, bx, by);

  // small fps under it
  const fpsText = 'FPS ' + fps;
  ctx.font = 'bold 22px "Segoe UI", sans-serif';
  ctx.lineWidth = 6;
  ctx.strokeText(fpsText, bx, by + 56);
  ctx.fillText(fpsText, bx, by + 56);

  // compute reserved left area width
  let reservedLeft = 18;
  ctx.font = 'bold 40px "Segoe UI", sans-serif';
  const wTime = ctx.measureText(timeText).width;
  ctx.font = 'bold 22px "Segoe UI", sans-serif';
  const wFps = ctx.measureText(fpsText).width;
  reservedLeft += Math.max(wTime, wFps) + 24;

  // Description (bottom-right) using wrapText already in your code
  if (desc) {
    ctx.font = '16px "Segoe UI", sans-serif';
    const pad = 12;
    const lineHeight = 20;
    const maxBoxAllowed = Math.max(120, w - reservedLeft - 18);
    const maxLineWidth = Math.max(120, maxBoxAllowed - pad * 2);
    const wrap = wrapText(ctx, desc, maxLineWidth);
    const lines = wrap.lines;
    const textW = wrap.maxWidth;
    const boxW = Math.min(maxBoxAllowed, Math.max(120, textW + pad * 2));
    const boxH = lines.length * lineHeight + pad * 2;
    const rx = w - boxW - 18;
    const ry = h - boxH - 12;

    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(rx, ry, boxW, boxH);

    ctx.fillStyle = '#fff';
    for (let i = 0; i < lines.length; i++) {
      const ly = ry + pad + i * lineHeight + 4;
      ctx.fillText(lines[i], rx + pad, ly);
    }
  }
  ctx.restore();
}

// ---------- Build mixed audio track from timeline (no speakers) ----------
async function buildMixedAudioBuffer(sampleRate) {
  const totalFrames = state.frames.reduce((acc, f) => acc + Math.max(1, safeNumber(f?.duration, state.defaultDuration)), 0);
  const totalSeconds = totalFrames / Math.max(1, state.fps || 24);
  const sr = sampleRate || 48000;
  const offline = new OfflineAudioContext(2, Math.ceil(totalSeconds * sr), sr);

  // Load & place audio per frame
  let cursorFrames = 0;
  const tasks = state.frames.map(async (f) => {
    const musicUrl = f && f.music ? f.music : null;
    const durFrames = Math.max(1, safeNumber(f?.duration, state.defaultDuration));
    const startTime = cursorFrames / Math.max(1, state.fps || 24);
    const segDuration = durFrames / Math.max(1, state.fps || 24);
    cursorFrames += durFrames;
    if (!musicUrl) return;
    try {
      const res = await fetch(musicUrl);
      const arr = await res.arrayBuffer();
      const buf = await offline.decodeAudioData(arr);
      const src = offline.createBufferSource();
      src.buffer = buf;
      src.connect(offline.destination);
      // Play continuously from the frame start until the end of the total timeline (or track end),
      // not just the frame segment
      const remaining = Math.max(0, totalSeconds - startTime);
      const playLen = Math.min(buf.duration, remaining);
      src.start(startTime, 0, playLen);
    } catch (_) {
      // ignore audio load failure for this segment
    }
  });
  await Promise.all(tasks);
  const mixed = await offline.startRendering();
  return { buffer: mixed, durationSec: totalSeconds };
}

// ---------- Unified export (offscreen, combined A/V, no UI blinking) ----------
async function exportVideoWithAudio(kind /* 'webm' | 'mp4' */){
  if (!state.frames.length) { alert('No frames'); return; }

  const fps = Math.max(1, state.fps || 24);
  const w = preview.width || 1280;
  const h = preview.height || 720;

  // Prepare offscreen canvas
  const rec = document.createElement('canvas');
  rec.width = w; rec.height = h;
  const ctx = rec.getContext('2d');

  // Prepare audio (mix offline to avoid CPU spikes/jank)
  const hasAnyMusic = state.frames.some(f => !!f.music);
  let audioCtx = null, audioDest = null, audioSource = null;
  if (hasAnyMusic) {
    const { buffer: mixedBuffer } = await buildMixedAudioBuffer(48000);
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
    audioDest = audioCtx.createMediaStreamDestination();
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = mixedBuffer;
    audioSource.connect(audioDest);
    // Do not connect to speakers -> silent to user
  }

  // Build combined stream
  const canvasStream = rec.captureStream(fps);
  let combinedStream;
  if (audioDest) {
    combinedStream = new MediaStream([
      ...canvasStream.getVideoTracks(),
      ...audioDest.stream.getAudioTracks()
    ]);
  } else {
    combinedStream = canvasStream;
  }

  // Choose mime by kind
  let mime;
  if (kind === 'mp4') {
    mime = chooseSupportedMp4Mime();
    if (!mime) {
      alert('MP4 export is not supported in this browser. Use WebM or try a browser with MediaRecorder MP4 support (e.g., Safari).');
      return;
    }
  } else {
    mime = chooseSupportedMime();
  }

  // Create recorder
  let recorder;
  const chunks = [];
  try {
    recorder = new MediaRecorder(combinedStream, { mimeType: mime });
  } catch (err) {
    alert('Cannot start recorder for ' + mime + ': ' + (err && err.message ? err.message : String(err)));
    return;
  }
  recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
  const stopped = new Promise(resolve => recorder.onstop = resolve);
  try { recorder.start(1000); } catch (err) { try { recorder.start(); } catch(e) { alert('Recorder failed to start.'); return; } }

  // Start audio play silently (if any)
  if (audioSource) { try { audioSource.start(); } catch(_) {} }

  // Draw frames according to durations
  const frameMs = 1000 / fps;
  for (let i = 0; i < state.frames.length; i++) {
    const f = state.frames[i] || createFrame(null);
    const img = new Image();
    try { img.crossOrigin = 'anonymous'; } catch(_) {}
    img.src = f.thumb || blankImageData(w,h);
    await new Promise(r => { img.onload = r; img.onerror = r; });

    const framesToShow = Math.max(1, Math.round(safeNumber(f.duration, state.defaultDuration)));
    for (let ff = 0; ff < framesToShow; ff++) {
      ctx.clearRect(0,0,w,h);
      try { drawImageCover(ctx, img, w, h); } catch(e){}
      try { drawGuides(ctx, w, h); } catch(e){}
      const elapsedMs = (state.frames.slice(0, i).reduce((a,b)=>a + Math.max(1, safeNumber(b.duration, state.defaultDuration)),0) + ff) * frameMs;
      drawOverlayForExport(ctx, elapsedMs, i, w, h, fps, f.desc || '');
      await waitMs(Math.round(frameMs));
    }
  }

  // Finish
  recorder.stop();
  await stopped;
  try { if (audioSource) audioSource.stop(); } catch(_) {}
  try { if (audioCtx) await audioCtx.close(); } catch(_) {}

  if (!chunks.length) {
    alert('No video data captured. Try using a different browser and ensure images/audio are properly loaded.');
    return;
  }
  const ext = (kind === 'mp4') ? '.mp4' : '.webm';
  const blob = new Blob(chunks, { type: mime });
  download(sanitizeFilename((document.getElementById('projectTitle').value || 'storyboard')) + ext, blob);
}

// ---------- Robust exportVideo (no console logs) ----------
 async function exportVideo(){
   if (!state.frames.length) { alert('No frames'); return; }
 
   const w = preview.width || 1280;
   const h = preview.height || 720;
   const rec = document.createElement('canvas');
   rec.width = w; rec.height = h;
   const ctx = rec.getContext('2d');
 
   // create MediaRecorder safely
   let recorder;
   const chunks = [];
   const mime = chooseSupportedMime();
   try {
     const stream = rec.captureStream(Math.max(1, state.fps || 24));
     recorder = new MediaRecorder(stream, { mimeType: mime });
   } catch (err) {
     throw new Error('MediaRecorder not available or mime not supported on this browser.');
   }
   
   recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
   
   const stopped = new Promise(resolve => recorder.onstop = resolve);
   try { recorder.start(1000); } catch (err) { try { recorder.start(); } catch(e) { throw new Error('Recorder failed to start.'); } } // Fallback to start() without timeslice
 
   // record frames
   let cumulativeMs = 0;
   const frameMs = 1000 / Math.max(1, state.fps || 24);
 
   for (let i = 0; i < state.frames.length; i++) {
     const f = state.frames[i] || createFrame(null);
     const img = new Image();
     // set crossOrigin to avoid taint if possible
     try { img.crossOrigin = 'anonymous'; } catch(e) {}
     img.src = f.thumb || blankImageData(w,h);
     await new Promise(r => { img.onload = r; img.onerror = r; });
 
     const framesToShow = Math.max(1, Math.round(safeNumber(f.duration, state.defaultDuration)));
     for (let ff = 0; ff < framesToShow; ff++) {
       ctx.clearRect(0,0,w,h);
       try { drawImageCover(ctx, img, w, h); } catch(e){}
       try { drawGuides(ctx, w, h); } catch(e){}        // <-- draw guides into exported frame
       drawOverlayForExport(ctx, cumulativeMs, i, w, h, state.fps || 24, f.desc || '');
       await waitMs(Math.round(frameMs));
       cumulativeMs += frameMs;
     }
   }
 
   recorder.stop();
   await stopped;
 
   if (!chunks.length) {
     throw new Error('No video data captured. Try using Chrome/Edge and ensure images are uploaded (not cross-origin blocked).');
   }
 
   const blob = new Blob(chunks, { type: mime });
   download(sanitizeFilename((document.getElementById('projectTitle').value || 'storyboard')) + '.webm', blob);
 }
// ... existing code ...

// playback engine (unchanged)
let playing = false;
let playStartTime = 0;
let pausedTime = 0;
let rafId = null;
let currentFrameIndex = -1;
const playBtn = document.getElementById('playAll');

function findFrameIndex(elapsedMs) {
    const elapsedFrames = elapsedMs * state.fps / 1000;
    let framesSoFar = 0;
    for (let i = 0; i < state.frames.length; i++) {
        framesSoFar += state.frames[i].duration;
        if (elapsedFrames < framesSoFar) {
            return i;
        }
    }
    return -1; // end of playback
}

function getElapsedInFrame(elapsedMs, frameIndex) {
    const elapsedFrames = elapsedMs * state.fps / 1000;
    let framesBefore = 0;
    for (let i = 0; i < frameIndex; i++) {
        framesBefore += state.frames[i].duration;
    }
    const elapsedInFrame = elapsedFrames - framesBefore;
    return elapsedInFrame * 1000 / state.fps;
}


function playbackLoop() {
    if (!playing) return;

    const elapsed = pausedTime + (performance.now() - playStartTime);
    try { setPlayheadFromElapsedMs(elapsed); } catch(_){ }
    const frameIdx = findFrameIndex(elapsed);

    if (frameIdx === -1) {
        if (loopEnabled) {
            // restart playback from beginning
            pausedTime = 0;
            currentFrameIndex = -1;
            playStartTime = performance.now();
            rafId = requestAnimationFrame(playbackLoop);
            return;
        } else {
            stopPlayback();
            return;
        }
    }

    if (frameIdx !== currentFrameIndex) {
        currentFrameIndex = frameIdx;
        // Update sidebar playing highlight
        try { highlightSelected(); } catch(_){}
        // Do NOT change selection during playback; just handle audio
        handleMusicForFrame(currentFrameIndex);
    }
    
    const f = state.frames[currentFrameIndex];
    if (!f) { stopPlayback(); return; }

    // draw from cache; fall back to lastPreviewImage to avoid blink
    primeCacheAround(currentFrameIndex);
    const img = f.thumb ? ensureFrameImage(f) : null;
    const ready = !!(img && img.complete && img.naturalWidth > 0);
    const baseToDraw = ready ? img : (lastPreviewImage || null);

        pctx.clearRect(0, 0, preview.width, preview.height);
    if (baseToDraw) {
      try { drawImageCover(pctx, baseToDraw, preview.width, preview.height); } catch(e) {}
    } else {
        pctx.fillStyle = '#111';
        pctx.fillRect(0, 0, preview.width, preview.height);
    }
    try { drawGuides(pctx, preview.width, preview.height); } catch(e) {}
        drawOverlayCanvas('Cut no. ' + (currentFrameIndex + 1), elapsed);

    if (ready) { lastPreviewImage = img; lastPreviewIndex = currentFrameIndex; }

        rafId = requestAnimationFrame(playbackLoop);
}

function startPlayback() {
    if (playing || !state.frames.length) return;
    playing = true;
    playBtn.innerHTML = "<i class='bx bx-pause'></i> Stop";
    playStartTime = performance.now();
    if (pausedTime === 0) {
        currentFrameIndex = -1;
    }
    try { setPlayheadFromElapsedMs(0); } catch(_){}
    playbackLoop();
}

function pausePlayback() {
    if (!playing) return;
    playing = false;
    cancelAnimationFrame(rafId);
    pausedTime += performance.now() - playStartTime;
    playBtn.innerHTML = "<i class='bx bx-play'></i> Play";
    
    // Pause musik saat playback di-pause
    if (musicAudio) musicAudio.pause();
}

function resumePlayback(){
    if (playing) return;
    playing = true;
    playStartTime = performance.now();
    playBtn.innerHTML = "<i class='bx bx-pause'></i> Stop";
    
    // Resume musik saat playback di-resume
    if (musicAudio) musicAudio.play();
    
    playbackLoop();
}

function stopPlayback() {
    playing = false;
    cancelAnimationFrame(rafId);
    pausedTime = 0;
    currentFrameIndex = -1;
    playBtn.innerHTML = "<i class='bx bx-play'></i> Play";
    try { setPlayheadFromElapsedMs(0); } catch(_){}
    
    // Stop musik saat playback di-stop
    if (musicAudio) {
        musicAudio.pause();
        musicAudio = null;
        currentMusicUrl = null;
    }
    
    drawPreview();
}

function togglePlayback() {
    if (playing) {
        pausePlayback();
    } else {
        const totalDuration = state.frames.reduce((acc, f) => acc + f.duration, 0) * 1000 / state.fps;
        if (pausedTime >= totalDuration) {
            stopPlayback(); // if at the end, reset and play from start
            startPlayback();
        } else {
            resumePlayback(); // Use resumePlayback instead of startPlayback
        }
    }
}

playBtn.addEventListener('click', togglePlayback);


// ====================
// Keyboard Shortcuts + Shortcuts Modal wiring
// ====================
const openShortcutsBtn = document.getElementById('openShortcuts');
const shortcutsDialog = document.getElementById('shortcutsDialog');
const closeShortcutsBtn = document.getElementById('closeShortcuts');

function openShortcuts(){ if (shortcutsDialog) shortcutsDialog.classList.add('open'); }
function closeShortcuts(){ if (shortcutsDialog) shortcutsDialog.classList.remove('open'); }

if (openShortcutsBtn) openShortcutsBtn.addEventListener('click', (e)=>{ e.preventDefault(); openShortcuts(); });
if (closeShortcutsBtn) closeShortcutsBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeShortcuts(); });
if (shortcutsDialog) { shortcutsDialog.addEventListener('click', (e)=>{ if (e.target === shortcutsDialog) closeShortcuts(); }); }

window.addEventListener('keydown', e => {
  // --- Shortcuts for Drawing Modal ---
  if (drawDialog.classList.contains('open')) {
    // Ctrl+Z / Ctrl+Shift+Z inside modal (Undo/Redo)
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
      e.preventDefault();
      if (e.shiftKey) {
        if (currentHistoryIndex < drawingHistory.length - 1) restoreCanvasState(currentHistoryIndex + 1);
      } else {
        if (currentHistoryIndex > 0) restoreCanvasState(currentHistoryIndex - 1);
      }
      return;
    }
    // Ctrl+Y redo inside modal
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
      e.preventDefault();
      if (currentHistoryIndex < drawingHistory.length - 1) restoreCanvasState(currentHistoryIndex + 1);
      return;
    }
    // Shift+D: Confirm current and immediately start a new frame
    if (e.shiftKey && e.key.toLowerCase() === 'd') {
      e.preventDefault();
      if (confirmInProgress) return;
      chainNewFrameAfterConfirm = true;
      document.getElementById('confirmDraw').click();
      return;
    }
    // Enter to confirm
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      if (confirmInProgress) return;
      document.getElementById('confirmDraw').click();
      return;
    }
    // Tab to confirm as well while in draw/edit modal
    if (e.key === 'Tab') {
      e.preventDefault();
      if (confirmInProgress) return;
      document.getElementById('confirmDraw').click();
      return;
    }
    // Escape to cancel
    if (e.key === 'Escape') {
      e.preventDefault();
      document.getElementById('cancelDraw').click();
      return;
    }
  }

  // If shortcuts modal is open, allow Esc to close it and stop further handling
  if (shortcutsDialog && shortcutsDialog.classList.contains('open')) {
    if (e.key === 'Escape') { e.preventDefault(); closeShortcuts(); return; }
  }

  const target = e.target || document.activeElement;
  const isInputting = (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable));

  // Global shortcuts: ignore while typing so text fields keep native behavior
  if (!isInputting && (e.ctrlKey || e.metaKey)) {
    switch(e.key.toLowerCase()) {
      case 'z':
        e.preventDefault();
        if (e.shiftKey) redo(); else undo();
        return;
      case 'y': e.preventDefault(); redo(); return;
      case 's': e.preventDefault(); document.getElementById('saveProject').click(); return;
      case 'c': e.preventDefault(); copyFrames(); return;
      case 'x': e.preventDefault(); cutFrames(); return;
      case 'v': e.preventDefault(); pasteFrames(); return;
    }
  }

  // Shift+D to create new frame (mirrors New Frame button behavior)
  if (!isInputting && !drawDialog.classList.contains('open') && e.shiftKey && e.key.toLowerCase() === 'd') {
    e.preventDefault();
    const addBtn = document.getElementById('addFrame');
    if (addBtn) addBtn.click();
    return;
  }

  // Handle Enter key separately for playback vs. newline/confirm
  if (e.key === 'Enter') {
    if (isInputting) {
      if (target.tagName === 'INPUT') {
        e.preventDefault();
        try { target.blur(); } catch(_) {}
      }
      return; // do not trigger playback while typing
    }
    e.preventDefault();
    togglePlayback();
  }

  // Delete selected frames (when not typing and not in draw modal)
  if (!isInputting && !drawDialog.classList.contains('open') && e.key === 'Delete') {
    if (selectedFrames.size > 0) {
      e.preventDefault();
      deleteSelectedFrames();
      return;
    }
  }

  // Arrow Left/Right to navigate frames (when not typing and not in draw modal)
  if (!isInputting && !drawDialog.classList.contains('open')) {
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      const prevIndex = clampIndex(state.selected - 1);
      selectFrame(prevIndex, e);
      return;
    }
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      const nextIndex = clampIndex(state.selected + 1);
      selectFrame(nextIndex, e);
      return;
    }
  }
});

// load autosave on startup
window.addEventListener('load',()=>{
  try { 
    const data = localStorage.getItem('ladaboard.autosave'); 
    if(data){ 
      const p = JSON.parse(data); 
      state.frames = normalizeFrames(p.frames||[]); 
      state.fps = safeNumber(p.meta?.fps,state.fps); 
      state.defaultDuration = safeNumber(p.meta?.defaultDuration,state.defaultDuration); 
      document.getElementById('projectTitle').value = p.meta?.title||''; 
      fpsInput.value = state.fps; 
      fpsBadge.textContent = state.fps + ' FPS'; 
      defaultDurationInput.value = state.defaultDuration; 
      renderList(); 
      selectFrame(state.frames.length?0:-1); 
    } 
  } catch(e) { 
    console.warn('failed to load autosave',e); 
  } 
  pushHistory(); // Create initial history entry
  preview.width=1280; 
  preview.height=720; 
  drawPreview(); 
  // Intro overlay logic removed
  try { document.title = (document.getElementById('projectTitle').value || 'LadaBoard - Storyboard Maker'); } catch(_) {}
});

// helpers for renderList
function escapeHtmlSimple(s){ return escapeHtml(s); }
framesList.addEventListener('click',()=>setTimeout(drawPreview,50));

// new: restart and loop controls
const restartBtn = document.getElementById('restartPlay');
const loopBtn = document.getElementById('loopToggle');
let loopEnabled = JSON.parse(localStorage.getItem('ladaboard.loopEnabled') || 'false');

function updateLoopButtonUI() {
  if (!loopBtn) return;
  loopBtn.style.borderColor = loopEnabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  loopBtn.style.color = loopEnabled ? '#fff' : 'var(--muted)';
}

if (restartBtn) {
  restartBtn.addEventListener('click', () => {
    pausedTime = 0;
    currentFrameIndex = -1;
    try { setPlayheadFromElapsedMs(0); } catch(_){}
    if (!playing) startPlayback();
    else playStartTime = performance.now();
  });
}
if (loopBtn) {
  loopBtn.addEventListener('click', () => {
    loopEnabled = !loopEnabled;
    localStorage.setItem('ladaboard.loopEnabled', JSON.stringify(loopEnabled));
    updateLoopButtonUI();
  });
}
updateLoopButtonUI();

// Event Add Music
// Removed - now handled by individual frame music buttons

// Event Remove Music  
// Removed - now handled by individual frame music buttons

// Fungsi untuk menangani musik saat frame berubah
function handleMusicForFrame(frameIndex){
  const frame = state.frames[frameIndex];
  if (frame.music && frame.music !== currentMusicUrl) {
    if (musicAudio) {
      musicAudio.pause();
      musicAudio = null;
    }
    musicAudio = new Audio(frame.music);
    musicAudio.play();
    currentMusicUrl = frame.music;
  }
}

// Mobile sidebar overlay controls
const openSidebarBtn = document.getElementById('openSidebar');
const mobileBackdrop = document.getElementById('mobileBackdrop');
function openSidebarOverlay(){ document.body.classList.add('sidebar-open'); }
function closeSidebarOverlay(){ document.body.classList.remove('sidebar-open'); }
if (openSidebarBtn) openSidebarBtn.addEventListener('click', openSidebarOverlay);
if (mobileBackdrop) mobileBackdrop.addEventListener('click', closeSidebarOverlay);
window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeSidebarOverlay(); });

// Image transform state for insert tool
let insertImage = null; // HTMLImageElement when active
let insertTransform = {
  x: 512,
  y: 288,
  scaleX: 1,
  scaleY: 1,
  rotation: 0,
  skewX: 0,
  skewY: 0,
  width: 0,
  height: 0,
  dragging: false,
  dragMode: null, // 'move' | 'scale' | 'rotate' | 'skewX' | 'skewY'
  dragModeCorner: null,
  startPointer: {x:0,y:0},
  startState: null
};
let suppressInsertOverlay = false;
const HANDLE = { corner: 14, edge: 12, rotRadius: 8, rotOffset: 28 };

const addImageBtn = document.getElementById('addImageBtn');
const applyImageBtn = document.getElementById('applyImageBtn');
const insertImageInput = document.getElementById('insertImageInput');

function hasActiveInsert() { return !!insertImage; }

function drawTransformedImage(ctx) {
  if (!insertImage) return;
  const cx = insertTransform.x;
  const cy = insertTransform.y;
  const w = insertTransform.width;
  const h = insertTransform.height;

  ctx.save();
  ctx.translate(cx, cy);
  // apply transform matrix: scale, skew, rotate
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.drawImage(insertImage, -w/2, -h/2, w, h);
  ctx.restore();

  // draw handles
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.strokeStyle = '#39f';
  ctx.lineWidth = 1;
  ctx.setLineDash([6,4]);
  ctx.strokeRect(-w/2, -h/2, w, h);
  ctx.setLineDash([]);
  const handle = 10; // pixels in local space
  ctx.fillStyle = '#39f';
  // corners for scale
  [[-w/2,-h/2],[w/2,-h/2],[w/2,h/2],[-w/2,h/2]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-handle/2, hy-handle/2, handle, handle);
  });
  // rotation handle: top center
  ctx.beginPath();
  ctx.arc(0, -h/2-24, 6, 0, Math.PI*2);
  ctx.fill();
  // skew handles: middle of edges
  ctx.fillStyle = '#9cf';
  [[0,-h/2],[w/2,0],[0,h/2],[-w/2,0]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-6, hy-6, 12, 12);
  });
  ctx.restore();
}

function screenToCanvasPoint(e) {
  const r = drawCanvas.getBoundingClientRect();
  return { x:(e.clientX-r.left)*(drawCanvas.width/r.width||1), y:(e.clientY-r.top)*(drawCanvas.height/r.height||1) };
}

function hitHandle(p) {
  if (!insertImage) return null;
  const {x,y,scaleX,scaleY,rotation,skewX,skewY,width,height} = insertTransform;
  let px = p.x - x, py = p.y - y;
  const cos = Math.cos(-rotation), sin = Math.sin(-rotation);
  let rx = px * cos - py * sin;
  let ry = px * sin + py * cos;
  const tanY = Math.tan(skewY), tanX = Math.tan(skewX);
  let sx = rx - tanX * ry;
  let sy = ry - tanY * sx;
  const lx = sx / scaleX;
  const ly = sy / scaleY;

  const w = width, h = height;
  const near = (ax,ay, bx,by, s)=> Math.abs(ax-bx)<=s && Math.abs(ay-by)<=s;
  // corners -> scale
  if (near(lx,ly, -w/2, -h/2, HANDLE.corner)) return {mode:'scale', corner:'tl'};
  if (near(lx,ly,  w/2, -h/2, HANDLE.corner)) return {mode:'scale', corner:'tr'};
  if (near(lx,ly,  w/2,  h/2, HANDLE.corner)) return {mode:'scale', corner:'br'};
  if (near(lx,ly, -w/2,  h/2, HANDLE.corner)) return {mode:'scale', corner:'bl'};
  // rotation handle near top center
  if (Math.hypot(lx-0, ly-(-h/2-HANDLE.rotOffset)) <= HANDLE.rotRadius + 4) return {mode:'rotate'};
  // skew handles mid edges
  if (near(lx,ly, 0, -h/2, HANDLE.edge)) return {mode:'skewY', edge:'top'};
  if (near(lx,ly,  w/2, 0, HANDLE.edge)) return {mode:'skewX', edge:'right'};
  if (near(lx,ly, 0,  h/2, HANDLE.edge)) return {mode:'skewY', edge:'bottom'};
  if (near(lx,ly, -w/2, 0, HANDLE.edge)) return {mode:'skewX', edge:'left'};
  // inside rect -> move
  if (lx>=-w/2 && lx<=w/2 && ly>=-h/2 && ly<=h/2) return {mode:'move'};
  return null;
}

function requestCanvasRedrawWithInsertOverlay() {
  // Repaint base and overlays (onion/guides)
  redrawPaths();
  // Draw insert preview (image + blue handles) on the overlay canvas only
  drawTransformedImageOverlay();
}

let prevToolForInsert = null;
addImageBtn?.addEventListener('click', ()=>{
  insertImageInput?.click();
});

insertImageInput?.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const img = new Image();
    img.onload = () => {
      insertImage = img;
      prevToolForInsert = tool;
      tool = 'insert';
      insertTransform.width = Math.min(drawCanvas.width * 0.6, img.width);
      insertTransform.height = insertTransform.width * (img.height / img.width);
      insertTransform.x = drawCanvas.width/2;
      insertTransform.y = drawCanvas.height/2;
      insertTransform.scaleX = 1; insertTransform.scaleY = 1;
      insertTransform.rotation = 0; insertTransform.skewX = 0; insertTransform.skewY = 0;
      applyImageBtn.style.display = 'inline-flex';
      requestCanvasRedrawWithInsertOverlay();
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
  // reset file input value so same file can be chosen again later
  e.target.value = '';
});

applyImageBtn?.addEventListener('click', ()=>{
  if (!insertImage) return;
  // permanently draw transformed image onto drawCanvas and push to history
  saveCanvasState();
  // draw current transformed image directly onto base canvas (no handles)
  drawTransformedImageOnly(dctx);
  // clear overlay state
  insertImage = null;
  ictx.clearRect(0,0,insertCanvas.width, insertCanvas.height);
  applyImageBtn.style.display = 'none';
  tool = prevToolForInsert || 'pen';
  prevToolForInsert = null;
  // save state after applying
  saveCanvasState();
});

// also cleanup on cancel/close
const cancelBtn = document.getElementById('cancelDraw');
if (cancelBtn) cancelBtn.addEventListener('click', ()=>{
  insertImage = null;
  applyImageBtn.style.display = 'none';
  tool = prevToolForInsert || tool;
  prevToolForInsert = null;
});

// augment pointer interactions when insert is active
(function attachInsertPointerHandlers(){
  drawCanvas.addEventListener('pointerdown', (e)=>{
    if (!insertImage) return; // let default tools handle
    const p = screenToCanvasPoint(e);
    const hit = hitHandle(p);
    if (!hit) return;
    e.preventDefault();
    insertTransform.dragging = true;
    insertTransform.dragMode = hit.mode;
    insertTransform.dragModeCorner = hit.corner || null;
    insertTransform.startPointer = p;
    insertTransform.startState = JSON.parse(JSON.stringify(insertTransform));
    drawCanvas.setPointerCapture(e.pointerId);
  });

  drawCanvas.addEventListener('pointermove', (e)=>{
    if (!insertImage || !insertTransform.dragging) return;
    const p = screenToCanvasPoint(e);
    const dx = p.x - insertTransform.startPointer.x;
    const dy = p.y - insertTransform.startPointer.y;
    const s = insertTransform.startState;
    switch (insertTransform.dragMode) {
      case 'move':
        insertTransform.x = s.x + dx;
        insertTransform.y = s.y + dy;
        break;
      case 'scale': {
        const corner = insertTransform.dragModeCorner || 'br';
        const signX = (corner === 'tr' || corner === 'br') ? 1 : -1;
        const signY = (corner === 'bl' || corner === 'br') ? 1 : -1;
        let factorX = 1 + (dx * signX) / 300;
        let factorY = 1 + (dy * signY) / 300;
        if (e.shiftKey) {
          const delta = Math.abs(dx) > Math.abs(dy) ? dx * signX : dy * signY;
          const f = 1 + delta / 300;
          factorX = f; factorY = f;
        }
        insertTransform.scaleX = Math.max(0.05, s.scaleX * factorX);
        insertTransform.scaleY = Math.max(0.05, s.scaleY * factorY);
        break;
      }
      case 'rotate': {
        const angle0 = Math.atan2(insertTransform.startPointer.y - s.y, insertTransform.startPointer.x - s.x);
        let angle1 = Math.atan2(p.y - s.y, p.x - s.x);
        let newAngle = s.rotation + (angle1 - angle0);
        if (e.shiftKey) {
          const step = Math.PI / 12; // 15°
          newAngle = Math.round(newAngle / step) * step;
        }
        insertTransform.rotation = newAngle;
        break;
      }
      case 'skewX': {
        insertTransform.skewX = s.skewX + dx / 300;
        break;
      }
      case 'skewY': {
        insertTransform.skewY = s.skewY + dy / 300;
        break;
      }
    }
    requestCanvasRedrawWithInsertOverlay();
  });

  const stop = (e)=>{
    if (!insertImage) return;
    if (insertTransform.dragging) {
      insertTransform.dragging = false;
      drawCanvas.releasePointerCapture(e.pointerId);
    }
  };
  drawCanvas.addEventListener('pointerup', stop);
  drawCanvas.addEventListener('pointercancel', stop);
})();


// ... existing code ...
function drawTransformedImageOverlay() {
  if (!insertImage) {
    ictx.clearRect(0,0,insertCanvas.width,insertCanvas.height);
    return;
  }
  ictx.clearRect(0,0,insertCanvas.width,insertCanvas.height);
  const ctx = ictx;
  const cx = insertTransform.x;
  const cy = insertTransform.y;
  const w = insertTransform.width;
  const h = insertTransform.height;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.drawImage(insertImage, -w/2, -h/2, w, h);
  ctx.restore();
  // Handles + bbox
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.strokeStyle = '#39f';
  ctx.lineWidth = 1;
  ctx.setLineDash([6,4]);
  ctx.strokeRect(-w/2, -h/2, w, h);
  ctx.setLineDash([]);
  ctx.fillStyle = '#39f';
  const halfCorner = HANDLE.corner / 2;
  [[-w/2,-h/2],[w/2,-h/2],[w/2,h/2],[-w/2,h/2]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-halfCorner, hy-halfCorner, HANDLE.corner, HANDLE.corner);
  });
  ctx.beginPath();
  ctx.arc(0, -h/2-HANDLE.rotOffset, HANDLE.rotRadius, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#9cf';
  const halfEdge = HANDLE.edge / 2;
  [[0,-h/2],[w/2,0],[0,h/2],[-w/2,0]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-halfEdge, hy-halfEdge, HANDLE.edge, HANDLE.edge);
  });
  ctx.restore();
}
// ... existing code ...

// ... existing code ...
function drawTransformedImageOnly(ctx) {
  if (!insertImage) return;
  const cx = insertTransform.x;
  const cy = insertTransform.y;
  const w = insertTransform.width;
  const h = insertTransform.height;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.drawImage(insertImage, -w/2, -h/2, w, h);
  ctx.restore();
}
// ... existing code ...

// Persist project title immediately on edit and reflect to document.title
(function bindProjectTitlePersistence(){
  const titleEl = document.getElementById('projectTitle');
  if (!titleEl) return;
  const persist = ()=>{ saveAuto(); try { document.title = (titleEl.value || 'LadaBoard - Storyboard Maker'); } catch(_) {} };
  titleEl.addEventListener('input', persist);
  titleEl.addEventListener('change', persist);
  titleEl.addEventListener('blur', persist);
})();

// Helper: get user-friendly music display name (avoid blob/data UUIDs)
function getMusicDisplayName(frame) {
  if (!frame) return 'Audio';
  const named = (typeof frame.musicName === 'string' && frame.musicName.trim()) ? frame.musicName.trim() : null;
  if (named) return named;
  const url = frame.music || '';
  if (/^https?:/i.test(url) || /^file:/i.test(url)) {
    try { return url.split('/').pop().split('?')[0] || 'Audio'; } catch(_) { return 'Audio'; }
  }
  // For blob: or data: URLs we cannot infer a filename reliably
  return 'Audio';
}

// ===== Timeline module (Flash/Animate-like) =====
const tl = {
  canvas: null,
  ctx: null,
  scroller: null,
  zoom: 0.6,            // default zoomed out
  basePxPerFrame: 6,    // compact grid
  rowHeight: 24,
  headerH: 56,
  gutterW: 100,
  bottomPad: 12,
  selection: new Set(),
  drag: null,
  playhead: 0,
  flashIndex: -1,
  flashUntil: 0,
  moveAnim: null,
  get pxPerFrame() { return this.basePxPerFrame * this.zoom; },
  dpr: 1,
};

function computeFramePositions(){
  const map = new Map();
  let cursor = tl.gutterW;
  for (let i=0;i<state.frames.length;i++){
    map.set(state.frames[i], cursor);
    const dur = Math.max(1, safeNumber(state.frames[i]?.duration, state.defaultDuration));
    cursor += dur * tl.pxPerFrame;
  }
  return map;
}

function getTimelineTotalFrames(){
  const fps = Math.max(1, state.fps||24);
  const total = (state.frames && state.frames.length)
    ? state.frames.reduce((sum, fr) => sum + Math.max(1, safeNumber(fr?.duration, state.defaultDuration)), 0)
    : fps * 10; // show 10 seconds grid when empty
  return Math.max(1, total);
}

(function initTimeline(){
  tl.canvas = document.getElementById('timelineCanvas');
  tl.scroller = document.getElementById('timelineScroller');
  if (!tl.canvas || !tl.scroller) return;
  tl.ctx = tl.canvas.getContext('2d');
  setTimelineSize();
  wireTimelineEvents();
  updateTlScaleText();
  renderTimeline();
})();

function setTimelineSize(){
  if (!tl.canvas) return;
  const totalFramesCount = getTimelineTotalFrames();
  const computedWidth = Math.ceil(tl.gutterW + totalFramesCount * tl.pxPerFrame + 120);
  const viewportMin = Math.max(900, (tl.scroller && tl.scroller.clientWidth) ? tl.scroller.clientWidth : 0);
  const cssWidth = Math.max(computedWidth, viewportMin);
  const cssHeight = tl.headerH + tl.rowHeight * 1 + 12 + tl.bottomPad;
  const ctx = tl.canvas.getContext('2d');
  tl.canvas.width = cssWidth;
  tl.canvas.height = cssHeight;
  tl.canvas.style.width = cssWidth + 'px';
  tl.canvas.style.height = cssHeight + 'px';
  // render in CSS pixel units (no DPR scaling) to avoid distortion
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  tl.ctx = ctx; // ensure reference is up to date
}

function updateTlScaleText(){
  const el = document.getElementById('tlScaleText');
  if (el) el.textContent = `${(tl.pxPerFrame).toFixed(1)} px/frame`;
  updateTimecode();
}

function formatTimecode(frames, fps){
  const totalFrames = Math.max(0, Math.floor(frames));
  const ff = totalFrames % fps;
  const totalSec = Math.floor(totalFrames / fps);
  const ss = totalSec % 60;
  const mm = Math.floor((totalSec / 60)) % 60;
  const hh = Math.floor(totalSec / 3600);
  const z = n => String(n).padStart(2,'0');
  return `${z(hh)}:${z(mm)}:${z(ss)}:${z(ff)} / ${z(ff)}f`;
}

function updateTimecode(){
  const t = document.getElementById('tlTimecode');
  if (!t) return;
  const fps = Math.max(1, state.fps||24);
  t.textContent = formatTimecode(tl.playhead, fps);
}

function renderTimeline(){
  if (!tl.ctx) return;
  setTimelineSize();
  const ctx = tl.ctx;
  const w = tl.canvas.width, h = tl.canvas.height;
  ctx.clearRect(0,0,w,h);
  updateTimecode();
  ctx.textBaseline = 'alphabetic';
  ctx.fillStyle = '#0d0f13';
  ctx.fillRect(0,0,w,h);
  ctx.fillStyle = '#161616';
  ctx.fillRect(tl.gutterW,0,w-tl.gutterW,tl.headerH);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.beginPath(); ctx.moveTo(0, tl.headerH+0.5); ctx.lineTo(w, tl.headerH+0.5); ctx.stroke();

  const fps = Math.max(1, state.fps||24);
  const pxpf = tl.pxPerFrame;
  const totalFrames = getTimelineTotalFrames();

  ctx.fillStyle = 'rgba(255,255,255,0.015)';
  ctx.fillRect(tl.gutterW, tl.headerH, w - tl.gutterW, h - tl.headerH);
  for (let f = 0; f <= totalFrames; f++){
    const x = Math.round(tl.gutterW + f * pxpf) + 0.5;
    let alpha = 0.06;
    if (f % fps === 0) { alpha = 0.25; }
    else if (f % 10 === 0) { alpha = 0.16; }
    else if (f % 5 === 0) { alpha = 0.10; }
    ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
    ctx.beginPath(); ctx.moveTo(x, tl.headerH); ctx.lineTo(x, h); ctx.stroke();
    if (f % fps === 0) {
      ctx.fillStyle = '#9aa3b2';
      ctx.font = '12px Segoe UI, Roboto, system-ui, sans-serif';
      const sec = f / fps;
      ctx.fillText(String(sec), Math.round(x + 8), 22);
    }
  }

  ctx.fillStyle = '#141414';
  ctx.fillRect(0,0,tl.gutterW,h);
  ctx.fillStyle = '#e6eef8';
  ctx.font = '11px Segoe UI, Roboto, system-ui, sans-serif';
  ctx.fillText('Frames', 10, tl.headerH + (tl.rowHeight-11)/2 + 1);

  // compute current playing index from playhead
  let playingIdx = -1;
  if (playing) { playingIdx = frameIndexFromAbsFrame(Math.max(0, Math.floor(tl.playhead))); }

  // prepare position maps for animation
  const now = performance.now();
  const anim = tl.moveAnim;
  const toMap = anim && anim.toMap ? anim.toMap : computeFramePositions();
  const t = anim ? Math.min(1, (now - anim.start) / Math.max(1, anim.duration)) : 1;

  for (let i=0;i<state.frames.length;i++){
    const f = state.frames[i];
    const dur = Math.max(1, safeNumber(f?.duration, state.defaultDuration));
    const spanW = dur * pxpf;
    const y = tl.headerH + 2;
    const height = tl.rowHeight - 4;

    const toX = toMap.get(f) ?? tl.gutterW;
    const fromX = anim && anim.fromMap ? (anim.fromMap.get(f) ?? toX) : toX;
    const startX = fromX + (toX - fromX) * t;

    const hasThumb = !!f?.thumb;
    if (hasThumb) {
      ctx.fillStyle = 'rgba(154,163,178,0.12)';
      ctx.fillRect(Math.floor(startX)+0.5, y, Math.floor(spanW), height);
    } else {
      const step = Math.max(4, Math.floor(pxpf));
      ctx.save();
      ctx.beginPath(); ctx.rect(Math.floor(startX)+0.5, y, Math.floor(spanW), height); ctx.clip();
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for (let xx = Math.floor(startX); xx < startX + spanW; xx += step*2) {
        ctx.fillRect(xx, y, step, height);
      }
      ctx.restore();
    }

    // playing highlight (distinct from selection)
    if (playing && i === playingIdx) {
      ctx.save();
      const pulse = 0.16 + 0.08 * Math.abs(Math.sin(now/180));
      ctx.fillStyle = `rgba(217,250,0,${pulse})`;
      ctx.fillRect(Math.floor(startX)+0.5, y, Math.floor(spanW), height);
      ctx.restore();
    }

    // outline for span
    ctx.strokeStyle = tl.selection.has(i) ? 'rgba(217,250,0,0.85)' : 'rgba(255,255,255,0.35)';
    ctx.strokeRect(Math.floor(startX)+0.5, y, Math.floor(spanW), height);

    // keyframe dot at start
    ctx.fillStyle = '#e6eef8';
    ctx.beginPath(); ctx.arc(startX + 4, y + height/2 + 1, 2, 0, Math.PI*2); ctx.fill();

    // index label
    ctx.fillStyle = '#9aa3b2';
    ctx.font = '11px Segoe UI, Roboto, system-ui, sans-serif';
    ctx.fillText(String(i+1), startX + 8, y + height/2 + 5);

    // flash on reorder drop
    if (tl.flashIndex === i && tl.flashUntil > now) {
      ctx.save();
      const k = Math.max(0, (tl.flashUntil - now) / 450);
      const a = 0.25 * k;
      ctx.strokeStyle = `rgba(217,250,0,${Math.min(0.45, 0.2 + a)})`;
      ctx.lineWidth = 2;
      ctx.strokeRect(Math.floor(startX)+0.5, y, Math.floor(spanW), height);
      ctx.restore();
    }
  }

  // playhead
  const phx = tl.gutterW + tl.playhead * pxpf;
  ctx.strokeStyle = 'var(--accent)';
  ctx.beginPath(); ctx.moveTo(Math.round(phx) + 0.5, 0); ctx.lineTo(Math.round(phx) + 0.5, h); ctx.stroke();
  ctx.fillStyle = 'var(--accent)';
  ctx.beginPath(); ctx.moveTo(Math.round(phx)-4, 0); ctx.lineTo(Math.round(phx)+4, 0); ctx.lineTo(Math.round(phx), 6); ctx.closePath(); ctx.fill();
}

function ensurePlayheadVisible(){
  if (!tl.scroller) return;
  const viewportW = tl.scroller.clientWidth;
  const left = tl.scroller.scrollLeft;
  const phxCss = tl.gutterW + tl.playhead * tl.pxPerFrame;
  const margin = 40; // keep some headroom
  if (phxCss > left + viewportW - margin) {
    tl.scroller.scrollLeft = phxCss - viewportW + margin;
  } else if (phxCss < left + margin) {
    tl.scroller.scrollLeft = Math.max(0, phxCss - margin);
  }
}

function timelinePosToFrame(px){
  return Math.max(0, (px - tl.gutterW) / tl.pxPerFrame);
}

function frameIndexAtX(px){
  let cursor = tl.gutterW;
  for (let i=0;i<state.frames.length;i++){
    const dur = Math.max(1, safeNumber(state.frames[i]?.duration, state.defaultDuration));
    const next = cursor + dur * tl.pxPerFrame;
    if (px >= cursor && px < next) return { index: i, startX: cursor, endX: next, dur };
    cursor = next;
  }
  return null;
}

function frameIndexFromAbsFrame(absFrame){
  let acc = 0;
  for (let i=0;i<state.frames.length;i++){
    const dur = Math.max(1, state.frames[i].duration);
    if (absFrame < acc + dur) return i;
    acc += dur;
  }
  return state.frames.length ? state.frames.length - 1 : -1;
}

function wireTimelineEvents(){
  const c = tl.canvas; if (!c) return;

  const zi = document.getElementById('tlZoomIn');
  const zo = document.getElementById('tlZoomOut');
  zi && zi.addEventListener('click', ()=>{ tl.zoom = Math.min(8, tl.zoom*1.25); updateTlScaleText(); renderTimeline(); });
  zo && zo.addEventListener('click', ()=>{ tl.zoom = Math.max(0.25, tl.zoom/1.25); updateTlScaleText(); renderTimeline(); });

  c.addEventListener('mousedown', (e)=>{
    const rect = c.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    const y = (e.clientY - rect.top);

    // if grabbing near playhead anywhere -> scrub
    const phx = tl.gutterW + tl.playhead * tl.pxPerFrame;
    if (Math.abs(x - phx) <= 6) {
      if (selectedFrames.size > 1 && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
        try { collapseSelectionToPrimary(); } catch(_){ }
      }
      tl.drag = { type:'scrub', startX:x };
      c.style.cursor = 'ew-resize';
      return;
    }

    // header scrub
    if (y <= tl.headerH){
      if (selectedFrames.size > 1 && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
        try { collapseSelectionToPrimary(); } catch(_){ }
      }
      tl.drag = { type:'scrub', startX:x };
      tl.playhead = Math.max(0, timelinePosToFrame(x));
      seekToPlayhead();
      ensurePlayheadVisible();
      updatePausedFromPlayhead();
      renderTimeline();
      c.style.cursor = 'ew-resize';
      return;
    }

    // if no frames or clicking outside spans: map to nearest frame index
    if (!state.frames.length || !frameIndexAtX(x)){
      const absF = timelinePosToFrame(x);
      const idx = frameIndexFromAbsFrame(absF);
      if (selectedFrames.size > 1 && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
        // collapse multi-selection, keep playhead move, do not change selection to nearest
        try { collapseSelectionToPrimary(); } catch(_){ }
        tl.playhead = absF;
        ensurePlayheadVisible();
        updatePausedFromPlayhead();
        renderTimeline();
        return;
      }
      if (idx >= 0){
        if (e.shiftKey && state.selected >= 0){
          const start = Math.min(state.selected, idx);
          const end = Math.max(state.selected, idx);
          tl.selection.clear();
          for (let k=start;k<=end;k++) tl.selection.add(k);
        } else {
          tl.selection = new Set([idx]);
        }
        try { selectFrame(idx, e); } catch(_){ }
        // also move playhead to clicked position
        tl.playhead = absF;
        ensurePlayheadVisible();
        updatePausedFromPlayhead();
        renderTimeline();
      }
      return;
    }

    const hit = frameIndexAtX(x);
    const edgeThreshold = 6;
    const nearEnd = Math.abs(x - hit.endX) <= edgeThreshold;
    const nearStart = Math.abs(x - hit.startX) <= edgeThreshold;

    // Resize rule: only right edge; require selected OR hold Shift for direct
    if (nearEnd && (tl.selection.has(hit.index) || e.shiftKey)){
       tl.drag = { type:'resize', frameIndex: hit.index, edge: 'end', startX: x, origDur: hit.dur };
       // if shift-resize, do not change selection; otherwise keep selection as-is
       if (!tl.selection.has(hit.index) && !e.shiftKey){
         try { selectFrame(hit.index, e); } catch(_){ }
       }
       c.style.cursor = 'ew-resize';
       return;
     }

    // range select with Shift-click (not resizing)
    if (e.shiftKey && state.selected >= 0){
      const start = Math.min(state.selected, hit.index);
      const end = Math.max(state.selected, hit.index);
      tl.selection.clear();
      for (let k=start;k<=end;k++) tl.selection.add(k);
      try { selectFrame(hit.index, e); } catch(_){ }
      renderTimeline();
      return;
    }

    // If multi-selected and click on any frame without modifiers, collapse to that frame
    if (selectedFrames.size > 1 && !e.ctrlKey && !e.metaKey && !e.shiftKey && !nearEnd) {
      try { selectFrame(hit.index, e); } catch(_){ }
      renderTimeline();
      // do not return; allow drag/copy setup below
    }

    // Ctrl/Meta click toggles selection for timeline items
    if (e.ctrlKey || e.metaKey){
      // rely on selectFrame to manage selectedFrames toggling logic consistently with sidebar
      try { selectFrame(hit.index, e); } catch(_){ }
      // tl.selection is synced by selectFrame
      renderTimeline();
      return;
    }

    // normal select then drag/copy
    if (!tl.selection.has(hit.index)){
      if (!e.ctrlKey) tl.selection.clear();
      tl.selection.add(hit.index);
      try { selectFrame(hit.index, e); } catch(_){ }
      renderTimeline();
    }
    if (e.altKey) {
      tl.drag = { type:'copy', fromIndex: hit.index, startX: x, dropIndex: hit.index };
      c.style.cursor = 'move';
    } else {
      tl.drag = { type:'move', frameIndex: hit.index, startX: x, origIndex: hit.index };
      c.style.cursor = 'move';
    }
  });

  window.addEventListener('mousemove', (e)=>{
    const rect = c.getBoundingClientRect();
    const x = (e.clientX - rect.left);
    if (!tl.drag){
      // hover cursor feedback
      const hit = frameIndexAtX(x);
      if (hit){
        const edgeThreshold = 6;
        const nearEnd = Math.abs(x - hit.endX) <= edgeThreshold;
        const nearStart = Math.abs(x - hit.startX) <= edgeThreshold;
        if (nearEnd /* only right-edge resize */){
          c.style.cursor = 'ew-resize';
        } else {
          c.style.cursor = 'move';
        }
      } else {
        c.style.cursor = 'default';
      }
    }
    if (!tl.drag) return;
    
    if (tl.drag.type === 'scrub'){
      tl.playhead = Math.max(0, timelinePosToFrame(x));
      seekToPlayhead();
      ensurePlayheadVisible();
      updatePausedFromPlayhead();
      renderTimeline();
      return;
    }

    if (tl.drag.type === 'resize'){
      const idx = tl.drag.frameIndex;
      const startAbs = state.frames.slice(0, idx).reduce((a,b)=> a + Math.max(1, b.duration), 0);
      const newDurFrames = Math.max(1, Math.round(timelinePosToFrame(x) - startAbs));
      state.frames[idx].duration = newDurFrames;
      syncSidebarDuration(idx);
      renderTimeline();
      c.style.cursor = 'ew-resize';
      return;
    }

    if (tl.drag.type === 'copy'){
      const hit = frameIndexAtX(x);
      tl.drag.dropIndex = hit ? hit.index : state.frames.length - 1;
      c.style.cursor = 'move';
      return;
    }
  });

  window.addEventListener('mouseup', (e)=>{
    if (!tl.drag) return;
    const kind = tl.drag.type; const info = tl.drag; tl.drag = null;
    const c = tl.canvas; if (c) c.style.cursor = 'default';
    if (kind === 'scrub') return;
    if (kind === 'copy'){
      // animate copy insertion
      let beforeMap = null; try { beforeMap = computeFramePositions(); } catch(_){}
      const from = info.fromIndex;
      const to = Math.min(state.frames.length, (info.dropIndex ?? from) + 1);
      try { pushHistory(); } catch(_){ }
      const clone = JSON.parse(JSON.stringify(state.frames[from]));
      state.frames.splice(to, 0, clone);
      renderList();
      selectFrame(to);
      saveAuto();
      try { const afterMap = computeFramePositions(); tl.moveAnim = { fromMap: beforeMap || new Map(), toMap: afterMap, start: performance.now(), duration: 320 }; animateTimelineMove(); } catch(_){}
      try { tl.flashIndex = to; tl.flashUntil = performance.now() + 450; animateTimelineFlash(); } catch(_){}
    }
    if (kind === 'move'){
      const rect = tl.canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const hit = frameIndexAtX(x);
      const dropIndex = hit ? hit.index : state.frames.length - 1;
      if (dropIndex !== undefined && dropIndex !== info.origIndex){
        reorder(info.origIndex, dropIndex);
        try { tl.flashIndex = dropIndex; tl.flashUntil = performance.now() + 450; animateTimelineFlash(); } catch(_){}
      }
    }
    renderTimeline();
  });

  // Keyboard shortcuts in timeline area
  window.addEventListener('keydown', (e)=>{
    // Skip timeline Ctrl+A when typing in inputs/textareas/contentEditable
    const tgt = e.target || document.activeElement;
    const isInputting = tgt && (tgt.tagName === 'INPUT' || tgt.tagName === 'TEXTAREA' || tgt.isContentEditable);
    if (isInputting) return;
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='a'){
      e.preventDefault();
      tl.selection.clear();
      for(let i=0;i<state.frames.length;i++) tl.selection.add(i);
      try {
        selectedFrames.clear();
        for(let i=0;i<state.frames.length;i++) selectedFrames.add(i);
        highlightSelected();
      } catch(_){ }
      renderTimeline();
    }
  });
}

function syncSidebarDuration(index){
  renderList();
  if (state.selected === index){
    const parts = splitDurationFrames(state.frames[index].duration, state.fps);
    durationSecInput.value = String(parts.sec);
    durationFrmInput.value = String(parts.frm);
  }
  saveAuto();
}

function seekToPlayhead(){
  let framesSoFar = 0;
  for (let i=0;i<state.frames.length;i++){
    const dur = Math.max(1, state.frames[i].duration);
    if (tl.playhead < framesSoFar + dur){
      if (i !== state.selected) {
        selectFrame(i);
      }
      break;
    }
    framesSoFar += dur;
  }
}

const origRenderList = renderList;
renderList = function(){
  origRenderList();
  setTimelineSize();
  renderTimeline();
};

fpsInput.addEventListener('change', ()=>{ setTimelineSize(); renderTimeline(); });

function setPlayheadFromElapsedMs(ms){
  tl.playhead = Math.round((ms * state.fps / 1000));
  ensurePlayheadVisible();
  renderTimeline();
}
// ... existing code ...

function updatePausedFromPlayhead(){
  try {
    const fps = Math.max(1, state.fps || 24);
    pausedTime = (tl.playhead / fps) * 1000; // resume starts from playhead
    currentFrameIndex = -1; // force recalculation on next loop
  } catch(_){}
}

// keep paused time consistent with playhead when fps changes
fpsInput.addEventListener('change', ()=>{ updatePausedFromPlayhead(); updateTimecode(); });

function animateTimelineFlash(){
  if (!tl.canvas) return;
  if (!tl.flashIndex || tl.flashUntil <= performance.now()) { renderTimeline(); return; }
  renderTimeline();
  requestAnimationFrame(animateTimelineFlash);
}
function animateTimelineMove(){
  if (!tl.canvas) return;
  const anim = tl.moveAnim;
  if (!anim) { renderTimeline(); return; }
  const now = performance.now();
  if (now >= anim.start + anim.duration) { tl.moveAnim = null; renderTimeline(); return; }
  renderTimeline();
  requestAnimationFrame(animateTimelineMove);
}

// Clear multi-selection when clicking stage or outside of any frame card
function collapseSelectionToPrimary(){
  if (selectedFrames.size <= 1) return;
  const primary = clampIndex(state.selected);
  selectedFrames.clear();
  if (primary >= 0) selectedFrames.add(primary);
  try { if (tl) { tl.selection = new Set([primary]); renderTimeline(); } } catch(_){ }
  highlightSelected();
}

(function setupClickToUnselect(){
  const stageEl = document.getElementById('stage');
  if (stageEl) {
    stageEl.addEventListener('click', (e)=>{
      if (selectedFrames.size > 1) collapseSelectionToPrimary();
    });
  }
  document.addEventListener('click', (e)=>{
    if (selectedFrames.size <= 1) return;
    const t = e.target;
    // ignore clicks on a frame card or inside the timeline area
    if (t.closest && (t.closest('.frame') || t.closest('#timelineContainer'))) return;
    // if click is not inside the frames list area (or on any frame), clear
    if (!t.closest || (!t.closest('#framesList') && !t.closest('.frame'))) {
      collapseSelectionToPrimary();
    }
  });
})();

// NEW: TL controls wiring to same guidesState
(function initTimelineGuides(){
  const tlTgl = document.getElementById('tlToggleGuides');
  const tlTr = document.getElementById('tlToggleRulers');
  const tlAspect = document.getElementById('tlGuideAspect');
  const tlTitle = document.getElementById('tlTitleSafePct');
  const tlAction = document.getElementById('tlActionSafePct');
  if (tlTgl) tlTgl.addEventListener('click', ()=>{ guidesState.enabled = !guidesState.enabled; applyGuideUI(); try { redrawPaths(); drawPreview(); drawOutsideRulers(); drawPreviewOutsideRulers(); } catch(e){} });
  if (tlTr) tlTr.addEventListener('click', ()=>{ guidesState.rulers = !guidesState.rulers; applyGuideUI(); try { redrawPaths(); drawPreview(); drawOutsideRulers(); drawPreviewOutsideRulers(); } catch(e){} });
  if (tlAspect) tlAspect.addEventListener('change', ()=>{
    const v = (tlAspect.value || '1920x1080').split('x');
    guidesState.artW = Number(v[0]) || 1920; guidesState.artH = Number(v[1]) || 1080; applyGuideUI();
    try { redrawPaths(); drawPreview(); drawOutsideRulers(); drawPreviewOutsideRulers(); } catch(e){}
  });
  if (tlTitle) tlTitle.addEventListener('change', ()=>{ guidesState.titleSafePct = Math.max(50, Math.min(100, Number(tlTitle.value)||90)); applyGuideUI(); try { redrawPaths(); drawPreview(); drawOutsideRulers(); drawPreviewOutsideRulers(); } catch(e){} });
  if (tlAction) tlAction.addEventListener('change', ()=>{ guidesState.actionSafePct = Math.max(50, Math.min(100, Number(tlAction.value)||95)); applyGuideUI(); try { redrawPaths(); drawPreview(); drawOutsideRulers(); drawPreviewOutsideRulers(); } catch(e){} });
  // initial sync for TL controls
  applyGuideUI();
})();
// ... existing code ...

function drawTintedLinesFromImage(ctx, img, tintCss, alpha){
   const cw = ctx.canvas && ctx.canvas.width ? ctx.canvas.width : drawCanvas.width;
   const ch = ctx.canvas && ctx.canvas.height ? ctx.canvas.height : drawCanvas.height;
   const off = document.createElement('canvas'); off.width = cw; off.height = ch;
   const ox = off.getContext('2d');
   // draw source fitted
   try { drawImageCover(ox, img, cw, ch); } catch(_){ return; }
   const data = ox.getImageData(0,0,cw,ch);
   const arr = data.data;
   const tint = hexToRgba(tintCss || '#ff0000');
   const aBase = Math.max(0, Math.min(1, alpha == null ? 0.45 : alpha));
   let any = false;
   for (let i = 0; i < arr.length; i+=4) {
     const r = arr[i], g = arr[i+1], b = arr[i+2], a = arr[i+3];
     if (a < 16) { arr[i+3] = 0; continue; }
     const br = 0.2126*r + 0.7152*g + 0.0722*b;
     if (br > 245) { // near white -> transparent
       arr[i+3] = 0; continue;
     }
     const w = (255 - br) / 255; // darker -> stronger
     arr[i] = tint.r; arr[i+1] = tint.g; arr[i+2] = tint.b;
     arr[i+3] = Math.max(0, Math.min(255, Math.round(255 * aBase * (0.35 + 0.65*w))));
     if (!any && arr[i+3] > 4) any = true;
   }
   ox.putImageData(data,0,0);
   ctx.save();
   ctx.globalAlpha = 1;
   ctx.drawImage(off,0,0);
   ctx.restore();
   return any;
 }

// -- preview image cache and prefetch helpers --
let lastPreviewImage = null;
let lastPreviewIndex = -1;
function primeCacheAround(index, radius = 2) {
  if (!Array.isArray(state.frames) || state.frames.length === 0) return;
  const start = Math.max(0, index - radius);
  const end = Math.min(state.frames.length - 1, index + radius);
  for (let i = start; i <= end; i++) {
    const f = state.frames[i];
    if (f && f.thumb) ensureFrameImage(f);
  }
}

// Safe fallback: returns a transparent canvas the same size; adjust to real mask implementation if available
function createStrokeMaskCanvasFromContext(ctx, w, h) {
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const x = c.getContext('2d');
  // If needed, we can derive mask from current drawCanvas content; for now leave transparent to avoid punching holes in onion
  return c;
}

// Bitmap cache for onion skin to ensure neighbors show up reliably
function ensureFrameBitmap(frame, refIndexForRerender) {
  if (!frame || !frame.thumb) return;
  if (frame._bmp) return;
  if (frame._bmpPromise) return;
  frame._bmpPromise = createBitmapFromSrc(frame.thumb).then(bmp => {
    frame._bmp = bmp;
    frame._bmpPromise = null;
    // trigger overlay redraw once decoded
    try {
      if (drawDialog.classList.contains('open')) {
        const idx = (typeof currentOnionRefIndex === 'number' && currentOnionRefIndex >= 0)
          ? currentOnionRefIndex
          : ((typeof editIndex === 'number' && editIndex != null) ? editIndex : (refIndexForRerender ?? state.selected));
        renderOnionSkinsOverlay(typeof idx === 'number' ? idx : 0);
      } else {
        drawPreview();
      }
    } catch(_){}
    return bmp;
  }).catch(() => { frame._bmpPromise = null; });
}

function primeOnionNeighbors(centerIndex, radius = 3) {
  if (!Array.isArray(state.frames) || state.frames.length === 0) return;
  const order = [];
  for (let i = 1; i <= radius; i++) {
    order.push(centerIndex - i, centerIndex + i);
  }
  for (const idx of order) {
    if (idx >= 0 && idx < state.frames.length) ensureFrameBitmap(state.frames[idx], centerIndex);
  }
 }

// Fast path: cached, downscaled onion mask per frame (warm/cool), then scaled up on draw
function drawOnionTintedCached(ctx, frame, isWarm, aBase){
  try {
    if (!frame) return false;
    const cw = (ctx.canvas && ctx.canvas.width) ? ctx.canvas.width : drawCanvas.width;
    const ch = (ctx.canvas && ctx.canvas.height) ? ctx.canvas.height : drawCanvas.height;
    const img = frame._bmp || (frame._img && frame._img.complete && frame._img.naturalWidth > 0 ? frame._img : null);
    if (!img) return false;

    if (!frame._onionCache || frame._onionCache.src !== frame.thumb) {
      frame._onionCache = { src: frame.thumb, warm: null, cool: null, w: 0, h: 0 };
    }

    const key = isWarm ? 'warm' : 'cool';
    const targetAspect = cw / Math.max(1, ch);
    const PROC_W = 256; // low-res processing width (fast)
    const PROC_H = Math.max(1, Math.round(PROC_W / targetAspect));

    let mask = frame._onionCache[key];
    if (!mask || frame._onionCache.w !== PROC_W || frame._onionCache.h !== PROC_H) {
      const off = document.createElement('canvas');
      off.width = PROC_W; off.height = PROC_H;
      const ox = off.getContext('2d');
      try { drawImageCover(ox, img, PROC_W, PROC_H); } catch(_) { return false; }
      const data = ox.getImageData(0, 0, PROC_W, PROC_H);
      const arr = data.data;
      const tint = isWarm ? { r:255, g:120, b:90 } : { r:110, g:230, b:200 };
      for (let i = 0; i < arr.length; i += 4) {
        const a = arr[i+3];
        if (a < 16) { arr[i+3] = 0; continue; }
        const r = arr[i], g = arr[i+1], b = arr[i+2];
        const br = 0.2126*r + 0.7152*g + 0.0722*b;
        if (br > 245) { arr[i+3] = 0; continue; }
        const w = (255 - br) / 255; // darker -> stronger
        arr[i] = tint.r; arr[i+1] = tint.g; arr[i+2] = tint.b;
        // store normalized alpha (aBase applied at draw time)
        arr[i+3] = Math.max(0, Math.min(255, Math.round(255 * (0.35 + 0.65*w))));
      }
      ox.putImageData(data, 0, 0);
      frame._onionCache[key] = off;
      frame._onionCache.w = PROC_W;
      frame._onionCache.h = PROC_H;
      mask = off;
    }

    ctx.save();
    ctx.globalAlpha = Math.max(0, Math.min(1, aBase == null ? 0.45 : aBase));
    try { ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'medium'; } catch(_){}
    ctx.drawImage(mask, 0, 0, cw, ch);
    ctx.restore();
    return true;
  } catch(_) { return false; }
}
// ... existing code ...

</script>
</body>
</html>
