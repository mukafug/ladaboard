<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LadaBoard - Storyboard Maker</title>
<!-- 
  STORYBOARD HTML - Onion Skin System
  
  PERUBAHAN ONION SKIN:
  - Onion skin sekarang menggunakan overlay canvas terpisah (onionCanvas)
  - Onion skin tidak pernah tercampur dengan gambar utama (drawCanvas)
  - Onion skin hanya muncul di mode edit/draw
  - Preview dan export tidak menampilkan onion skin
  - Bitmap final hanya berisi gambar utama tanpa onion skin
  
  Struktur Canvas:
  - drawCanvas (z-index: 1): Gambar utama + hasil drawing
  - onionCanvas (z-index: 2): Overlay onion skin (transparan, pointer-events: none)
-->
<link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
:root{--bg:#0f1115;--panel:#141619;--muted:#9aa3b2;--accent:#d9fa00;--accent-2:#d9fa00;}
*{box-sizing:border-box;font-family:Inter,Segoe UI,Roboto,system-ui,Arial}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0c0e 0%, #0f1115 100%);color:#e6eef8}
.app {
  display: flex; /* ubah dari grid ke flexbox */
  gap: 18px;
  padding: 18px;
  height: 100vh;
  align-items: flex-start; /* penting untuk sticky positioning */
}
.sidebar {
  display: flex;
  flex-direction: column;
  width: 360px; /* fixed width untuk sidebar */
  flex-shrink: 0; /* mencegah sidebar menyusut */
  height: 100vh; /* full height */
  background: var(--panel);
  border-radius: 10px;
  padding: 12px;
  gap: 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  overflow: hidden; /* mencegah sidebar scroll */
}
.header{display:flex;gap:8px;align-items:center}
.logo{padding:8px 12px;background:linear-gradient(90deg,var(--accent),var(--accent-2));border-radius:8px;font-weight:700;color:#000}
.controls{display:flex;gap:8px;margin-left:auto}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer; display:inline-flex; align-items:center; gap: 6px;}
.btn:hover{border-color: var(--accent); background: rgba(217,250,0,0.08); color:#fff; box-shadow: 0 6px 16px rgba(217,250,0,0.08)}
.btn:focus-visible{outline:none; box-shadow:0 0 0 2px rgba(217,250,0,0.55)}
.mode-toggle{position:relative;display:grid;grid-template-columns:1fr 1fr;align-items:center;gap:0;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.1);border-radius:12px;padding:4px;--pos:0;min-width:160px}
.mode-toggle .toggle-thumb{position:absolute;top:4px;left:4px;width:calc(50% - 0px);height:calc(100% - 8px);background:linear-gradient(90deg,var(--accent),var(--accent-2));border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.35);transform:translateX(calc(var(--pos)*100%));transition:transform 220ms cubic-bezier(.2,.8,.2,1),width 220ms}
.mode-toggle button{position:relative;z-index:1;background:transparent;border:none;cursor:pointer;padding:8px 14px;border-radius:8px;color:var(--muted);font-weight:700}
.mode-toggle .active{color:#071017}
.list {
  flex: 1;
  overflow-y: auto;       /* biar bisa digulir */
  padding: 6px;
  background: linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
  border-radius: 8px;
  scroll-behavior: smooth; /* smooth scrolling */

  /* sembunyikan scrollbar */
  scrollbar-width: none;  /* Firefox */
}
.list::-webkit-scrollbar { 
  display: none;          /* Chrome, Edge, Safari */
}
.frame{display:grid;grid-template-columns:56px 1fr 64px;gap:10px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:8px;border:1px solid rgba(255,255,255,0.02);transition: all 0.2s ease;}
.frame.selected{background:rgba(217,250,0,0.08);border-color:var(--accent);}
.frame.selected input:focus{background:rgba(255,255,255,0.1);}
.thumb{width:56px;height:40px;border-radius:4px;background:#0a0a0b;display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:12px;overflow:hidden}
.meta{display:flex;flex-direction:column;gap:6px}
.meta input[type=text]{width:100%;background:transparent;border:none;color:inherit;outline:none}
.small{font-size:12px;color:var(--muted)}
.side-right {
  background: var(--panel);
  border-radius: 10px;
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  position: sticky;
  top: 18px; /* biar nempel di atas */
  flex: 1; /* ambil sisa ruang yang tersedia */
  max-width: calc(100vw - 396px); /* 360px sidebar + 18px gap + 18px padding */
  height: fit-content; /* tinggi sesuai konten */
  overflow: visible; /* pastikan tidak ada overflow yang mengganggu sticky */
}
.canvas-stage{background:#050607;border-radius:8px;aspect-ratio:16/9;width:100%;max-height:70vh;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
.canvas-stage canvas{width:100%;height:100%;object-fit:contain;background:#000;border-radius:4px}
.toolbar{display:flex;gap:8px;align-items:center}
.input{padding:8px;border-radius:6px;background:#0b0c0d;border:1px solid rgba(255,255,255,0.03);color:var(--muted);font-family:inherit}
.row{display:flex;gap:8px;align-items:center}
.footer{display:flex;justify-content:space-between;align-items:center;padding-top:8px}
.file-actions{display:flex;gap:8px}
/* File dropdown styles */
.toolbar .dropdown{position:relative}
.dropdown-menu{position:absolute;top:100%;left:0;background:var(--panel);border:1px solid rgba(255,255,255,0.06);border-radius:8px;padding:6px;display:none;min-width:200px;box-shadow:0 12px 30px rgba(0,0,0,0.6);z-index:1300}
.dropdown.open .dropdown-menu{display:block}
.dropdown-menu .btn{width:100%;justify-content:flex-start}
.badge{background:rgba(255,255,255,0.04);padding:6px 8px;border-radius:6px;color:var(--muted)}
.dialog{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:999}
.dialog.open{display:flex;touch-action:none}
.modal{width:920px;background:var(--panel);border-radius:8px;padding:8px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}
.modal{display:inline-flex;flex-direction:column;align-items:center;width:auto;max-width:calc(100vw - 40px);background:var(--panel);border-radius:8px;padding:8px;box-shadow:0 20px 60px rgba(0,0,0,0.7)}
.canvas-toolbar{display:flex;gap:8px;align-items:center;padding:8px}
.toolbtn{padding:6px;border-radius:6px;border:none;background:transparent;color:var(--muted);cursor:pointer; font-size: 20px; width:36px; height:36px; display:inline-flex; align-items:center; justify-content:center;}
.toolbtn:hover{background: rgba(217,250,0,0.08); color:#fff; box-shadow: 0 6px 16px rgba(217,250,0,0.08)}
.toolbtn:focus-visible{outline:none; box-shadow:0 0 0 2px rgba(217,250,0,0.55)}
.toolbtn.active{background:rgba(255,255,255,0.03);color:#fff}
.slider{width:150px}
.color-swatch{width:28px;height:28px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
.small-muted{font-size:12px;color:var(--muted)}
.icon-bx{width:24px;height:24px;display:inline-flex;align-items:center;justify-content:center;font-size:20px; color: var(--muted);}
.truncate{max-width:500px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
textarea.input{resize:both;min-height:44px;max-height:140px;min-width:120px}
.bx { vertical-align: middle; }
.small-edit{padding:4px 6px;font-size:12px;border-radius:6px}
/* Empty state inside the frames list */
.empty-state {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:10px;
  padding:18px;
  height:180px; /* adjust if you want larger */
  border-radius:8px;
  background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
  color: var(--muted);
}
.empty-state .big-btn {
  --cta1: #d9fa00;
  --cta2: #d9fa00;
  background: linear-gradient(135deg, var(--cta1), var(--cta2));
  color: #071017;
  border: 1px solid rgba(0,0,0,0.15);
  padding: 12px 20px;
  border-radius: 12px;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.2);
  width: 70%;
  max-width: 260px;
  transition: transform .2s ease, box-shadow .2s ease, filter .2s ease;
}
.empty-state .big-btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 14px 40px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.2);
}
.empty-state .big-btn:active {
  transform: translateY(0);
  filter: brightness(.98);
  box-shadow: 0 6px 18px rgba(0,0,0,0.45) inset, 0 6px 18px rgba(0,0,0,0.35);
}
.empty-state .big-btn:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px rgba(217,250,0,0.55), 0 10px 30px rgba(0,0,0,0.5);
}
.empty-state .small-line {
  font-size: 13px;
  color: var(--muted);
  text-align:center;
  max-width: 280px;
}
/* small canvas overlay text style - not required but keeps consistent look */
.guide-label {
  font-family: "Segoe UI", sans-serif;
  font-size: 12px;
  fill: #fff;
  pointer-events: none;
}
/* Guide panel styles */
.guide-panel {
  position: absolute;
  top: 56px; /* adjust if toolbar height differs */
  right: 24px; /* align under toolbar area (change as needed) */
  width: 680px;
  max-width: calc(100% - 40px);
  background: linear-gradient(180deg, rgba(20,20,20,0.98), rgba(16,16,16,0.96));
  border-radius: 10px;
  padding: 12px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  z-index: 1200;
  display: none;
  gap: 8px;
  color: var(--muted);
}

/* show state */
.guide-panel.open { display: block; }

/* panel contents */
.guide-row { display:flex; gap:12px; align-items:flex-start; }
.bx-icon { width:48px; height:48px; display:flex; align-items:center; justify-content:center; background:linear-gradient(90deg,var(--accent),var(--accent-2)); border-radius:8px; color:#071017; font-size:20px; }

/* make inputs compact in panel */
.guide-panel .input { padding:6px; font-size:13px; }
.guide-panel .small-edit { padding:6px 8px; font-size:13px; }

/* responsive: if narrow screen, panel becomes full width below toolbar */
@media (max-width: 900px) {
  .guide-panel { left:12px; right:12px; top:64px; width:auto; }
}
/* new: compact group for seconds+frames inputs */
.duration-group { display:flex; align-items:center; gap:6px; }
/* icon-only tiny button (for Edit) */
.icon-btn { padding:4px; width:28px; height:28px; border:none; background:transparent; color:var(--muted); border-radius:6px; display:inline-flex; align-items:center; justify-content:center; }
.icon-btn:hover { background:rgba(255,255,255,0.05); color:#fff; }
/* Confirm button accent style */
#confirmDraw {
  background: linear-gradient(90deg, var(--accent), var(--accent-2));
  color: #071017;
  border: none;
  font-weight: 700;
  box-shadow: 0 6px 20px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.25);
}
#confirmDraw:hover { filter: brightness(1.04); }
#confirmDraw:focus-visible { outline: none; box-shadow: 0 0 0 3px rgba(217,250,0,0.55), 0 6px 20px rgba(0,0,0,0.45); }

/* --- NEW: Animated hero logo + shining CTA + intro overlay --- */
.hero-logo{position:relative; width:68px; height:68px; border-radius:16px; background:linear-gradient(135deg, var(--accent), var(--accent-2)); box-shadow: 0 8px 24px rgba(217,250,0,0.2); display:flex; align-items:center; justify-content:center; color:#071017;}
.hero-logo i{font-size:32px;}
.hero-logo.lg{width:96px; height:96px; border-radius:20px;}

.big-animated{position:relative; animation: pulseGlow 3s ease-in-out infinite;}

@keyframes pulseGlow{0%,100%{box-shadow: 0 8px 24px rgba(217,250,0,0.25);}50%{box-shadow: 0 12px 32px rgba(217,250,0,0.4);}}

/* Intro overlay styles removed */

/* Draw wrapper responsive styles */
.draw-wrapper .canvas-toolbar {
  max-width: 100%;
}

.canvas-area canvas {
  max-width: 100%;
  height: auto;
}

/* Frame music button styling */
.frame-music-btn { 
  padding:4px; 
  width:28px; 
  height:28px; 
  border:none; 
  background:transparent; 
  color:var(--muted); 
  border-radius:6px; 
  display:inline-flex; 
  align-items:center; 
  justify-content:center; 
  cursor:pointer;
  transition: color 0.2s ease;
}
.frame-music-btn:hover { 
  background:rgba(255,255,255,0.05); 
  color:#fff; 
}
.frame-music-btn.has-music { 
  color: rgb(217, 255, 0); /* hijau kalau ada musik */
}
.frame-music-btn.has-music:hover { 
  color: #f55; /* merah kalau hover */
}

/* Improve input focus states within frames */
.frame input:focus {
  outline: none;
  background: rgba(255,255,255,0.08);
  border-color: rgba(217,250,0,0.3);
}

.frame.selected input:focus {
  background: rgba(255,255,255,0.12);
  border-color: rgba(217,250,0,0.5);
}

/* Submenu gaya Photoshop */
.submenu {
  position: relative;
}

.submenu-toggle {
  width: 100%;
  text-align: left;
}

.submenu-menu {
  position: absolute;
  top: 0;
  left: 100%;
  background: var(--panel);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 8px;
  padding: 6px;
  display: none;
  min-width: 200px;
  box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  z-index: 1400;
}

.submenu:hover .submenu-menu {
  display: block;
}

/* ---------- Frame list scrollable tanpa scrollbar (copy this) ---------- */
/* Pastikan ini ada di dalam tag <style> di storyboard.html */

/* Make sidebar column layout reliable */
.sidebar {
  display: flex;
  flex-direction: column;
  height: 100%; /* sekarang ikut .app yang fixed */
  background: var(--panel);
  border-radius: 10px;
  padding: 12px;
  gap: 10px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.6);
}

.list {
  flex: 1;
  overflow-y: auto;       /* biar bisa digulir */
  padding: 6px;
  background: linear-gradient(180deg,rgba(255,255,255,0.01),transparent);
  border-radius: 8px;

  /* sembunyikan scrollbar */
  scrollbar-width: none;  /* Firefox */
}
.list::-webkit-scrollbar { 
  display: none;          /* Chrome, Edge, Safari */
}

/* Area kanan (toolbar + preview + footer) tetap di tempat (stay) */
.side-right {
  /* agar sticky bekerja, parent harus punya tinggi (app punya height:100vh di filemu) */
  position: sticky;
  top: 0;
  align-self: start;  /* agar tidak mengisi baris vertikal fleksibel */
  display: flex;
  flex-direction: column;
  gap: 10px;
  background:var(--panel);border-radius:10px;padding:14px
}

/* optional: membuat konten kanan tidak ikut mengkerut */
.side-right > .canvas-stage,
.side-right > .toolbar,
.side-right > .footer {
  flex-shrink: 0;
}

/* (opsional) smoother scroll behavior */
.list {
  scroll-behavior: smooth;
}

/* -------- Responsive Enhancements (non-destructive) -------- */
.mobile-only { display: none; }

@media (max-width: 1600px) {
  .app { gap: 16px; padding: 16px; }
  .sidebar { width: 340px; }
  .canvas-stage { max-height: 68vh; }
}

@media (max-width: 1366px) {
  /* Ensure 100% zoom equivalent layout fits 1366p width */
  .app { gap: 12px; padding: 10px; }
  .sidebar { width: 280px; }
  .toolbar { flex-wrap: wrap; row-gap: 8px; overflow-x: auto; }
  .mode-toggle { min-width: 140px; }
  .canvas-stage { max-height: 66vh; }
  .truncate { max-width: 360px; }
}

@media (max-width: 1024px) {
  .app { flex-direction: column; gap: 12px; padding: 12px; height: auto; }
  .side-right { position: relative; top: 0; max-width: 100%; }
  .canvas-stage { max-height: 48vh; }
  .mobile-only { display: inline-flex; }

  /* Off-canvas sidebar */
  .sidebar {
    position: fixed;
    left: 0; top: 0; bottom: 0;
    width: min(92vw, 420px);
    max-width: 420px;
    height: 100vh;
    transform: translateX(-110%);
    transition: transform .25s ease;
    z-index: 1750;
    box-shadow: 0 20px 60px rgba(0,0,0,0.7);
  }
  body.sidebar-open .sidebar { transform: translateX(0); }

  .mobile-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    z-index: 1700;
    display: none;
  }
  body.sidebar-open .mobile-backdrop { display: block; }

  /* Mobile File dropdown: full-width fixed panel + vertical submenus */
  .toolbar .dropdown { position: static; }
  #fileDropdown .dropdown-menu {
    position: fixed;
    left: 0;
    right: 0;
    top: 56px; /* sit below top toolbar */
    width: 100vw;
    min-width: 0;
    border-radius: 0 0 12px 12px;
    padding: 10px;
    max-height: 70vh;
    overflow-y: auto;
    z-index: 2000; /* above sidebar backdrop */
  }
  /* stack submenu content vertically on mobile */
  #fileDropdown .submenu-menu {
    position: static;
    top: auto; left: auto;
    background: transparent;
    border: none;
    border-radius: 0;
    padding: 6px 0 0 0;
    margin: 4px 0 0 0;
    box-shadow: none;
    min-width: 0;
    display: none; /* shown via .submenu.open */
  }
  #fileDropdown .submenu.open .submenu-menu { display: block; }
  #fileDropdown .submenu .bx-chevron-right { transition: transform .2s ease; }
  #fileDropdown .submenu.open .bx-chevron-right { transform: rotate(90deg); }
  #fileDropdown .submenu:hover .submenu-menu { display: none !important; }
}

@media (max-width: 480px) {
  .btn { padding: 6px 8px; }
  .input { padding: 6px; }
  .mode-toggle { min-width: 120px; }
}
/* -------- End Responsive Enhancements -------- */


/* Mobile-specific dropdown layout fixes */
@media (max-width: 1024px) {
  .dropdown { position: static; }
  .dropdown-menu {
    position: fixed;
    left: 12px;
    right: 12px;
    top: 72px;
    min-width: unset;
    max-height: 60vh;
    overflow-y: auto;
    z-index: 1900;
    padding: 8px;
    border-radius: 12px;
  }
  /* Stack submenu content below parent on mobile */
  .submenu-menu {
    position: static;
    display: none;
    min-width: 100%;
    box-shadow: none;
    margin-top: 6px;
  }
  .submenu.open .submenu-menu { display: block; }
  .dropdown-menu .btn { padding: 10px 12px; }
}

/* Export loading modal */
.loading-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.55);display:none;align-items:center;justify-content:center;z-index:2200}
.loading-backdrop.open{display:flex}
.loading-card{background:var(--panel);border:1px solid rgba(255,255,255,0.06);border-radius:14px;padding:18px 22px;min-width:260px;box-shadow:0 20px 60px rgba(0,0,0,0.7);display:flex;gap:12px;align-items:center}
.loading-spinner{width:28px;height:28px;border-radius:50%;border:3px solid rgba(255,255,255,0.15);border-top-color:var(--accent);animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
.loading-text{display:flex;flex-direction:column}
.loading-title{font-weight:700}
.loading-sub{color:var(--muted);font-size:12px}

</style>
</head>
<body>
<div class="loading-backdrop" id="exportLoading">
  <div class="loading-card">
    <div class="loading-spinner"></div>
    <div class="loading-text">
      <div class="loading-title" id="exportLoadingTitle">Exporting...</div>
      <div class="loading-sub" id="exportLoadingSub">Please wait</div>
    </div>
  </div>
  </div>
<div class="app">
  <div class="sidebar">
    <div class="header">
      <div class="logo"><i class='bx bxs-story'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 268 343.18" width="15" height="15"><defs><style>.cls-1{fill:#000;}</style></defs><g id="Layer_2" data-name="Layer 2"><g id="Layer_2-2" data-name="Layer 2"><path class="cls-1" d="M256,119.65,200,73.56a32.13,32.13,0,0,0-15.48-12.74L115,3.53c-6.6-5.44-12-4.48-12,2.12v53H32a32,32,0,0,0-32,32v196a32,32,0,0,0,32,32H173a32.07,32.07,0,0,0,30.48-22.26L256,339.65c6.6,5.43,12,4.48,12-2.12v-196C268,134.93,262.6,125.08,256,119.65Zm-91,159H40v-180h63v103c0,6.6,5.4,16.44,12,21.88l50,41.18Z"/></g></g></svg>
      </i> LadaBoard</div>
      <div class="controls">
        <div class="mode-toggle" id="modeToggle">
          <span class="toggle-thumb" aria-hidden="true"></span>
          <button class="active" data-mode="draw">Draw</button>
          <button data-mode="upload">Upload</button>
        </div>
      </div>
    </div>

    <div class="row">

      <input id="projectTitle" class="input truncate" placeholder="Project title..." autocomplete="off" />
      <div class="badge" id="fpsBadge">24 FPS</div>
      
    </div>

    <div class="row">
      <button class="btn" id="addFrame"><i class='bx bx-plus'></i> New Frame</button>
      <button class="btn" id="duplicateFrame"><i class='bx bx-copy'></i> Duplicate</button>
      <button class="btn" id="removeFrame"><i class='bx bx-trash'></i> Delete</button>
    </div>

    <div class="list" id="framesList" ondragover="event.preventDefault()"></div>

    <div class="row"><div class="small-muted">Drag thumbnails to reorder</div></div>

    <!-- File actions moved into File dropdown in top toolbar -->
  </div>

  <div class="side-right">
    <div class="toolbar">
      <button class="btn mobile-only" id="openSidebar"><i class='bx bx-menu'></i> Frames</button>
      <!-- File dropdown placed to the left of FPS setting -->
      <div class="dropdown" id="fileDropdown">
        <button class="btn" id="fileMenuBtn"><i class='bx bx-file'></i> File</button>
        <div class="dropdown-menu" id="fileMenu">
          <button class="btn" id="saveProject"><i class='bx bx-save'></i> Save</button>
          <button class="btn" id="loadProject"><i class='bx bx-folder-open'></i> Load</button>

          <!-- Submenu Export Spread -->
          <div class="submenu">
            <button class="btn submenu-toggle">
              <i class='bx bx-spreadsheet'></i> Export Storyboard
              <i class='bx bx-chevron-right' style="margin-left:auto;"></i>
            </button>
            <div class="submenu-menu">
              <button class="btn" id="exportSpreadPng">PNG</button>
              <button class="btn" id="exportSpreadPdf">PDF</button>
            </div>
          </div>

          <!-- Submenu Export Video -->
          <div class="submenu">
            <button class="btn submenu-toggle">
              <i class='bx bx-film'></i> Export Video
              <i class='bx bx-chevron-right' style="margin-left:auto;"></i>
            </button>
            <div class="submenu-menu">
              <button class="btn" id="exportVideoMp4">MP4</button>
              <button class="btn" id="exportVideoWebm">WEBM</button>
            </div>
          </div>
        </div>
      </div>
      <div class="row"><label class="small-muted">FPS</label><input id="fpsInput" class="input" type="number" value="24" min="1" max="60" style="width:80px" autocomplete="off" /></div>
      <div class="row"><label class="small-muted">Default Duration</label><input id="defaultDuration" class="input" type="number" value="24" min="1" style="width:80px" autocomplete="off" /></div>
      <div style="margin-left:auto" class="row">
        <button class="btn" id="loopToggle" title="Loop"><i class='bx bx-repeat'></i> Loop</button>
        <button class="btn" id="restartPlay" title="Play from start"><i class='bx bx-rewind'></i> Restart</button>
        <button class="btn" id="playAll"><i class='bx bx-play'></i> Play</button>
      </div>
    </div>

    <div class="canvas-stage" id="stage">
      <canvas id="preview" width="1280" height="720"></canvas>
    </div>

    <div class="row">
      <div style="flex:1">
        <!-- changed to textarea so Shift+Enter can make newline -->
        <textarea id="descInput" class="input" placeholder="Description for selected frame" autocomplete="off"></textarea>
      </div>
      <div class="duration-group">
        <input id="durationSec" class="input" type="number" min="0" step="0.1" value="0" style="width:70px" autocomplete="off" />
        <span class="small-muted">s</span>
        <input id="durationFrm" class="input" type="number" min="0" step="1" style="width:56px" value="" autocomplete="off" />
        <span class="small-muted">f</span>
      </div>
    </div>

    <div class="footer">
      <div class="small-muted">Total Frames: <span id="totalFrames">0</span></div>
      <div class="small-muted">Project length: <span id="projectLength">0s</span></div>
    </div>
  </div>
</div>
<div class="mobile-backdrop" id="mobileBackdrop"></div>

<!-- Drawing modal -->
<div class="dialog" id="drawDialog">
  <div class="modal">
    <div class="draw-wrapper" style="display:inline-flex; flex-direction:column; align-items:center; gap:8px; width:auto;">
      <div class="canvas-toolbar" style="width:100%; display:flex; align-items:center; gap:8px;">
        <button data-tool="pen" class="toolbtn active" title="Pen"><i class='bx bx-pencil'></i></button>
        <button data-tool="eraser" class="toolbtn" title="Eraser"><i class='bx bx-eraser'></i></button>
        <button data-tool="rect" class="toolbtn" title="Rectangle"><i class='bx bx-rectangle'></i></button>
        <button data-tool="ellipse" class="toolbtn" title="Ellipse"><i class='bx bxs-circle'></i></button>
        <button data-tool="bucket" class="toolbtn" title="Paint Bucket"><i class='bx bxs-color-fill'></i></button>

        <div style="display:flex;align-items:center;gap:8px;margin-left:6px">
          <input type="color" id="colorPicker" value="#000000" style="margin-left:8px" />
          <input type="range" id="sizeRange" min="1" max="80" value="6" class="slider" />
        </div>

        <button class="toolbtn" id="undoBtn" title="Undo"><i class='bx bx-undo'></i></button>
        <button class="toolbtn" id="redoBtn" title="Redo"><i class='bx bx-redo'></i></button>
        <button class="toolbtn" id="clearBtn" title="Clear Canvas"><i class='bx bx-brush-alt'></i></button>
        <button id="addImageBtn" class="btn small-edit" title="Add Image"><i class='bx bx-image-add'></i></button>
        <button id="applyImageBtn" class="btn small-edit" title="Apply Image" style="display:none"><i class='bx bx-check'></i></button>


        <!-- Onion skin controls (paste di canvas-toolbar) -->
        <div style="display:flex;align-items:center;gap:8px;margin-left:auto">
          <button id="toggleOnion" class="btn" title="Toggle Onion Skin"><i class='bx bx-layer'></i></button>
        
          <div style="display:flex;align-items:center;gap:8px;padding-left:6px;">
            <label class="small-muted" title="Backward frames"><i class='bx bx-chevrons-left' style="vertical-align: middle;"></i></label>
            <input id="onionBackInput" class="input" type="number" value="2" min="0" max="10" style="width:50px" />
            
            <label class="small-muted" title="Forward frames"><i class='bx bx-chevrons-right' style="vertical-align: middle;"></i></label>
            <input id="onionFwdInput" class="input" type="number" value="2" min="0" max="10" style="width:50px" />
          </div>
        </div>
        <!-- Single Guide button (replace previous guide controls) -->
        <button id="guideBtn" class="btn" title="Open Guides"><i class='bx bx-grid-alt'></i> </button>

        <!-- floating panel that appears under toolbar -->
        <div id="guidePanel" class="guide-panel" aria-hidden="true">
          <div class="guide-row">
            <div class="bx-icon"><i class='bx bx-camera-movie'></i></div>
            <div style="flex:1">
              <div style="display:flex;gap:8px;align-items:center">
                <button id="toggleGuides" class="btn small-edit">Guides</button>
                <button id="toggleRulers" class="btn small-edit">Rulers</button>

                <label class="small-muted" style="margin-left:6px">Aspect</label>
                <select id="guideAspect" class="input" style="width:120px;">
                  <option value="1920x1080">16:9 (1920×1080)</option>
                  <option value="1280x720">16:9 (1280×720)</option>
                  <option value="1024x768">4:3 (1024×768)</option>
                </select>
              </div>

              <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
                <label class="small-muted">Title</label>
                <input id="titleSafePct" class="input" type="number" min="50" max="100" value="90" style="width:64px" />%
                <label class="small-muted" style="margin-left:8px">Action</label>
                <input id="actionSafePct" class="input" type="number" min="50" max="100" value="95" style="width:64px" />%
                <div style="margin-left:auto;display:flex;gap:6px">
                  <button id="closeGuidePanel" class="btn small-edit">Close</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="canvas-area" style="position:relative; display:inline-block;">
        <canvas id="drawCanvas" width="1024" height="576" style="background:#fff; border-radius:6px;"></canvas>
        <canvas id="onionCanvas" width="1024" height="576" style="position:absolute; left:0; top:0; background:transparent; pointer-events:none;"></canvas>
        
        <canvas id="guideCanvas" width="1024" height="576" style="position:absolute; left:0; top:0; background:transparent; pointer-events:none;"></canvas>
        <canvas id="insertCanvas" width="1024" height="576" style="position:absolute; left:0; top:0; background:transparent; pointer-events:none;"></canvas>
      </div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;padding:8px">
      <button class="btn" id="cancelDraw"><i class='bx bx-x'></i> Cancel</button>
      <button class="btn" id="confirmDraw"><i class='bx bx-check'></i> Confirm</button>
    </div>
  </div>
</div>

<input type="file" id="uploader" accept="image/*" style="display:none" multiple />
<input type="file" id="insertImageInput" accept="image/*" style="display:none" />
<input type="file" id="loadProjectInput" accept="application/json" style="display:none" />

<!-- INTRO OVERLAY -->
<!-- Removed intro overlay popup -->

<!-- ---------- Frame cache & preload helpers ----------
let frameCache = []; // parallel array, same length as state.frames. Each entry: { bmp: ImageBitmap|HTMLImageElement, src: original src }

concurrency control
const PRELOAD_CONCURRENCY = 6; // tweak: 4..12 depending memory/network
const PRELOAD_BATCH_SIZE = PRELOAD_CONCURRENCY;

function isDataUrl(s) { return typeof s === 'string' && s.startsWith('data:'); }

async function createBitmapFromSrc(src) {
  try {
    if (window.createImageBitmap) {
      const res = await fetch(src);
      const blob = await res.blob();
      const bmp = await createImageBitmap(blob);
      return bmp;
    } else {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    }
  } catch (err) {
    try {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    } catch(e){
      console.warn('createBitmapFromSrc failed for', src, e);
      return null;
    }
  }
}

async function preloadFramesWithProgress(frames, onProgress = ()=>{}) {
  const n = frames.length;
  frameCache = new Array(n).fill(null);

  function getSrc(f) {
    if (!f) return null;
    return f.thumb || f.src || null;
  }

  const tasks = frames.map((f, idx) => async () => {
    const src = getSrc(f);
    if (!src) { frameCache[idx] = null; onProgress(idx+1, n); return; }
    try {
      const bmpOrImg = await createBitmapFromSrc(src);
      frameCache[idx] = { bmp: bmpOrImg, src };
      onProgress(idx+1, n);
    } catch (err) {
      console.warn('preload failed', idx, err);
      frameCache[idx] = null;
      onProgress(idx+1, n);
    }
  });

  let i = 0;
  const runners = new Array(Math.min(PRELOAD_BATCH_SIZE, tasks.length)).fill(0).map(async () => {
    while (i < tasks.length) {
      const task = tasks[i++];
      await task();
    }
  });

  await Promise.all(runners);
  return frameCache;
}

// optional small progress overlay
function showPreloadOverlay(text) {
  let el = document.getElementById('preloadOverlay');
  if (!el) {
    el = document.createElement('div');
    el.id = 'preloadOverlay';
    Object.assign(el.style, {
      position: 'fixed', left: '12px', bottom: '12px', padding: '8px 12px',
      background: 'rgba(0,0,0,0.7)', color: '#fff', borderRadius: '8px', zIndex: 2000,
      fontSize: '13px'
    });
    document.body.appendChild(el);
  }
  el.textContent = text;
  el.style.display = 'block';
}
function hidePreloadOverlay() {
  const el = document.getElementById('preloadOverlay');
  if (el) el.style.display = 'none';
}

let _cacheUpdatePending = null;
function scheduleUpdateFrameCache(debounceMs = 200) {
  if (_cacheUpdatePending) clearTimeout(_cacheUpdatePending);
  _cacheUpdatePending = setTimeout(() => {
    _cacheUpdatePending = null;
    updateFrameCache();
  }, debounceMs);
}

async function updateFrameCache() {
  if (!state.frames || state.frames.length === 0) {
    frameCache = [];
    return;
  }
  try {
    showPreloadOverlay('Preloading frames... 0/' + state.frames.length);
    await preloadFramesWithProgress(state.frames, (done, total) => {
      showPreloadOverlay(`Preloading frames... ${done}/${total}`);
    });
  } catch (err) {
    console.warn('updateFrameCache error', err);
  } finally {
    hidePreloadOverlay();
  }
}
// ---------- End of Frame cache & preload helpers ---------- -->

<script>
// LadaBoard Planner — improved eraser & edit behavior
const state = { frames: [], selected: -1, fps: 24, defaultDuration: 24, mode: 'draw' };
let editIndex = null; // Used for the drawing modal
let selectedFrames = new Set();
let clipboardFrames = [];

// Variabel global untuk musik
let musicAudio = null;
let currentMusicUrl = null;

const framesList = document.getElementById('framesList');
const preview = document.getElementById('preview'); const pctx = preview.getContext('2d');
const fpsInput = document.getElementById('fpsInput'); const fpsBadge = document.getElementById('fpsBadge');
const defaultDurationInput = document.getElementById('defaultDuration');
const totalFramesEl = document.getElementById('totalFrames'); const projectLength = document.getElementById('projectLength');
const descInput = document.getElementById('descInput'); const durationSecInput = document.getElementById('durationSec'); const durationFrmInput = document.getElementById('durationFrm');

// wiring for File dropdown
const fileDropdownEl = document.getElementById('fileDropdown');
const fileMenuBtn = document.getElementById('fileMenuBtn');
const fileMenu = document.getElementById('fileMenu');

// ensure export submenu works on mobile
(function fixExportSubmenuMobile(){
  const isMobile = () => window.innerWidth <= 1024;
  const roots = document.querySelectorAll('#fileMenu .submenu');
  roots.forEach(root=>{
    const toggle = root.querySelector('.submenu-toggle');
    toggle?.addEventListener('click',(e)=>{
      if (!isMobile()) return;
      e.preventDefault(); e.stopPropagation();
      roots.forEach(r=>{ if(r!==root) r.classList.remove('open'); });
      root.classList.toggle('open');
    });
  });
})();
function closeAllSubmenus(){
  try {
    if (!fileDropdownEl) return;
    fileDropdownEl.querySelectorAll('.submenu.open').forEach((el)=> el.classList.remove('open'));
  } catch(_){}
}
function closeFileDropdown(){
  try {
    if (!fileDropdownEl) return;
    fileDropdownEl.classList.remove('open');
    closeAllSubmenus();
  } catch(_){}
}
if (fileMenuBtn) {
  fileMenuBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    const willOpen = !fileDropdownEl.classList.contains('open');
    if (willOpen) {
      fileDropdownEl.classList.add('open');
    } else {
      closeFileDropdown();
    }
  });
  // prevent accidental close when interacting inside the menu
  if (fileMenu) {
    ['click','touchstart'].forEach((evt)=>{
      fileMenu.addEventListener(evt, (ev)=> ev.stopPropagation(), { passive: false });
    });
  }
  // close on outside interaction / escape
  ['click','touchstart'].forEach((evt)=>{
    document.addEventListener(evt, ()=> closeFileDropdown(), { passive: true });
  });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeFileDropdown(); });

  // toggle submenus on tap for mobile, and close others when opening one
  const submenuToggles = fileDropdownEl.querySelectorAll('.submenu-toggle');
  submenuToggles.forEach((toggle)=>{
    toggle.addEventListener('click', (e)=>{
      const isMobile = window.innerWidth <= 1024;
      if (!isMobile) return; // keep hover behavior on desktop
      e.preventDefault();
      e.stopPropagation();
      const parent = toggle.closest('.submenu');
      const willOpen = !parent.classList.contains('open');
      // close others
      fileDropdownEl.querySelectorAll('.submenu.open').forEach((el)=>{ if (el !== parent) el.classList.remove('open'); });
      if (willOpen) { parent.classList.add('open'); } else { parent.classList.remove('open'); }
    }, { passive: false });
  });

  // reset submenu state when switching back to desktop
  window.addEventListener('resize', ()=>{ if (window.innerWidth > 1024) closeAllSubmenus(); });
}

// Mobile submenu toggle handling
(function setupMobileSubmenu(){
  const isMobile = () => window.innerWidth <= 1024;
  const submenuRoots = document.querySelectorAll('#fileMenu .submenu');
  submenuRoots.forEach(root => {
    const toggleBtn = root.querySelector('.submenu-toggle');
    if (!toggleBtn) return;
    toggleBtn.addEventListener('click', (ev) => {
      // On mobile, toggle inline submenu instead of hover
      if (isMobile()) {
        ev.preventDefault();
        ev.stopPropagation();
        root.classList.toggle('open');
      }
    });
  });

  // Prevent dropdown from closing when clicking inside menu on mobile
  const fileMenu = document.getElementById('fileMenu');
  if (fileMenu) {
    fileMenu.addEventListener('click', (ev) => {
      if (isMobile()) ev.stopPropagation();
    });
  }

  // Close submenus when dropdown itself closes
  document.addEventListener('click', () => {
    if (!isMobile()) return;
    document.querySelectorAll('#fileMenu .submenu.open').forEach(el => el.classList.remove('open'));
  });

  // Also close on Escape
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      document.querySelectorAll('#fileMenu .submenu.open').forEach(el => el.classList.remove('open'));
    }
  });
})();

// drawing modal elements
const drawDialog = document.getElementById('drawDialog'); 
const drawCanvas = document.getElementById('drawCanvas'); 
const dctx = drawCanvas.getContext('2d');
const onionCanvas = document.getElementById('onionCanvas');
const octx = onionCanvas.getContext('2d');

// TAMBAHKAN DUA BARIS DI BAWAH INI
const guideCanvas = document.getElementById('guideCanvas');
const gctx = guideCanvas.getContext('2d');
const insertCanvas = document.getElementById('insertCanvas');
const ictx = insertCanvas.getContext('2d');

// Main drawing canvas - everything will be drawn here as bitmap
let drawingHistory = []; // Array of canvas states for undo/redo
let currentHistoryIndex = -1;
let maxHistorySize = 50; // Limit history size to prevent memory issues

// Initialize drawing canvas
function initDrawingCanvas() {
  // Clear any existing history
  drawingHistory = [];
  currentHistoryIndex = -1;
  
  // Save initial blank state
  saveCanvasState();
}

function saveCanvasState() {
  // Create a copy of current canvas state
  const imageData = dctx.getImageData(0, 0, drawCanvas.width, drawCanvas.height);
  
  // Remove any future states if we're not at the end
  if (currentHistoryIndex < drawingHistory.length - 1) {
    drawingHistory = drawingHistory.slice(0, currentHistoryIndex + 1);
  }
  
  // Add new state
  drawingHistory.push(imageData);
  currentHistoryIndex++;
  
  // Limit history size
  if (drawingHistory.length > maxHistorySize) {
    drawingHistory.shift();
    currentHistoryIndex--;
  }
  
  // Update undo/redo button states
  updateUndoRedoButtons();
}

function restoreCanvasState(index) {
  if (index < 0 || index >= drawingHistory.length) return;
  
  const imageData = drawingHistory[index];
  dctx.putImageData(imageData, 0, 0);
  currentHistoryIndex = index;
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  
  if (undoBtn) undoBtn.disabled = currentHistoryIndex <= 0;
  if (redoBtn) redoBtn.disabled = currentHistoryIndex >= drawingHistory.length - 1;
}

function undo() {
  if (currentHistoryIndex > 0) {
    restoreCanvasState(currentHistoryIndex - 1);
  }
}

function redo() {
  if (currentHistoryIndex < drawingHistory.length - 1) {
    restoreCanvasState(currentHistoryIndex + 1);
  }
}

function clearCanvas() {
  dctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
  dctx.fillStyle = '#fff';
  dctx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
  saveCanvasState();
}

// Remove old brush layer system - everything will be drawn directly on main canvas
let lastBrushPoint = null;
let brushSize = 8; // default size
let brushColor = '#000000';

// Remove old brush layer functions
// function initBrushLayer() { ... }
// function clearBrushLayer() { ... }
// function drawBrushDot() { ... }
// function drawBrushStroke() { ... }

// New bitmap-based drawing functions
function drawBrushDot(p, pressure) {
  const r = (brushSize * (pressure > 0 ? pressure : 0.5)) / 2;
  dctx.save();
  dctx.globalCompositeOperation = 'source-over';
  dctx.fillStyle = brushColor;
  dctx.beginPath();
  dctx.arc(p.x, p.y, Math.max(0.5, r), 0, Math.PI * 2);
  dctx.fill();
  dctx.restore();
}

function drawBrushStroke(p1, p2, pressure) {
  const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
  const steps = Math.max(1, Math.ceil(dist / 0.5));
  for (let i = 0; i < steps; i++) {
    const t = i / steps;
    const x = p1.x + (p2.x - p1.x) * t;
    const y = p1.y + (p2.y - p1.y) * t;
    drawBrushDot({ x, y }, pressure);
  }
}

// New eraser function for bitmap-based erasing
function drawEraserStroke(p1, p2) {
  dctx.save();
  dctx.globalCompositeOperation = 'destination-out';
  dctx.lineWidth = size;
  dctx.lineCap = 'round';
  dctx.lineJoin = 'round';
  dctx.beginPath();
  dctx.moveTo(p1.x, p1.y);
  dctx.lineTo(p2.x, p2.y);
  dctx.stroke();
  dctx.restore();
}

// ===== Compact Guide panel logic =====
const guideBtn = document.getElementById('guideBtn');
const guidePanel = document.getElementById('guidePanel');
const closeGuidePanel = document.getElementById('closeGuidePanel');

// single shared guides state (keperluan drawGuides function)
const guidesState = window.guidesState || {
  enabled: true,
  rulers: true,
  artW: 1920, artH: 1080,
  titleSafePct: 90,
  actionSafePct: 95
};
// expose globally if not already
window.guidesState = guidesState;

// wire UI elements
const tgl = document.getElementById('toggleGuides');
const tr = document.getElementById('toggleRulers');
const aspect = document.getElementById('guideAspect');
const titleInp = document.getElementById('titleSafePct');
const actionInp = document.getElementById('actionSafePct');

function applyGuideUI() {
  if (!tgl || !tr || !aspect || !titleInp || !actionInp) return;
  tgl.style.borderColor = guidesState.enabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  tr.style.borderColor = guidesState.rulers ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  // set aspect select to current artW/artH
  aspect.value = `${guidesState.artW}x${guidesState.artH}`;
  titleInp.value = Math.round(guidesState.titleSafePct);
  actionInp.value = Math.round(guidesState.actionSafePct);
}

// toggle panel visibility
function openGuidePanel() {
  guidePanel.classList.add('open');
  guidePanel.setAttribute('aria-hidden', 'false');
  applyGuideUI();
}
function closeGuidePanelFn() {
  guidePanel.classList.remove('open');
  guidePanel.setAttribute('aria-hidden', 'true');
}

// attach events
if (guideBtn) {
  guideBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (guidePanel.classList.contains('open')) closeGuidePanelFn(); else openGuidePanel();
  });
}
// close button
if (closeGuidePanel) closeGuidePanel.addEventListener('click', () => closeGuidePanelFn());

// click outside to close panel
document.addEventListener('click', (e) => {
  if (!guidePanel) return;
  if (!guidePanel.classList.contains('open')) return;
  if (guidePanel.contains(e.target) || guideBtn.contains(e.target)) return;
  closeGuidePanelFn();
});

// wire controls inside panel to guidesState and re-render
if (tgl) tgl.addEventListener('click', ()=>{ guidesState.enabled = !guidesState.enabled; applyGuideUI(); try { redrawPaths(); drawPreview(); } catch(e){} });
if (tr) tr.addEventListener('click', ()=>{ guidesState.rulers = !guidesState.rulers; applyGuideUI(); try { redrawPaths(); drawPreview(); } catch(e){} });
if (aspect) aspect.addEventListener('change', ()=>{
  const v = (aspect.value || '1920x1080').split('x');
  guidesState.artW = Number(v[0]) || 1920; guidesState.artH = Number(v[1]) || 1080;
  try { redrawPaths(); drawPreview(); } catch(e) {}
});
if (titleInp) titleInp.addEventListener('change', ()=>{ guidesState.titleSafePct = Math.max(50, Math.min(100, Number(titleInp.value)||90)); try { redrawPaths(); drawPreview(); } catch(e){} });
if (actionInp) actionInp.addEventListener('change', ()=>{ guidesState.actionSafePct = Math.max(50, Math.min(100, Number(actionInp.value)||95)); try { redrawPaths(); drawPreview(); } catch(e){} });

// ensure UI initial state
applyGuideUI();

// If you already implemented drawGuides(ctx, w, h) earlier, it will use window.guidesState.
// If not, include the drawGuides() implementation provided previously (the function that draws artboard, safe areas and rulers).

// drawGuides: draws artboard box, safe areas and rulers on given ctx & canvas size
function drawGuides(ctx, canvasW, canvasH) {
  if(!guidesState.enabled) return;

  const artW = guidesState.artW, artH = guidesState.artH;
  // compute scale to fit artboard inside canvas (cover both drawCanvas & preview)
  const scale = Math.min(canvasW / artW, canvasH / artH);
  const aw = Math.round(artW * scale), ah = Math.round(artH * scale);
  const ox = Math.round((canvasW - aw) / 2), oy = Math.round((canvasH - ah) / 2);

  ctx.save();

  // Hapus outer artboard border dan center lines - tidak diperlukan lagi
  
  // safe areas
  const titlePadX = aw * ((100 - guidesState.titleSafePct) / 200); // symmetric inset
  const titlePadY = ah * ((100 - guidesState.titleSafePct) / 200);
  const actionPadX = aw * ((100 - guidesState.actionSafePct) / 200);
  const actionPadY = ah * ((100 - guidesState.actionSafePct) / 200);

  // action safe (outer)
  ctx.strokeStyle = 'rgba(90,200,180,0.95)'; // teal
  ctx.lineWidth = 2;
  ctx.setLineDash([6,4]);
  ctx.strokeRect(ox + actionPadX + 0.5, oy + actionPadY + 0.5, aw - actionPadX*2 -1, ah - actionPadY*2 -1);

  // title safe (inner)
  ctx.strokeStyle = 'rgba(240,200,80,0.95)'; // yellow
  ctx.lineWidth = 2;
  ctx.setLineDash([4,2]);
  ctx.strokeRect(ox + titlePadX + 0.5, oy + titlePadY + 0.5, aw - titlePadX*2 -1, ah - titlePadY*2 -1);

  // small labels for safe boxes
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(240,200,80,0.95)';
  ctx.font = '12px "Segoe UI", sans-serif';
  ctx.fillText('Title Safe ' + guidesState.titleSafePct + '%', ox + titlePadX + 8, oy + titlePadY + 14);
  ctx.fillStyle = 'rgba(90,200,180,0.95)';
  ctx.fillText('Action Safe ' + guidesState.actionSafePct + '%', ox + actionPadX + 8, oy + actionPadY + 14);

  // Hapus seluruh bagian rulers - tidak diperlukan lagi

  ctx.restore();
}

// ========== Onion Skin Feature ==========
// state variables (add near other drawing vars)
let onionEnabled = JSON.parse(localStorage.getItem('ladaboard.onionEnabled') || 'true');
let onionBackCount = 2;
let onionFwdCount = 2;

// helper to clamp
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// attach UI listeners (run once after DOM ready)
(function initOnionUI(){
  const toggle = document.getElementById('toggleOnion');
  const backInput = document.getElementById('onionBackInput');
  const fwdInput = document.getElementById('onionFwdInput');

  if(!toggle || !backInput || !fwdInput) return; // safe exit if UI not present

  function updateUI(){
    toggle.style.borderColor = onionEnabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
    backInput.value = String(onionBackCount);
    fwdInput.value = String(onionFwdCount);
    // redraw edit canvas if open
    if(drawDialog.classList.contains('open')) redrawPaths();
  }

  toggle.addEventListener('click', ()=>{ 
    onionEnabled = !onionEnabled;
    localStorage.setItem('ladaboard.onionEnabled', onionEnabled); // Save state
    updateUI();
  });
  backInput.addEventListener('change', ()=>{ onionBackCount = clamp(Number(backInput.value), 0, 10); updateUI(); });
  fwdInput.addEventListener('change', ()=>{ onionFwdCount = clamp(Number(fwdInput.value), 0, 10); updateUI(); });
  updateUI();
})();

// draw single thumbnail image to ctx using existing drawImageCover util
function drawThumbInto(ctx, img, alpha, tint) {
  if(!img) return;
  ctx.save();
  ctx.globalAlpha = alpha;
  // draw image cover to full canvas
  try { drawImageCover(ctx, img, drawCanvas.width, drawCanvas.height); } catch(e){}
  if(tint){
    // simple tint overlay
    ctx.fillStyle = tint;
    ctx.globalCompositeOperation = 'source-atop';
    ctx.fillRect(0,0,drawCanvas.width,drawCanvas.height);
  }
  ctx.restore();
}

// ensure Image object for a frame (cache it on frame._img)
function ensureFrameImage(frame){
  if(!frame) return null;
  if(frame._img && frame._img.src === frame.thumb) return frame._img;
  if(!frame.thumb) return null;
  const im = new Image();
  im.src = frame.thumb;
  // when loaded, request a redraw of the draw canvas if it's open
  im.onload = ()=>{ if(drawDialog.classList.contains('open')) redrawPaths(); };
  frame._img = im;
  return im;
}

// main onion rendering — draws backward (older) and forward frames
// PERHATIAN: Fungsi ini hanya boleh dipanggil dalam mode edit/draw
// Jangan panggil di drawPreview() atau confirmDraw() untuk menghindari onion skin tersimpan ke bitmap final
function renderOnionSkins(ctx, refIndex){
  if(!onionEnabled) return;
  if(typeof refIndex !== 'number' || refIndex < 0) return;

  // backward frames: tint reddish/orange
  for(let i = 1; i <= onionBackCount; i++){
    const idx = refIndex - i;
    if(idx < 0 || !state.frames[idx]) continue;
    const f = state.frames[idx];
    const img = ensureFrameImage(f);
    const alpha = 0.45 * (1 - (i-1) / Math.max(1, onionBackCount)); // nearer = stronger
    drawThumbInto(ctx, img, alpha, 'rgba(255,120,90,0.18)'); // warm tint
  }

  // forward frames: tint green/cyan
  for(let i = 1; i <= onionFwdCount; i++){
    const idx = refIndex + i;
    if(idx >= state.frames.length || !state.frames[idx]) continue;
    const f = state.frames[idx];
    const img = ensureFrameImage(f);
    const alpha = 0.45 * (1 - (i-1) / Math.max(1, onionFwdCount));
    drawThumbInto(ctx, img, alpha, 'rgba(110,230,200,0.16)'); // cool tint
  }
}

// Fungsi baru untuk render onion skin ke overlay canvas terpisah
// Fungsi ini memastikan onion skin tidak tercampur dengan gambar utama
function renderOnionSkinsOverlay(refIndex) {
  octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
  if (!onionEnabled) return;
  if (typeof refIndex !== 'number' || refIndex < 0) return;

  // backward frames: tint reddish/orange
  for(let i = 1; i <= onionBackCount; i++){
    const idx = refIndex - i;
    if(idx < 0 || !state.frames[idx]) continue;
    const f = state.frames[idx];
    const img = ensureFrameImage(f);
    const alpha = 0.45 * (1 - (i-1) / Math.max(1, onionBackCount)); // nearer = stronger
    drawThumbInto(octx, img, alpha, 'rgba(255,120,90,0.18)'); // warm tint
  }

  // forward frames: tint green/cyan
  for(let i = 1; i <= onionFwdCount; i++){
    const idx = refIndex + i;
    if(idx >= state.frames.length || !state.frames[idx]) continue;
    const f = state.frames[idx];
    const img = ensureFrameImage(f);
    const alpha = 0.45 * (1 - (i-1) / Math.max(1, onionFwdCount));
    drawThumbInto(octx, img, alpha, 'rgba(110,230,200,0.16)'); // cool tint
  }
}
let tool='pen', color='#000', size=6, drawing=false;
let baseImage = null; // Image object for background when editing an existing frame
let eraserMode = 'stroke'; // legacy, eraser mode toggle removed

// utilities
function createFrame(img=null){ return { thumb: img || null, desc: '', duration: Number(state.defaultDuration) || 24, music: null }; }
function safeNumber(v, fallback=0){ const n = Number(v); return Number.isFinite(n) ? n : fallback; }
function safeString(v){ return (typeof v === 'string') ? v : (v==null?'':String(v)); }
function normalizeFrames(arr){ if(!Array.isArray(arr)) return []; return arr.map(it => { if(!it) return createFrame(null); if(typeof it === 'string') return createFrame(it); return { thumb: it.thumb || null, desc: safeString(it.desc), duration: Math.max(1, safeNumber(it.duration, state.defaultDuration)), music: it.music || null }; }); }
function ellipsize(s, len){ if(!s) return ''; const st=String(s); return st.length>len?st.slice(0,len-1)+'…':st; }
function sanitizeFilename(s){ return String(s||'').replace(/[<>:"/\\|?*]+/g,'').slice(0,120); }
function pad2(n){ return String(n).padStart(2,'0'); }

// --- New helper: word-wrapping for canvas text ---
function wrapText(ctx, text, maxWidth) {
  const words = String(text || '').split(/\s+/);
  const lines = [];
  let currentLine = '';
  
  // Variabel baru untuk melacak lebar maksimum yang terukur
  let measuredMaxWidth = 0;

  for (let word of words) {
    const testLine = currentLine ? currentLine + ' ' + word : word;
    const metrics = ctx.measureText(testLine);
    
    if (metrics.width > maxWidth && currentLine !== '') {
      lines.push(currentLine);
      // Perbarui lebar maksimal dengan lebar baris saat ini
      measuredMaxWidth = Math.max(measuredMaxWidth, ctx.measureText(currentLine).width);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  
  if (currentLine) {
    lines.push(currentLine);
    // Perbarui lebar maksimal untuk baris terakhir
    measuredMaxWidth = Math.max(measuredMaxWidth, ctx.measureText(currentLine).width);
  }

  // Kembalikan objek yang berisi 'lines' dan 'maxWidth' yang sudah dihitung
  return { lines, maxWidth: measuredMaxWidth };
}

// --- Helper for creating bitmap from source ---
async function createBitmapFromSrc(src) {
  try {
    if (window.createImageBitmap) {
      const res = await fetch(src);
      const blob = await res.blob();
      const bmp = await createImageBitmap(blob);
      return bmp;
      } else {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    }
  } catch (err) {
    try {
      const img = new Image();
      img.src = src;
      await img.decode();
      return img;
    } catch(e){
      console.warn('createBitmapFromSrc failed for', src, e);
      return null;
    }
  }
}

// --- Generator halaman A4 Jepang 100% ---
async function generateStoryboardPages() {
  const dpi = 300;
  const mmToPx = mm => Math.round(mm * dpi / 25.4);
  const pageW = mmToPx(210); // 2480 px
  const pageH = mmToPx(297); // 3508 px

  const perPage = 5;
  const thumbW = mmToPx(90);
  const thumbH = mmToPx(50.6);
  const marginX = mmToPx(10);
  const startY = mmToPx(25);
  const rowH = mmToPx(55);

  const canvases = [];

  for (let p = 0; p < Math.ceil(state.frames.length / perPage); p++) {
    const c = document.createElement('canvas');
    c.width = pageW;
    c.height = pageH;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, pageW, pageH);

    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;

    // Kolom: CUT, 画面, 動き, セリフ・音, 秒
    const colCut = mmToPx(15);
    const colImg = thumbW + mmToPx(5);
    const colAction = mmToPx(50);
    const colDialogue = mmToPx(50);
    const colSec = mmToPx(15);
    const colX = [
      marginX,
      marginX + colCut,
      marginX + colCut + colImg,
      marginX + colCut + colImg + colAction,
      marginX + colCut + colImg + colAction + colDialogue,
      pageW - marginX
    ];

    // Garis vertikal
    for (let x of colX) {
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, startY + perPage * rowH);
      ctx.stroke();
    }

    // Garis horizontal
    for (let r = 0; r <= perPage; r++) {
      const y = startY + r * rowH;
      ctx.beginPath();
      ctx.moveTo(marginX, y);
      ctx.lineTo(pageW - marginX, y);
      ctx.stroke();
    }

    // Label kolom (Jepang saja)
    ctx.font = `${mmToPx(4)}px sans-serif`;
    ctx.fillStyle = '#000';
    ctx.fillText('カット', colX[0] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('画面', colX[1] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('動き', colX[2] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('セリフ・音', colX[3] + mmToPx(2), startY - mmToPx(2));
    ctx.fillText('秒', colX[4] + mmToPx(2), startY - mmToPx(2));

    // Isi baris
    for (let r = 0; r < perPage; r++) {
      const idx = p * perPage + r;
      if (idx >= state.frames.length) break;
      const f = state.frames[idx];
      const y = startY + r * rowH;

      // Cut number
      ctx.font = `${mmToPx(4.5)}px sans-serif`;
      ctx.fillText(String(idx + 1).padStart(2, '0'), colX[0] + mmToPx(2), y + mmToPx(5));

      // Frame image + grid merah
      ctx.strokeStyle = '#000';
      ctx.strokeRect(colX[1] + mmToPx(1), y + mmToPx(1), thumbW, thumbH);
      ctx.strokeStyle = 'rgba(255,0,0,0.5)';
      ctx.lineWidth = 1;
      for (let gx = 1; gx < 3; gx++) {
        ctx.beginPath();
        ctx.moveTo(colX[1] + mmToPx(1) + (thumbW / 3) * gx, y + mmToPx(1));
        ctx.lineTo(colX[1] + mmToPx(1) + (thumbW / 3) * gx, y + mmToPx(1) + thumbH);
        ctx.stroke();
      }
      for (let gy = 1; gy < 3; gy++) {
        ctx.beginPath();
        ctx.moveTo(colX[1] + mmToPx(1), y + mmToPx(1) + (thumbH / 3) * gy);
        ctx.lineTo(colX[1] + mmToPx(1) + thumbW, y + mmToPx(1) + (thumbH / 3) * gy);
        ctx.stroke();
      }
      if (f.thumb) {
        const img = await createBitmapFromSrc(f.thumb);
        ctx.drawImage(img, colX[1] + mmToPx(1), y + mmToPx(1), thumbW, thumbH);
      }

      // 動き
      ctx.fillStyle = '#000';
      ctx.font = `${mmToPx(3.5)}px sans-serif`;
      wrapText(ctx, f.desc || '', colAction - mmToPx(4)).lines.forEach((line, li) => {
        ctx.fillText(line, colX[2] + mmToPx(2), y + mmToPx(4) + li * mmToPx(4));
      });

      // セリフ・音
      if (f.music) {
        const name = f.music.split('/').pop().split('?')[0];
        wrapText(ctx, `BGM: ${name} (00:00)`, colDialogue - mmToPx(4)).lines.forEach((line, li) => {
          ctx.fillText(line, colX[3] + mmToPx(2), y + mmToPx(4) + li * mmToPx(4));
        });
      }

      // 秒
      const secs = splitDurationFrames(f.duration, state.fps).sec;
      ctx.font = `${mmToPx(4)}px sans-serif`;
      ctx.fillText(`${secs}`, colX[4] + mmToPx(2), y + mmToPx(5));
    }

    canvases.push(c);
  }
  return canvases;
}

// list rendering (edit button only for selected frame and smaller)
function renderList(){ 
  framesList.innerHTML=''; 
  state.frames = normalizeFrames(state.frames); 

  // Empty state: jika belum ada frame sama sekali
  if (!state.frames || state.frames.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'empty-state';
    empty.innerHTML = `
      <div class="small-line">No frames yet</div>
      <button class="big-btn big-animated" id="createFirstFrame"><i class='bx bx-plus'></i> Create New Frame</button>
      <div class="small-line">Click to draw a new frame or upload an image</div>
    `;
    framesList.appendChild(empty);

    // sambungkan tombol besar ke tombol addFrame (pakai existing behavior)
    const createBtn = document.getElementById('createFirstFrame');
    if (createBtn) {
      createBtn.addEventListener('click', () => {
        // trigger the same action as the existing +New Frame button
        document.getElementById('addFrame').click();
      });
    }

    updateProjectInfo(); 
    highlightSelected();
    return;
  }

  // jika ada frames -> rendering normal (lanjutkan dengan kode semula)
  state.frames.forEach((f,i)=>{
    const el=document.createElement('div'); el.className='frame'; el.draggable=true; el.dataset.index=i;
    const thumbHTML = f.thumb 
    ? `<img src="${f.thumb}" style="width:100%;height:100%;object-fit:cover"/>` 
    : 'Empty';

    const showEdit = (i === state.selected);
    el.innerHTML = `
    <div class="thumb">${thumbHTML}</div>
    <div class="meta">
      <input class="frame-title truncate" type="text" value="${escapeHtml(f.desc)}" placeholder="Desc" autocomplete="off" />
      ${showEdit?`<div style="display:flex;gap:4px;margin-top:4px">
        <button class="icon-btn edit-frame" title="Edit"><i class='bx bx-edit'></i></button>
        <button class="icon-btn frame-music-btn ${f.music ? 'has-music' : ''}" title="${f.music ? 'Remove Music' : 'Add Music'}"><i class='bx ${f.music ? 'bx-music' : 'bx-music'}'></i></button>
      </div>`:''}
    </div>
    <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
      <div class="small-muted">${i+1}</div>
      <div class="duration-group">
        <input class="input dur-sec" type="number" min="0" step="0.1" style="width:56px" value="${(function(){ const d=splitDurationFrames(safeNumber(f.duration,state.defaultDuration), state.fps); return d.sec; })()}" autocomplete="off" />
        <span class="small-muted">s</span>
        <input class="input dur-frm" type="number" min="0" step="1" style="width:56px" value="${(function(){ const d=splitDurationFrames(safeNumber(f.duration,state.defaultDuration), state.fps); return d.frm; })()}" autocomplete="off" />
        <span class="small-muted">f</span>
      </div>
    </div>`;
    framesList.appendChild(el);
    
    // Event delegation: any click within the frame card selects the frame first
    el.addEventListener('mousedown', (e) => {
      // Only select frame if clicking on non-interactive elements or if no frame is currently selected
      const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
      const isButton = e.target.tagName === 'BUTTON' || e.target.closest('button');
      
      if (!isInput && !isButton) {
        // Clicking on non-interactive areas always selects frame
        selectFrame(i, e);
      } else if (state.selected !== i) {
        // Clicking on inputs/buttons selects frame only if it's not already selected
        selectFrame(i, e);
      }
    });
    
    // Keep the old click handler for better compatibility
    el.addEventListener('click', (e) => {
      // Only handle frame selection if not clicking on interactive elements
      const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
      const isButton = e.target.tagName === 'BUTTON' || e.target.closest('button');
      
      if (!isInput && !isButton) {
        selectFrame(i, e);
      }
    });
    
    el.addEventListener('dragstart',e=>{
      const a = document.activeElement;
      const inputting = a && (a.tagName === 'INPUT' || a.tagName === 'TEXTAREA' || a.isContentEditable);
      if (inputting) { e.preventDefault(); return; }
      e.dataTransfer.setData('text/plain',i);
    });
    el.addEventListener('dragover',e=>e.preventDefault());
    el.addEventListener('drop',e=>{e.preventDefault(); const from=Number(e.dataTransfer.getData('text/plain')); const to=Number(el.dataset.index); reorder(from,to);});
    
    const ti = el.querySelector('.frame-title');
    if (ti) {
      // Remove stopPropagation from mousedown since we want frame selection to happen first
      // ti.addEventListener('mousedown', ev => ev.stopPropagation());
      ti.addEventListener('click', ev => ev.stopPropagation());
      ti.addEventListener('focus', ev => ev.stopPropagation());
      ti.addEventListener('input', ev => {
        state.frames[i].desc = ev.target.value;
        if (i === state.selected) descInput.value = ev.target.value;
        saveAuto();
        // Update preview secara real-time jika frame yang diedit adalah yang sedang dipilih
        if (i === state.selected) {
          drawPreview();
        }
      });
    }

    const secEl = el.querySelector('.dur-sec');
    const frmEl = el.querySelector('.dur-frm');
    if (secEl && frmEl) {
      // Remove stopPropagation from mousedown since we want frame selection to happen first
      // const stop = ev => ev.stopPropagation();
      // secEl.addEventListener('mousedown', stop);
      // frmEl.addEventListener('mousedown', stop);
      secEl.addEventListener('click', ev => ev.stopPropagation());
      secEl.addEventListener('focus', ev => ev.stopPropagation());
      const syncAndSave = () => {
        const newDur = Math.max(1, composeDurationFrames(secEl.value, frmEl.value, state.fps));
        state.frames[i].duration = newDur;
        const parts = splitDurationFrames(newDur, state.fps);
        secEl.value = String(parts.sec);
        frmEl.value = String(parts.frm);
        if (i === state.selected) {
          durationSecInput.value = String(parts.sec);
          durationFrmInput.value = String(parts.frm);
        }
        updateProjectInfo();
        saveAuto();
      };
      secEl.addEventListener('change', syncAndSave);
      frmEl.addEventListener('change', syncAndSave);
      secEl.addEventListener('blur', syncAndSave);
      frmEl.addEventListener('blur', syncAndSave);
      const onEnter = ev => { if (ev.key === 'Enter') { ev.preventDefault(); syncAndSave(); secEl.blur(); frmEl.blur(); } };
      secEl.addEventListener('keydown', onEnter);
      frmEl.addEventListener('keydown', onEnter);
    }
    
    // Handle edit button
    const editBtn = el.querySelector('.edit-frame');
    if(editBtn){
      editBtn.addEventListener('click', e => {
        e.stopPropagation();
        editIndex = i;
        // reuse cached Image object (ensureFrameImage will create or return frame._img)
        const img = ensureFrameImage(state.frames[i]);
        // pass Image to openDraw -> openDraw handles complete/onload
        openDraw(img);
      });
    }
    
    // Handle music button
    const musicBtn = el.querySelector('.frame-music-btn');
    if(musicBtn){
      // Hover effects for music button
      musicBtn.addEventListener('mouseenter', () => {
        if (f.music) {
          musicBtn.innerHTML = "<i class='bx bx-x'></i>";
          musicBtn.title = "Remove Music";
        }
      });
      
      musicBtn.addEventListener('mouseleave', () => {
        if (f.music) {
          musicBtn.innerHTML = "<i class='bx bx-music'></i>";
          musicBtn.title = "Remove Music";
        }
      });
      
      // Click handler for music button
      musicBtn.addEventListener('click', e => {
        e.stopPropagation();
        if (f.music) {
          // Remove music
          // Stop audio if it's currently playing from this frame
          if (musicAudio && currentMusicUrl === f.music) {
            musicAudio.pause();
            musicAudio = null;
            currentMusicUrl = null;
          }
          f.music = null;
          saveAuto();
          renderList();
        } else {
          // Add music
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = 'audio/*';
          input.style.display = 'none';
          input.addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            f.music = URL.createObjectURL(file);
            saveAuto();
            renderList();
          });
          document.body.appendChild(input);
          input.click();
          input.remove();
        }
      });
    }
  }); 
  updateProjectInfo(); 
  highlightSelected(); 
}

function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

// helper conversions between frames and s+f
function splitDurationFrames(totalFrames, fps){
  const f = Math.max(1, Number(totalFrames)||0);
  const rate = Math.max(1, Number(fps)||24);
  const sec = Math.floor(f / rate);
  const frm = f - sec * rate;
  return { sec, frm };
}
function composeDurationFrames(sec, frm, fps){
  const rate = Math.max(1, Number(fps)||24);
  const s = Number(sec) || 0;
  const fr = Math.max(0, Math.floor(Number(frm) || 0));
  return Math.max(1, Math.round(s * rate) + fr);
}

// parse flexible text like "02", "02s", "35f" according to defaultKind ("sec" or "frm")
function valueTextToFrames(text, fps, defaultKind){
  const rate = Math.max(1, Number(fps)||24);
  const raw = String(text||'').trim().toLowerCase();
  if (!raw) return 0;
  let kind = defaultKind === 'frm' ? 'frm' : 'sec';
  let numStr = raw;
  if (raw.endsWith('s')) { kind = 'sec'; numStr = raw.slice(0,-1); }
  else if (raw.endsWith('f')) { kind = 'frm'; numStr = raw.slice(0,-1); }
  const n = Number(numStr);
  if (!Number.isFinite(n)) return 0;
  if (kind === 'sec') {
    // seconds can be fractional; convert to frames
    return Math.max(0, Math.round(n * rate));
  } else {
    // frames; integer
    return Math.max(0, Math.floor(n));
  }
}
function normalizePairToFrames(secText, frmText, fps){
  const fromSec = valueTextToFrames(secText, fps, 'sec');
  const fromFrm = valueTextToFrames(frmText, fps, 'frm');
  const total = Math.max(1, fromSec + fromFrm);
  return total;
}

function reorder(from,to){ 
  if(from===to) return; 
  if(from<0||to<0||from>=state.frames.length||to>state.frames.length) return; 
  pushHistory(); 
  const [it] = state.frames.splice(from,1); 
  state.frames.splice(to,0,it); 
  renderList(); 
  selectFrame(Math.min(to,state.frames.length-1)); 
  saveAuto(); 
}

function highlightSelected(){
  Array.from(framesList.children).forEach((el, idx) => {
    if (selectedFrames.has(idx)) {
      el.classList.add('selected');
    } else {
      el.classList.remove('selected');
    }
  });
}

function clampIndex(i){ if(typeof i!=='number' || !Number.isFinite(i)) return -1; if(state.frames.length===0) return -1; return Math.min(Math.max(0,i), state.frames.length-1); }

function selectFrame(i, e = {}) {
    const isShift = e.shiftKey;
    const isCtrl = e.ctrlKey || e.metaKey;
    const clickedElement = e.target;

    // Handle selection logic
    if (isShift && selectedFrames.size > 0) {
        const lastSelected = state.selected;
        const start = Math.min(lastSelected, i);
        const end = Math.max(lastSelected, i);
        selectedFrames.clear();
        for (let j = start; j <= end; j++) {
            selectedFrames.add(j);
        }
    } else if (isCtrl) {
        if (selectedFrames.has(i)) {
            selectedFrames.delete(i);
        } else {
            selectedFrames.add(i);
        }
    } else {
        selectedFrames.clear();
        if (i >= 0) selectedFrames.add(i);
    }

    state.selected = clampIndex(i); // The last clicked frame is the primary selection

    // Handle musik untuk frame yang dipilih (jika sedang dalam playback)
    if (playing && state.selected >= 0) {
        handleMusicForFrame(state.selected);
    }

    // Re-render the whole list to update button visibility and highlights
    renderList(); 

    // Update the side panel inputs
    if (state.selected === -1) {
        descInput.value = '';
        durationSecInput.value = '0';
        durationFrmInput.value = String(state.defaultDuration);
    } else {
        const f = state.frames[state.selected] || createFrame(null);
        descInput.value = f.desc || '';
        const parts = splitDurationFrames(safeNumber(f.duration, state.defaultDuration), state.fps);
        durationSecInput.value = String(parts.sec);
        durationFrmInput.value = String(parts.frm);
    }
    
    // If clicking on an input element, focus it after selection
    if (clickedElement && (clickedElement.tagName === 'INPUT' || clickedElement.tagName === 'TEXTAREA')) {
        // Only focus if the input isn't already focused
        if (document.activeElement !== clickedElement) {
            // Use setTimeout to ensure selection happens before focus
            setTimeout(() => {
                try {
                    clickedElement.focus();
                    // If it's a text input, select all text for easy editing
                    if (clickedElement.type === 'text' || clickedElement.type === 'number') {
                        clickedElement.select();
                    }
                } catch (e) {
                    // Ignore focus errors
                }
            }, 0);
        }
    }
    
    drawPreview();

    // Auto-close sidebar on mobile after selection for better UX
    try { if (window.innerWidth <= 1024) { document.body.classList.remove('sidebar-open'); } } catch(_){}
}


function updateProjectInfo(){ totalFramesEl.textContent = String(state.frames.length); const totalFramesCount = state.frames.reduce((a,b)=>a + safeNumber(b?.duration,0),0); const seconds = Math.floor(totalFramesCount/Math.max(1,state.fps)); projectLength.textContent = seconds+'s'; }

// drawing to canvas helpers
function drawImageCover(ctx,img,w,h){ const ar = (img.width||1)/(img.height||1); const ar2 = w/h; let sx=0,sy=0,sw=img.width||w,sh=img.height||h; if(ar>ar2){ const nw=(img.height||h)*ar2; sx=((img.width||w)-nw)/2; sw=nw; } else { const nh = (img.width||w)/ar2; sy=((img.height||h)-nh)/2; sh=nh; } try{ ctx.drawImage(img,sx,sy,sw,sh,0,0,w,h); }catch(e){} }

// ----- Replaced drawOverlayCanvas with wrapping-capable version -----
function drawOverlayCanvas(title, elapsedMs) {
  const ctx = pctx;
  ctx.save();

  // Title (top-left)
  ctx.textBaseline = 'top';
  ctx.font = 'bold 44px "Impact", "Segoe UI", sans-serif';
  ctx.lineWidth = 8;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const tx = 18, ty = 12;
  ctx.strokeText(title, tx, ty);
  ctx.fillText(title, tx, ty);

  // Time (bottom-left)
  const seconds = Math.floor(elapsedMs / 1000);
  const framesSinceStart = Math.floor(elapsedMs * state.fps / 1000);
  const frameInSecond = framesSinceStart % state.fps;
  const timeText = pad2(seconds) + 's + ' + String(frameInSecond).padStart(2,'0') + 'f';
  ctx.font = 'bold 52px "Segoe UI", sans-serif';
  ctx.lineWidth = 10;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const bx = 18, by = preview.height - 100;
  ctx.strokeText(timeText, bx, by);
  ctx.fillText(timeText, bx, by);

  // small fps under it
  const fpsText = 'FPS ' + state.fps;
  ctx.font = 'bold 28px "Segoe UI", sans-serif';
  ctx.lineWidth = 8;
  ctx.strokeText(fpsText, bx, by + 68);
  ctx.fillText(fpsText, bx, by + 68);

  // compute reserved left width (timestamp area) so description won't overlap
  let reservedLeft = 18; // left margin
  ctx.font = 'bold 52px "Segoe UI", sans-serif';
  const wTime = ctx.measureText(timeText).width;
  ctx.font = 'bold 28px "Segoe UI", sans-serif';
  const wFps = ctx.measureText(fpsText).width;
  reservedLeft += Math.max(wTime, wFps) + 24; // add gap after timestamp

  // Description (bottom-right) - multiline wrapping + auto box sizing
  const desc = state.frames[state.selected]?.desc || '';
  if (desc) {
    ctx.font = '24px "Segoe UI", sans-serif';
    const pad = 16;
    const lineHeight = 32; // increased for readability
    const maxBoxAllowed = Math.max(120, preview.width - reservedLeft - 18); // keep clear of timestamp
    const maxLineWidth = Math.max(120, maxBoxAllowed - pad*2);

    const wrap = wrapText(ctx, desc, maxLineWidth);
    const lines = wrap.lines;
    const textW = wrap.maxWidth;

    const boxW = Math.min(maxBoxAllowed, Math.max(120, textW + pad*2));
    const boxH = lines.length * lineHeight + pad * 2;

    const rx = preview.width - boxW - 18;
    const ry = preview.height - boxH - 18;

    // background (semi translucent)
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(rx, ry, boxW, boxH);

    // draw each line
    ctx.fillStyle = '#fff';
    for (let i = 0; i < lines.length; i++) {
      const ly = ry + pad + i * lineHeight + 4;
      ctx.fillText(lines[i], rx + pad, ly);
    }
  }

  ctx.restore();
}

// main preview draw
function drawPreview(){ 
  pctx.clearRect(0,0,preview.width,preview.height); 
  const sel = state.selected; 
  if(sel<0||!state.frames[sel]){ 
    pctx.fillStyle='#0b0b0b'; 
    pctx.fillRect(0,0,preview.width,preview.height); 
    drawOverlayCanvas('No cut selected',0); 
    return; 
  }
  const f = state.frames[sel]; 
  const cached = frameCache[sel]?.bmp;
  if(cached){
    try { drawImageCover(pctx, cached, preview.width, preview.height); } catch(e){}
    drawGuides(pctx, preview.width, preview.height);
    drawOverlayCanvas('Cut no. ' + (sel+1), 0);
    return;
  }
  if(f.thumb){ 
    const img = new Image(); 
    img.onload = ()=>{
      drawImageCover(pctx,img,preview.width,preview.height); 
      drawGuides(pctx, preview.width, preview.height);
      drawOverlayCanvas('Cut no. ' + (sel+1), 0); 
      scheduleUpdateFrameCache(50);
    }; 
    img.onerror = ()=>{ 
      pctx.fillStyle='#111'; 
      pctx.fillRect(0,0,preview.width,preview.height); 
      drawOverlayCanvas('Cut no. ' + (sel+1), 0); 
    }; 
    img.src = f.thumb; 
  } else { 
    pctx.fillStyle='#111'; 
    pctx.fillRect(0,0,preview.width,preview.height); 
    drawOverlayCanvas('Cut no. ' + (sel+1), 0); 
  } 
}

// drawing modal (improved)
function openDraw(initial = null){
  drawDialog.classList.add('open');

  // reset drawing state and initialize new bitmap system
  baseImage = null;
  
  // Clear onion skin overlay saat modal dibuka
  octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
  
  // Pastikan ukuran semua kanvas overlay sama
  onionCanvas.width = drawCanvas.width;
  onionCanvas.height = drawCanvas.height;
  guideCanvas.width = drawCanvas.width;
  guideCanvas.height = drawCanvas.height;
  insertCanvas.width = drawCanvas.width;
  insertCanvas.height = drawCanvas.height;
  
  // Initialize new bitmap drawing system
  initDrawingCanvas();

  // clear canvas background
  dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  dctx.fillStyle = '#fff';
  dctx.fillRect(0,0,drawCanvas.width,drawCanvas.height);

  function scheduleRedraw() {
    // draw after browser paint; fallback in 40ms for rare races
    requestAnimationFrame(() => {
      try { redrawPaths(); } catch(e){}
      setTimeout(() => {
        try { redrawPaths(); } catch(e){}
      }, 40);
    });
  }

  if (initial instanceof HTMLImageElement) {
    baseImage = initial;
    if (baseImage.complete) {
      scheduleRedraw();
    } else {
      baseImage.onload = () => scheduleRedraw();
    }
  } else if (typeof initial === 'string' && initial) {
    // if passed a URL, create image but prefer reuse via ensureFrameImage outside
    baseImage = new Image();
    // optional: baseImage.crossOrigin = 'anonymous'; // if remote and CORS allowed
    baseImage.onload = () => scheduleRedraw();
    baseImage.src = initial;
  } else {
    scheduleRedraw();
  }

  // Save initial state after everything is set up
  setTimeout(() => {
    saveCanvasState();
  }, 100);

  // focus canvas so keyboard shortcuts work
  try { drawCanvas.focus(); } catch(e){}
}
function closeDraw(){ 
  drawDialog.classList.remove('open'); 
  baseImage = null; 
  // Clear onion skin dan guide overlay saat modal ditutup
  octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
  gctx.clearRect(0, 0, guideCanvas.width, guideCanvas.height); // <-- Baris baru
  ictx.clearRect(0, 0, insertCanvas.width, insertCanvas.height);
  insertImage = null;
  applyImageBtn && (applyImageBtn.style.display = 'none');
}

// toolbar events
document.querySelectorAll('.canvas-toolbar [data-tool]').forEach(b=>b.addEventListener('click',()=>{ document.querySelectorAll('.canvas-toolbar [data-tool]').forEach(x=>x.classList.remove('active')); b.classList.add('active'); tool=b.dataset.tool; }));
document.getElementById('colorPicker').addEventListener('input',e=>{color=e.target.value; brushColor = color;});
document.getElementById('sizeRange').addEventListener('input',e=>{size=Number(e.target.value)||6; brushSize = size;});

// eraser mode toggle button
// eraser mode toggle removed by request

function hexToRgba(hex) {
    let c;
    if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
        c= hex.substring(1).split('');
        if(c.length== 3){
            c= [c[0], c[0], c[1], c[1], c[2], c[2]];
        }
        c= '0x'+c.join('');
        return { r: (c>>16)&255, g: (c>>8)&255, b: c&255, a: 255 };
    }
    const rgba = hex.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if(rgba){
      return { r: parseInt(rgba[1]), g: parseInt(rgba[2]), b: parseInt(rgba[3]), a: rgba[4] ? Math.round(parseFloat(rgba[4])*255) : 255 };
    }
    return {r:0,g:0,b:0,a:255};
}

function floodFill(ctx, x, y, fillColor) {
    const canvas = ctx.canvas;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const { width, height } = canvas;
    const stack = [[Math.floor(x), Math.floor(y)]];
    const targetColor = getColorAtPixel(imageData, Math.floor(x), Math.floor(y));
    const visited = new Uint8Array(width * height);

    if (colorsMatch(targetColor, fillColor)) {
        return;
    }

    const tolerance = 32; // color matching tolerance

    while (stack.length) {
        const [px, py] = stack.pop();
        if (px < 0 || px >= width || py < 0 || py >= height) {
            continue;
        }
        const offset = py * width + px;
        if(visited[offset]) continue;

        const currentColor = getColorAtPixel(imageData, px, py);
        if (colorsMatch(currentColor, targetColor, tolerance)) {
            setColorAtPixel(imageData, px, py, fillColor);
            visited[offset] = 1;
            stack.push([px + 1, py]);
            stack.push([px - 1, py]);
            stack.push([px, py + 1]);
            stack.push([px, py - 1]);
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

function getColorAtPixel(imageData, x, y) {
    const { width, data } = imageData;
    const index = (y * width + x) * 4;
    return { r: data[index], g: data[index + 1], b: data[index + 2], a: data[index + 3] };
}

function setColorAtPixel(imageData, x, y, color) {
    const { width, data } = imageData;
    const index = (y * width + x) * 4;
    data[index] = color.r;
    data[index + 1] = color.g;
    data[index + 2] = color.b;
    data[index + 3] = color.a;
}

function colorsMatch(a, b, tolerance=0) {
    return Math.abs(a.r - b.r) <= tolerance && Math.abs(a.g - b.g) <= tolerance && Math.abs(a.b - b.b) <= tolerance && Math.abs(a.a - b.a) <= tolerance;
}

// pointer handlers — enhanced for eraser "pick" mode and baseImage retention
drawCanvas.addEventListener('pointerdown',async e=>{
  if (tool === 'pen') {
    const p = toLocal(e);
    lastBrushPoint = p;
    drawing = true;
    drawCanvas.setPointerCapture(e.pointerId);
    // Don't save state here - wait until drawing is complete
    return;
  }
  
  if (tool === 'eraser') {
    const p = toLocal(e);
    lastBrushPoint = p;
    drawing = true;
    drawCanvas.setPointerCapture(e.pointerId);
    
    if (eraserMode === 'pick') {
      // Save state before erasing for pick mode
      saveCanvasState();
      // For bitmap-based system, we'll use a simple circular eraser at the click point
      // This creates a circular transparent area
      dctx.save();
      dctx.globalCompositeOperation = 'destination-out';
      dctx.beginPath();
      dctx.arc(p.x, p.y, size, 0, Math.PI * 2);
      dctx.fill();
      dctx.restore();
      return;
    } else {
      // Stroke mode - start erasing
      return;
    }
  }
  
  const p=toLocal(e);
  if(tool === 'bucket'){
    // Save state before flood fill
    saveCanvasState();
    const rgbaColor = hexToRgba(color);
    floodFill(dctx, p.x, p.y, rgbaColor);
    return;
  }

  // For rectangle and ellipse tools, we'll implement bitmap-based drawing
  if (tool === 'rect' || tool === 'ellipse') {
    drawing=true; 
    drawCanvas.setPointerCapture(e.pointerId);
    // Store the starting point for the shape
    lastBrushPoint = p;
    return;
  }
});
 
// --- Localized Pointer Events for Drawing (Fix for sticky pen bug) ---
const stopDrawing = (e) => {
  if (!drawing) return;
  drawing = false;
  drawCanvas.releasePointerCapture(e.pointerId);
  
  // Don't save state here - it's handled by specific tool handlers
};

drawCanvas.addEventListener('pointermove', e => {
  if (tool === 'pen') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      drawBrushStroke(lastBrushPoint, p, e.pressure || 0.5);
      lastBrushPoint = p;
      // Don't save state here - wait until drawing is complete
    }
    return;
  }
  
  if (tool === 'eraser') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      drawEraserStroke(lastBrushPoint, p);
      lastBrushPoint = p;
      // Don't save state here - wait until drawing is complete
    }
    return;
  }
  
  // For rectangle and ellipse tools, show preview while drawing
  if (tool === 'rect' || tool === 'ellipse') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      // Clear the canvas and restore the last saved state
      if (drawingHistory.length > 0 && currentHistoryIndex >= 0) {
        const lastState = drawingHistory[currentHistoryIndex];
        dctx.putImageData(lastState, 0, 0);
      }
      
      // Draw the shape preview
      dctx.save();
      dctx.strokeStyle = color;
      dctx.lineWidth = size;
      dctx.beginPath();
      
      const x = Math.min(lastBrushPoint.x, p.x);
      const y = Math.min(lastBrushPoint.y, p.y);
      const w = Math.abs(p.x - lastBrushPoint.x);
      const h = Math.abs(p.y - lastBrushPoint.y);
      
      if (tool === 'rect') {
        dctx.rect(x, y, w, h);
      } else {
        dctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
      }
      dctx.stroke();
      dctx.restore();
    }
    return;
  }
});
drawCanvas.addEventListener('pointerup', e => { 
  if (tool === 'pen') { 
    // Save canvas state after completing pen drawing
    if (drawing) {
      saveCanvasState();
    }
    lastBrushPoint = null; 
  } 
  if (tool === 'eraser') {
    // Save canvas state after completing eraser operation
    if (drawing) {
      saveCanvasState();
    }
    lastBrushPoint = null;
  }
  
  // For rectangle and ellipse tools, finalize the drawing
  if (tool === 'rect' || tool === 'ellipse') {
    if (drawing && lastBrushPoint) {
      const p = toLocal(e);
      
      // Clear the canvas and restore the last saved state
      if (drawingHistory.length > 0 && currentHistoryIndex >= 0) {
        const lastState = drawingHistory[currentHistoryIndex];
        dctx.putImageData(lastState, 0, 0);
      }
      
      // Draw the final shape
      dctx.save();
      dctx.strokeStyle = color;
      dctx.lineWidth = size;
      dctx.beginPath();
      
      const x = Math.min(lastBrushPoint.x, p.x);
      const y = Math.min(lastBrushPoint.y, p.y);
      const w = Math.abs(p.x - lastBrushPoint.x);
      const h = Math.abs(p.y - lastBrushPoint.y);
      
      if (tool === 'rect') {
        dctx.rect(x, y, w, h);
      } else {
        dctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
      }
      dctx.stroke();
      dctx.restore();
      
      // Save the canvas state after drawing the shape
      saveCanvasState();
      lastBrushPoint = null;
    }
  }
  
  stopDrawing(e); 
});
drawCanvas.addEventListener('pointerleave', stopDrawing); // Stop drawing if pointer leaves canvas

function toLocal(e){ const r=drawCanvas.getBoundingClientRect(); return { x:(e.clientX-r.left)*(drawCanvas.width/r.width||1), y:(e.clientY-r.top)*(drawCanvas.height/r.height||1), pressure: e.pressure } }

function redrawPaths(){ 
  // 1. Gambar utama di dctx (drawCanvas)
  dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height); 
  dctx.fillStyle='#fff'; 
  dctx.fillRect(0,0,drawCanvas.width,drawCanvas.height);

  if(baseImage){
    dctx.save();
    try{ drawImageCover(dctx, baseImage, drawCanvas.width, drawCanvas.height); }catch(e){}
    dctx.restore();
  }

  // 2. Gambar Onion Skin di octx (onionCanvas)
  const refIndex = (typeof editIndex === 'number' && editIndex !== null) ? editIndex : state.frames.length;
  if (drawDialog.classList.contains('open')) {
    renderOnionSkinsOverlay(refIndex);
  } else {
    octx.clearRect(0, 0, onionCanvas.width, onionCanvas.height);
  }

  // 3. Gambar Guides di gctx (guideCanvas) - INI PERUBAHAN UTAMA
  gctx.clearRect(0, 0, guideCanvas.width, guideCanvas.height); // Bersihkan kanvas panduan
  drawGuides(gctx, guideCanvas.width, guideCanvas.height);    // Gambar panduan di atasnya
}

function hitTestPath(s,p,threshold){ if(!s||!s.points) return false; const th = Math.max(8, threshold||6);
  if(s.tool==='rect' || s.tool==='ellipse'){ const a=s.points[0], b=s.points[s.points.length-1]; const x=Math.min(a.x,b.x), y=Math.min(a.y,b.y), w=Math.abs(a.x-b.x), h=Math.abs(a.y-b.y); if(s.tool==='rect'){ return (p.x>=x-th && p.x<=x+w+th && p.y>=y-th && p.y<=y+h+th); } else { // ellipse approximate
      const cx = x + w/2, cy = y + h/2; const rx = Math.max(2,w/2), ry = Math.max(2,h/2); const nx = (p.x-cx)/rx, ny = (p.y-cy)/ry; return (nx*nx + ny*ny) <= 1.4; }
  }
  // path stroke: check each segment point distance
  for(const pt of s.points){ const dx = pt.x - p.x, dy = pt.y - p.y; if(Math.sqrt(dx*dx+dy*dy) <= th + (s.size||0)/2) return true; }
  return false;
}

// test pixel opacity on baseImage by drawing to temp canvas
function isOpaqueAt(img, x, y){ return new Promise(r=>{ const tc = document.createElement('canvas'); tc.width = drawCanvas.width; tc.height = drawCanvas.height; const tctx = tc.getContext('2d'); try{ drawImageCover(tctx, img, tc.width, tc.height); const px = Math.floor(x), py = Math.floor(y); const d = tctx.getImageData(Math.max(0,px), Math.max(0,py), 1, 1).data; r(d[3] > 16); }catch(e){ r(false); } }); }

// undo / redo / clear
document.getElementById('undoBtn').addEventListener('click',()=>{ 
  if (drawDialog.classList.contains('open')) {
    // In drawing modal, use drawing-specific undo
    if (currentHistoryIndex > 0) {
      restoreCanvasState(currentHistoryIndex - 1);
    }
  } else {
    // Outside drawing modal, use global undo
    undo(); 
  }
});
document.getElementById('redoBtn').addEventListener('click',()=>{ 
  if (drawDialog.classList.contains('open')) {
    // In drawing modal, use drawing-specific redo
    if (currentHistoryIndex < drawingHistory.length - 1) {
      restoreCanvasState(currentHistoryIndex + 1);
    }
  } else {
    // Outside drawing modal, use global redo
    redo(); 
  }
});
document.getElementById('clearBtn').addEventListener('click',()=>{ clearCanvas(); });
document.getElementById('cancelDraw').addEventListener('click',()=>{ closeDraw(); });
document.getElementById('confirmDraw').addEventListener('click',async ()=>{
  pushHistory();
  
  // Buat temporary canvas untuk menyimpan gambar final tanpa onion skin
  const temp = document.createElement('canvas');
  temp.width = drawCanvas.width;
  temp.height = drawCanvas.height;
  const tctx = temp.getContext('2d');

  // Base image tanpa onion skin
  if(baseImage){
    drawImageCover(tctx, baseImage, temp.width, temp.height);
  }
  
  // Tambahkan gambar hasil edit (tanpa onion skin)
  tctx.drawImage(drawCanvas,0,0);

  // Ambil data URL dari temporary canvas (tanpa onion skin)
  const data = temp.toDataURL('image/png');
  
  if(editIndex !== null){ 
    state.frames[editIndex].thumb = data;
    selectFrame(editIndex);
    editIndex = null;
  } else {
    state.frames.push({ thumb: data, desc: '', duration: Math.max(1,safeNumber(state.defaultDuration,24)) });
    selectFrame(state.frames.length-1);
  }
  renderList();
  closeDraw();
  saveAuto();
});

// mode and add frame
const modeToggle = document.getElementById('modeToggle');
// default position to left (Draw)
if (modeToggle) modeToggle.style.setProperty('--pos','0');
modeToggle.addEventListener('click', e => {
  const btn = e.target.closest('button[data-mode]');
  if (!btn) return;
  const mode = btn.dataset.mode;
  state.mode = mode;
  document.querySelectorAll('#modeToggle button').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  modeToggle.style.setProperty('--pos', mode === 'upload' ? '1' : '0');
});
document.getElementById('addFrame').addEventListener('click',()=>{
  if(state.mode==='draw') { 
    editIndex = null; // Ensure it's a new frame
    openDraw(); 
  } else { 
    document.getElementById('uploader').click(); 
  }
});

// uploader
const uploader = document.getElementById('uploader'); uploader.addEventListener('change',async(e)=>{
  const files = Array.from(e.target.files||[]); 
  if (files.length > 0) pushHistory();
  for(const f of files){ 
    const data = await readFileAsDataURL(f); 
    state.frames.push({ thumb: data, desc: '', duration: Math.max(1,safeNumber(state.defaultDuration,24)) }); 
  } 
  renderList(); 
  selectFrame(state.frames.length-1); 
  saveAuto(); 
  uploader.value=''; 
  scheduleUpdateFrameCache(); // start caching newly added frames
});
function readFileAsDataURL(file){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=()=>res(null); r.readAsDataURL(file);} ); }

// ====================
// History Stack System
// ====================
let history = [];
let historyIndex = -1;

function pushHistory() {
    history = history.slice(0, historyIndex + 1);
    history.push(JSON.stringify(state.frames));
    historyIndex++;
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        state.frames = normalizeFrames(JSON.parse(history[historyIndex]));
        renderList();
        selectFrame(clampIndex(state.selected));
    }
}

function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        state.frames = normalizeFrames(JSON.parse(history[historyIndex]));
        renderList();
        selectFrame(clampIndex(state.selected));
    }
}

// =======================================
// Frame Operations (Copy, Cut, Paste etc)
// =======================================
function copyFrames() {
    if (selectedFrames.size === 0) return;
    const sortedIndices = [...selectedFrames].sort((a, b) => a - b);
    clipboardFrames = sortedIndices.map(i => JSON.parse(JSON.stringify(state.frames[i])));
}

function cutFrames() {
    if (selectedFrames.size === 0) return;
    pushHistory();
    copyFrames();
    const sortedIndices = [...selectedFrames].sort((a, b) => b - a);
    for (const index of sortedIndices) {
        state.frames.splice(index, 1);
    }
    selectedFrames.clear();
    renderList();
    selectFrame(-1);
    saveAuto();
}

function pasteFrames() {
    if (clipboardFrames.length === 0) return;
    pushHistory();
    const insertPos = state.selected >= 0 ? state.selected + 1 : state.frames.length;
    const copies = clipboardFrames.map(f => JSON.parse(JSON.stringify(f)));
    state.frames.splice(insertPos, 0, ...copies);
    selectedFrames.clear();
    for(let i=0; i<copies.length; i++) {
        selectedFrames.add(insertPos + i);
    }
    state.selected = insertPos + copies.length - 1;
    renderList();
    selectFrame(state.selected);
    saveAuto();
}

function deleteSelectedFrames() {
    if (selectedFrames.size === 0) return;
    pushHistory();
    const sortedIndices = [...selectedFrames].sort((a, b) => b - a);
    for (const index of sortedIndices) {
        state.frames.splice(index, 1);
    }
    const newSel = state.frames.length ? Math.max(0, Math.min(sortedIndices[sortedIndices.length-1], state.frames.length - 1)) : -1;
    selectedFrames.clear();
    renderList();
    selectFrame(newSel);
    saveAuto();
}

function duplicateSelectedFrames() {
    if (selectedFrames.size === 0) return;
    pushHistory();
    const sortedIndices = [...selectedFrames].sort((a, b) => a - b);
    const copies = sortedIndices.map(i => JSON.parse(JSON.stringify(state.frames[i])));
    const insertPos = sortedIndices[sortedIndices.length - 1] + 1;
    state.frames.splice(insertPos, 0, ...copies);
    selectedFrames.clear();
    for(let i=0; i<copies.length; i++) {
        selectedFrames.add(insertPos + i);
    }
    state.selected = insertPos + copies.length - 1;
    renderList();
    selectFrame(state.selected);
    saveAuto();
}


// duplicate / remove buttons
document.getElementById('duplicateFrame').addEventListener('click', () => duplicateSelectedFrames());
document.getElementById('removeFrame').addEventListener('click', () => deleteSelectedFrames());

// fps & durations
fpsInput.addEventListener('change',e=>{ state.fps = Math.max(1, Number(e.target.value)||24); fpsBadge.textContent = state.fps + ' FPS'; saveAuto(); updateProjectInfo(); renderList(); if(state.selected>=0){ const parts = splitDurationFrames(state.frames[state.selected].duration, state.fps); durationSecInput.value = String(parts.sec); durationFrmInput.value = String(parts.frm); } });
defaultDurationInput.addEventListener('change',e=>{ state.defaultDuration = Math.max(1, Number(e.target.value)||24); });
descInput.addEventListener('input',e=>{ 
  if(state.selected>=0 && state.frames[state.selected]){ 
    state.frames[state.selected].desc = e.target.value; 
    renderList(); 
    saveAuto(); 
    // Update preview secara real-time saat deskripsi berubah
    drawPreview();
  } 
});
// replace old single duration input with dual inputs listeners
function updateSelectedDurationFromSide(){
  if(state.selected>=0 && state.frames[state.selected]){
    const d = normalizePairToFrames(durationSecInput.value, durationFrmInput.value, state.fps);
    state.frames[state.selected].duration = d;
    const parts = splitDurationFrames(d, state.fps);
    durationSecInput.value = String(parts.sec);
    durationFrmInput.value = String(parts.frm);
    renderList();
    saveAuto();
  }
}
durationSecInput.addEventListener('change', updateSelectedDurationFromSide);
durationFrmInput.addEventListener('change', updateSelectedDurationFromSide);
durationSecInput.addEventListener('blur', updateSelectedDurationFromSide);
durationFrmInput.addEventListener('blur', updateSelectedDurationFromSide);
durationSecInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); updateSelectedDurationFromSide(); durationSecInput.blur(); }});
durationFrmInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); updateSelectedDurationFromSide(); durationFrmInput.blur(); }});

// save/load
function saveAuto(){ try{ const payload = { meta: { fps: state.fps, defaultDuration: state.defaultDuration, title: document.getElementById('projectTitle').value||'' }, frames: state.frames }; localStorage.setItem('ladaboard.autosave', JSON.stringify(payload)); }catch(e){ console.warn('autosave failed',e); } }

// Helper function to convert blob to base64 data URL
async function blobToDataURL(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Helper function to convert base64 data URL back to blob
function dataURLToBlob(dataURL) {
  const [header, base64Data] = dataURL.split(",");
  const mime = header.match(/:(.*?);/)[1];
  const byteString = atob(base64Data);
  const arrayBuffer = new ArrayBuffer(byteString.length);
  const uint8Array = new Uint8Array(arrayBuffer);
  for (let i = 0; i < byteString.length; i++) {
    uint8Array[i] = byteString.charCodeAt(i);
  }
  return new Blob([uint8Array], { type: mime });
}

function download(filename, blob){ const a=document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),2000); }

// Enhanced save function that converts music blobs to base64
document.getElementById('saveProject').addEventListener('click', async ()=>{
  try {
    const project = {
      meta: { 
        title: document.getElementById('projectTitle').value||'', 
        fps: state.fps, 
        defaultDuration: state.defaultDuration 
      },
      frames: []
    };

    // Process each frame and convert music blobs to base64
    for (let f of state.frames) {
      const frameCopy = { ...f };

      // If music exists and is a blob URL, convert to base64
      if (f.music && f.music.startsWith('blob:')) {
        try {
          // Fetch the blob from the URL
          const response = await fetch(f.music);
          const blob = await response.blob();
          frameCopy.musicData = await blobToDataURL(blob);
          delete frameCopy.music; // Remove the blob URL to avoid JSON errors
        } catch (err) {
          console.warn('Failed to convert music to base64:', err);
          // Keep the original music if conversion fails
        }
      }

      project.frames.push(frameCopy);
    }

    const json = JSON.stringify(project, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    download((document.getElementById('projectTitle').value||'LadaBoard')+'.json', blob);
  } catch (err) {
    alert('Save failed: ' + (err && err.message ? err.message : String(err)));
  }
});

document.getElementById('loadProject').addEventListener('click',()=>document.getElementById('loadProjectInput').click());

// Enhanced load function that converts base64 music back to blobs
const loadProjectInput = document.getElementById('loadProjectInput'); 
loadProjectInput.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  
  try {
    const txt = await f.text();
    const data = JSON.parse(txt);
    
    // Process frames and convert base64 music back to blobs
    if (data.frames && Array.isArray(data.frames)) {
      for (let frame of data.frames) {
        if (frame.musicData) {
          try {
            // Convert base64 back to blob
            frame.music = URL.createObjectURL(dataURLToBlob(frame.musicData));
            delete frame.musicData; // Clean up the base64 data
          } catch (err) {
            console.warn('Failed to convert music from base64:', err);
            frame.music = null; // Set to null if conversion fails
          }
        }
      }
    }
    
    state.frames = normalizeFrames(data.frames||[]);
    state.fps = safeNumber(data.meta?.fps, state.fps);
    state.defaultDuration = safeNumber(data.meta?.defaultDuration, state.defaultDuration);
    document.getElementById('projectTitle').value = data.meta?.title || '';
    fpsInput.value = state.fps;
    fpsBadge.textContent = state.fps + ' FPS';
    defaultDurationInput.value = state.defaultDuration;
    renderList();
    selectFrame(state.frames.length?0:-1);
    pushHistory();
    saveAuto();
  } catch(err) {
    alert('Invalid project file: ' + (err && err.message ? err.message : String(err)));
  }
  e.target.value = '';
});

// export spread
document.getElementById('exportSpreadPng').addEventListener('click', async () => {
  if (!state.frames.length) return alert('No frames');
  
  const pages = await generateStoryboardPages();
  pages.forEach((c, i) => {
    const a = document.createElement('a');
    a.href = c.toDataURL('image/png');
    a.download = `storyboard_page${i + 1}.png`;
    a.click();
  });
});

document.getElementById('exportSpreadPdf').addEventListener('click', async () => {
  const { jsPDF } = window.jspdf;

  const pageWmm = 210;
  const pageHmm = 297;
  const pdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });

  const perPage = 5;
  const thumbWmm = 90;
  const thumbHmm = 50.6;
  const marginXmm = 10;
  const startYmm = 25;
  const rowHmm = 55;

  const colCut = 15;
  const colImg = thumbWmm + 5;
  const colAction = 50;
  const colDialogue = 50;
  const colSec = 15;
  const colX = [
    marginXmm,
    marginXmm + colCut,
    marginXmm + colCut + colImg,
    marginXmm + colCut + colImg + colAction,
    marginXmm + colCut + colImg + colAction + colDialogue,
    pageWmm - marginXmm
  ];

  for (let p = 0; p < Math.ceil(state.frames.length / perPage); p++) {
    if (p > 0) pdf.addPage();

    // Garis vertikal
    for (let x of colX) {
      pdf.line(x, startYmm, x, startYmm + perPage * rowHmm);
    }

    // Garis horizontal
    for (let r = 0; r <= perPage; r++) {
      const y = startYmm + r * rowHmm;
      pdf.line(marginXmm, y, pageWmm - marginXmm, y);
    }

    // Label kolom (Inggris)
    pdf.setFont("helvetica", "normal");
    pdf.setFontSize(8);
    pdf.text('Cut', colX[0] + 2, startYmm - 2);
    pdf.text('Picture', colX[1] + 2, startYmm - 2);
    pdf.text('Action / Notes', colX[2] + 2, startYmm - 2);
    pdf.text('Dialogue / Sound', colX[3] + 2, startYmm - 2);
    pdf.text('Sec', colX[4] + 2, startYmm - 2);

    // Isi baris
    for (let r = 0; r < perPage; r++) {
      const idx = p * perPage + r;
      if (idx >= state.frames.length) break;
      const f = state.frames[idx];
      const y = startYmm + r * rowHmm;

      // Cut number
      pdf.setFontSize(9);
      pdf.text(String(idx + 1).padStart(2, '0'), colX[0] + 2, y + 5);

      // Frame image
      if (f.thumb) {
        const img = await createBitmapFromSrc(f.thumb);
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = img.width;
        tmpCanvas.height = img.height;
        tmpCanvas.getContext('2d').drawImage(img, 0, 0);
        const imgData = tmpCanvas.toDataURL('image/jpeg', 0.8);
        pdf.addImage(imgData, 'JPEG', colX[1] + 1, y + 1, thumbWmm, thumbHmm);
      }

      // Action / Notes
      pdf.setFontSize(8);
      let actionLines = pdf.splitTextToSize(f.desc || '', colAction - 4);
      pdf.text(actionLines, colX[2] + 2, y + 4);

      // Dialogue / Sound
      if (f.music) {
        const name = f.music.split('/').pop().split('?')[0];
        let musicLines = pdf.splitTextToSize(`BGM: ${name} (00:00)`, colDialogue - 4);
        pdf.text(musicLines, colX[3] + 2, y + 4);
      }

      // Sec
      const secs = splitDurationFrames(f.duration, state.fps).sec;
      pdf.setFontSize(9);
      pdf.text(`${secs}`, colX[4] + 2, y + 5);
    }
  }

  pdf.save('storyboard.pdf');
});

function blankImageData(w,h){ const c=document.createElement('canvas'); c.width=w;c.height=h; const cx=c.getContext('2d'); cx.fillStyle='#222'; cx.fillRect(0,0,w,h); return c.toDataURL('image/png'); }

// ---------- Export menu bindings (WEBM/MP4) ----------
(function attachExportBindings(){
  const webmBtn = document.getElementById('exportVideoWebm');
  const mp4Btn = document.getElementById('exportVideoMp4');
  if (webmBtn) {
    webmBtn.addEventListener('click', async ()=>{
      try { showLoading('Exporting WEBM', 'Rendering frames...'); await exportVideoWebm(); }
      catch(err){ alert('Export failed: ' + (err?.message||err)); }
      finally { hideLoading(); }
    });
  }
  if (mp4Btn) {
    mp4Btn.addEventListener('click', async ()=>{
      try { showLoading('Exporting MP4', 'Encoding video...'); await exportVideoMp4(); }
      catch(err){ alert('Export failed: ' + (err?.message||err)); }
      finally { hideLoading(); }
    });
  }
})();

// ---------- Helpers for export (no console logs) ----------
function chooseSupportedMime() {
  const options = [
    'video/webm;codecs=vp9',
    'video/webm;codecs=vp8',
    'video/webm'
  ];
  for (const m of options) {
    try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(m)) return m; } catch(e) {}
  }
  return 'video/webm';
}
function waitMs(ms){ return new Promise(r=>setTimeout(r, ms)); }

function drawOverlayForExport(ctx, elapsedMs, frameIndex, w, h, fps, desc) {
  ctx.save();
  // Cut no. (top-left)
  ctx.textBaseline = 'top';
  ctx.font = 'bold 36px "Segoe UI", sans-serif';
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const tx = 16, ty = 10;
  ctx.strokeText('Cut no. ' + (frameIndex + 1), tx, ty);
  ctx.fillText('Cut no. ' + (frameIndex + 1), tx, ty);

  // Time (bottom-left)
  const seconds = Math.floor(elapsedMs / 1000);
  const framesSinceStart = Math.floor(elapsedMs * fps / 1000);
  const frameInSecond = framesSinceStart % fps;
  const timeText = String(seconds).padStart(2,'0') + 's +' + String(frameInSecond).padStart(2,'0') + 'f';
  ctx.font = 'bold 40px "Segoe UI", sans-serif';
  ctx.lineWidth = 8;
  ctx.strokeStyle = 'rgba(0,0,0,0.95)';
  ctx.fillStyle = '#ffffff';
  const bx = 16, by = h - 110;
  ctx.strokeText(timeText, bx, by);
  ctx.fillText(timeText, bx, by);

  // small fps under it
  const fpsText = 'FPS ' + fps;
  ctx.font = 'bold 22px "Segoe UI", sans-serif';
  ctx.lineWidth = 6;
  ctx.strokeText(fpsText, bx, by + 56);
  ctx.fillText(fpsText, bx, by + 56);

  // compute reserved left area width
  let reservedLeft = 18;
  ctx.font = 'bold 40px "Segoe UI", sans-serif';
  const wTime = ctx.measureText(timeText).width;
  ctx.font = 'bold 22px "Segoe UI", sans-serif';
  const wFps = ctx.measureText(fpsText).width;
  reservedLeft += Math.max(wTime, wFps) + 24;

  // Description (bottom-right) using wrapText already in your code
  if (desc) {
    ctx.font = '16px "Segoe UI", sans-serif';
    const pad = 12;
    const lineHeight = 20;
    const maxBoxAllowed = Math.max(120, w - reservedLeft - 18);
    const maxLineWidth = Math.max(120, maxBoxAllowed - pad * 2);
    const wrap = wrapText(ctx, desc, maxLineWidth);
    const lines = wrap.lines;
    const textW = wrap.maxWidth;
    const boxW = Math.min(maxBoxAllowed, Math.max(120, textW + pad * 2));
    const boxH = lines.length * lineHeight + pad * 2;
    const rx = w - boxW - 18;
    const ry = h - boxH - 12;

    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(rx, ry, boxW, boxH);

    ctx.fillStyle = '#fff';
    for (let i = 0; i < lines.length; i++) {
      const ly = ry + pad + i * lineHeight + 4;
      ctx.fillText(lines[i], rx + pad, ly);
    }
  }
  ctx.restore();
}

// ---------- Export WEBM (no audio) ----------
async function exportVideoWebm(){
  if (!state.frames.length) { alert('No frames'); return; }
  const w = preview.width || 1280;
  const h = preview.height || 720;
  const rec = document.createElement('canvas');
  rec.width = w; rec.height = h;
  const ctx = rec.getContext('2d');

  let recorder;
  const chunks = [];
  const mime = chooseSupportedMime();
  try {
    const stream = rec.captureStream(Math.max(1, state.fps || 24));
    recorder = new MediaRecorder(stream, { mimeType: mime });
  } catch (err) {
    throw new Error('MediaRecorder not available or mime not supported on this browser.');
  }

  recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };

  const stopped = new Promise(resolve => recorder.onstop = resolve);
  try { recorder.start(1000); } catch (err) { try { recorder.start(); } catch(e) { throw new Error('Recorder failed to start.'); } }

  let cumulativeMs = 0;
  const frameMs = 1000 / Math.max(1, state.fps || 24);

  for (let i = 0; i < state.frames.length; i++) {
    const f = state.frames[i] || createFrame(null);
    const cache = frameCache[i];
    const img = cache?.bmp || await createBitmapFromSrc(f.thumb || blankImageData(w,h));

    const framesToShow = Math.max(1, Math.round(safeNumber(f.duration, state.defaultDuration)));
    for (let ff = 0; ff < framesToShow; ff++) {
      ctx.clearRect(0,0,w,h);
      try { drawImageCover(ctx, img, w, h); } catch(e){}
      try { drawGuides(ctx, w, h); } catch(e){}
      drawOverlayForExport(ctx, cumulativeMs, i, w, h, state.fps || 24, f.desc || '');
      await waitMs(Math.round(frameMs));
      cumulativeMs += frameMs;
    }
  }

  recorder.stop();
  await stopped;
  if (!chunks.length) throw new Error('No video data captured.');
  const blob = new Blob(chunks, { type: mime });
  download(sanitizeFilename((document.getElementById('projectTitle').value || 'storyboard')) + '.webm', blob);
}

// ---------- Export MP4 (with audio) via ffmpeg.wasm ----------
async function exportVideoMp4(){
  if (!state.frames.length) { alert('No frames'); return; }
  const w = preview.width || 1280;
  const h = preview.height || 720;

  // 1) Render frames to a single silent WEBM first
  showLoading('Exporting MP4', 'Rendering frames...');
  const webmBlob = await renderFramesToWebm(w, h);

  // 2) Collect audio tracks (concatenate frame-level audios sequentially)
  const audioBlobs = [];
  for (let i=0;i<state.frames.length;i++){
    const url = state.frames[i]?.music;
    if (!url) continue;
    try {
      const res = await fetch(url);
      const b = await res.blob();
      audioBlobs.push(b);
    } catch(_){/* skip */}
  }

  // 3) Use ffmpeg.wasm to mux WEBM video with concatenated audio (if any)
  showLoading('Exporting MP4', 'Encoding and muxing...');
  const mp4Blob = await muxToMp4(webmBlob, audioBlobs, state.fps);
  download(sanitizeFilename((document.getElementById('projectTitle').value || 'storyboard')) + '.mp4', mp4Blob);
}

async function renderFramesToWebm(w, h){
  const rec = document.createElement('canvas');
  rec.width = w; rec.height = h;
  const ctx = rec.getContext('2d');
  const chunks = [];
  const mime = chooseSupportedMime();
  let recorder;
  try {
    const stream = rec.captureStream(Math.max(1, state.fps || 24));
    recorder = new MediaRecorder(stream, { mimeType: mime });
  } catch (err) {
    throw new Error('MediaRecorder not available or mime not supported on this browser.');
  }
  recorder.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
  const stopped = new Promise(resolve => recorder.onstop = resolve);
  try { recorder.start(1000); } catch (err) { try { recorder.start(); } catch(e) { throw new Error('Recorder failed to start.'); } }

  let cumulativeMs = 0;
  const frameMs = 1000 / Math.max(1, state.fps || 24);
  for (let i = 0; i < state.frames.length; i++) {
    const f = state.frames[i] || createFrame(null);
    const cache = frameCache[i];
    const img = cache?.bmp || await createBitmapFromSrc(f.thumb || blankImageData(w,h));
    const framesToShow = Math.max(1, Math.round(safeNumber(f.duration, state.defaultDuration)));
    for (let ff = 0; ff < framesToShow; ff++) {
      ctx.clearRect(0,0,w,h);
      try { drawImageCover(ctx, img, w, h); } catch(e){}
      try { drawGuides(ctx, w, h); } catch(e){}
      drawOverlayForExport(ctx, cumulativeMs, i, w, h, state.fps || 24, f.desc || '');
      await waitMs(Math.round(frameMs));
      cumulativeMs += frameMs;
    }
  }
  recorder.stop();
  await stopped;
  if (!chunks.length) throw new Error('No video data captured.');
  return new Blob(chunks, { type: mime });
}

// ffmpeg.wasm loader and mux helper
let _ffmpegLoading = null;
async function loadFfmpeg(){
  if (window._ffmpeg) return window._ffmpeg;
  if (_ffmpegLoading) return _ffmpegLoading;
  _ffmpegLoading = (async ()=>{
    const { createFFmpeg, fetchFile } = await import('https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js');
    const ffmpeg = createFFmpeg({ log: false, corePath: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js' });
    showLoading('Exporting MP4', 'Loading encoder (~20MB)...');
    await ffmpeg.load();
    window._ffmpeg = { ffmpeg, fetchFile };
    return window._ffmpeg;
  })();
  return _ffmpegLoading;
}

async function muxToMp4(webmBlob, audioBlobs, fps){
  const { ffmpeg, fetchFile } = await loadFfmpeg();
  // Write video file
  await ffmpeg.FS('writeFile', 'video.webm', await fetchFile(webmBlob));

  // If multiple audios, concatenate to one
  let audioInput = null;
  if (audioBlobs && audioBlobs.length){
    const inputs = [];
    for (let i=0;i<audioBlobs.length;i++){
      const name = `a${i}.mp3`;
      await ffmpeg.FS('writeFile', name, await fetchFile(audioBlobs[i]));
      inputs.push(name);
    }
    if (inputs.length === 1){
      audioInput = inputs[0];
    } else {
      // Generate concat list
      const list = inputs.map(n=>`file '${n}'`).join('\n');
      await ffmpeg.FS('writeFile', 'alist.txt', new TextEncoder().encode(list));
      await ffmpeg.run('-f','concat','-safe','0','-i','alist.txt','-c','copy','merged.mp3');
      audioInput = 'merged.mp3';
    }
  }

  // Transcode/mux to MP4 (H.264 + AAC)
  const args = audioInput
    ? ['-i','video.webm','-i',audioInput,'-c:v','libx264','-preset','veryfast','-crf','23','-r', String(Math.max(1,fps||24)),'-c:a','aac','-b:a','192k','-shortest','out.mp4']
    : ['-i','video.webm','-c:v','libx264','-preset','veryfast','-crf','23','-r', String(Math.max(1,fps||24)),'out.mp4'];

  updateLoading('Encoding MP4...');
  await ffmpeg.run(...args);
  const data = await ffmpeg.FS('readFile', 'out.mp4');
  return new Blob([data.buffer], { type:'video/mp4' });
}




// playback engine (unchanged)
let playing = false;
let playStartTime = 0;
let pausedTime = 0;
let rafId = null;
let currentFrameIndex = -1;
const playBtn = document.getElementById('playAll');

function findFrameIndex(elapsedMs) {
    const elapsedFrames = elapsedMs * state.fps / 1000;
    let framesSoFar = 0;
    for (let i = 0; i < state.frames.length; i++) {
        framesSoFar += state.frames[i].duration;
        if (elapsedFrames < framesSoFar) {
            return i;
        }
    }
    return -1; // end of playback
}

function getElapsedInFrame(elapsedMs, frameIndex) {
    const elapsedFrames = elapsedMs * state.fps / 1000;
    let framesBefore = 0;
    for (let i = 0; i < frameIndex; i++) {
        framesBefore += state.frames[i].duration;
    }
    const elapsedInFrame = elapsedFrames - framesBefore;
    return elapsedInFrame * 1000 / state.fps;
}


function playbackLoop() {
    if (!playing) return;

    const elapsed = pausedTime + (performance.now() - playStartTime);
    const frameIdx = findFrameIndex(elapsed);

    if (frameIdx === -1) {
        if (loopEnabled) {
            pausedTime = 0;
            currentFrameIndex = -1;
            playStartTime = performance.now();
            rafId = requestAnimationFrame(playbackLoop);
            return;
        } else {
            stopPlayback();
            return;
        }
    }

    if (frameIdx !== currentFrameIndex) {
        currentFrameIndex = frameIdx;
        // Select without re-rendering list to avoid jank during playback
        state.selected = clampIndex(currentFrameIndex);
        handleMusicForFrame(currentFrameIndex);
    }
    
    const f = state.frames[currentFrameIndex];
    if (!f) { stopPlayback(); return; }

    const cached = frameCache[currentFrameIndex]?.bmp;
    pctx.clearRect(0, 0, preview.width, preview.height);
    if (cached) {
        try { drawImageCover(pctx, cached, preview.width, preview.height); } catch(e){}
        try { drawGuides(pctx, preview.width, preview.height); } catch(e) {}
        drawOverlayCanvas('Cut no. ' + (currentFrameIndex + 1), elapsed);
        rafId = requestAnimationFrame(playbackLoop);
        return;
    }
    const img = new Image();
    img.onload = () => {
        try { drawImageCover(pctx, img, preview.width, preview.height); } catch (e) {}
        try { drawGuides(pctx, preview.width, preview.height); } catch(e) {}
        drawOverlayCanvas('Cut no. ' + (currentFrameIndex + 1), elapsed);
        rafId = requestAnimationFrame(playbackLoop);
    };
    img.onerror = () => {
        pctx.fillStyle = '#111';
        pctx.fillRect(0, 0, preview.width, preview.height);
        drawOverlayCanvas('Cut no. ' + (currentFrameIndex + 1), elapsed);
        rafId = requestAnimationFrame(playbackLoop);
    };
    img.src = f.thumb || blankImageData(preview.width, preview.height);
}

function startPlayback() {
    if (playing || !state.frames.length) return;
    playing = true;
    playBtn.innerHTML = "<i class='bx bx-pause'></i> Stop";
    playStartTime = performance.now();
    if (pausedTime === 0) {
        currentFrameIndex = -1;
    }
    playbackLoop();
}

function pausePlayback() {
    if (!playing) return;
    playing = false;
    cancelAnimationFrame(rafId);
    pausedTime += performance.now() - playStartTime;
    playBtn.innerHTML = "<i class='bx bx-play'></i> Play";
    
    // Pause musik saat playback di-pause
    if (musicAudio) musicAudio.pause();
}

function resumePlayback(){
    if (playing) return;
    playing = true;
    playStartTime = performance.now();
    playBtn.innerHTML = "<i class='bx bx-pause'></i> Stop";
    
    // Resume musik saat playback di-resume
    if (musicAudio) musicAudio.play();
    
    playbackLoop();
}

function stopPlayback() {
    playing = false;
    cancelAnimationFrame(rafId);
    pausedTime = 0;
    currentFrameIndex = -1;
    playBtn.innerHTML = "<i class='bx bx-play'></i> Play";
    
    // Stop musik saat playback di-stop
    if (musicAudio) {
        musicAudio.pause();
        musicAudio = null;
        currentMusicUrl = null;
    }
    
    drawPreview();
}

function togglePlayback() {
    if (playing) {
        pausePlayback();
    } else {
        const totalDuration = state.frames.reduce((acc, f) => acc + f.duration, 0) * 1000 / state.fps;
        if (pausedTime >= totalDuration) {
            stopPlayback(); // if at the end, reset and play from start
            startPlayback();
        } else {
            resumePlayback(); // Use resumePlayback instead of startPlayback
        }
    }
}

playBtn.addEventListener('click', togglePlayback);

// Preload frame cache when frames list changes significantly
const origRenderList = renderList;
renderList = function(){
  origRenderList.apply(this, arguments);
  scheduleUpdateFrameCache(100);
};


// ====================
// Keyboard Shortcuts
// ====================
window.addEventListener('keydown', e => {
  // --- Shortcuts for Drawing Modal ---
  if (drawDialog.classList.contains('open')) {
    // Ctrl+Z for undo inside the modal
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
      e.preventDefault();
      if (currentHistoryIndex > 0) {
        restoreCanvasState(currentHistoryIndex - 1);
      }
      return;
    }
    // Ctrl+Y for redo inside the modal
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
      e.preventDefault();
      if (currentHistoryIndex < drawingHistory.length - 1) {
        restoreCanvasState(currentHistoryIndex + 1);
      }
      return;
    }
    // Enter to confirm
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      document.getElementById('confirmDraw').click();
      return;
    }
    // Escape to cancel
    if (e.key === 'Escape') {
      e.preventDefault();
      document.getElementById('cancelDraw').click();
      return;
    }
  }

  const target = e.target || document.activeElement;
  const isInputting = (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable));

  // Global shortcuts: ignore while typing so text fields keep native behavior
  if (!isInputting && (e.ctrlKey || e.metaKey)) {
    switch(e.key.toLowerCase()) {
      case 'z': e.preventDefault(); undo(); return;
      case 'y': e.preventDefault(); redo(); return;
      case 's': e.preventDefault(); document.getElementById('saveProject').click(); return;
      case 'c': e.preventDefault(); copyFrames(); return;
      case 'x': e.preventDefault(); cutFrames(); return;
      case 'v': e.preventDefault(); pasteFrames(); return;
    }
  }

  // Handle Enter key separately for playback vs. newline/confirm
  if (e.key === 'Enter') {
    if (isInputting) {
      // In inputs: confirm/commit by blurring non-textarea inputs; allow newline in textarea
      if (target.tagName === 'INPUT') {
        e.preventDefault();
        try { target.blur(); } catch(_) {}
      }
      return; // do not trigger playback while typing
    }
    e.preventDefault();
    togglePlayback();
    return;
  }

  // Stop other shortcuts if user is typing
  if (isInputting || e.isComposing) return;

  // Shortcuts that should NOT work while inputting
  switch(e.key.toLowerCase()) {
    case 'arrowright':
      e.preventDefault();
      selectFrame(clampIndex(state.selected + 1));
      break;
    case 'arrowleft':
      e.preventDefault();
      selectFrame(clampIndex(state.selected - 1));
      break;
    case 'd':
      if (e.shiftKey) {
        e.preventDefault();
        duplicateSelectedFrames();
      }
      break;
    case 'delete':
    case 'backspace':
      e.preventDefault();
      deleteSelectedFrames();
      break;
  }
});

// load autosave on startup
window.addEventListener('load',()=>{
  try { 
    const data = localStorage.getItem('ladaboard.autosave'); 
    if(data){ 
      const p = JSON.parse(data); 
      state.frames = normalizeFrames(p.frames||[]); 
      state.fps = safeNumber(p.meta?.fps,state.fps); 
      state.defaultDuration = safeNumber(p.meta?.defaultDuration,state.defaultDuration); 
      document.getElementById('projectTitle').value = p.meta?.title||''; 
      fpsInput.value = state.fps; 
      fpsBadge.textContent = state.fps + ' FPS'; 
      defaultDurationInput.value = state.defaultDuration; 
      renderList(); 
      selectFrame(state.frames.length?0:-1); 
    } 
  } catch(e) { 
    console.warn('failed to load autosave',e); 
  } 
  pushHistory(); // Create initial history entry
  preview.width=1280; 
  preview.height=720; 
  scheduleUpdateFrameCache(50);
  drawPreview(); 
  // Intro overlay logic removed
});

// helpers for renderList
function escapeHtmlSimple(s){ return escapeHtml(s); }
framesList.addEventListener('click',()=>setTimeout(drawPreview,50));

// new: restart and loop controls
const restartBtn = document.getElementById('restartPlay');
const loopBtn = document.getElementById('loopToggle');
let loopEnabled = JSON.parse(localStorage.getItem('ladaboard.loopEnabled') || 'false');

function updateLoopButtonUI() {
  if (!loopBtn) return;
  loopBtn.style.borderColor = loopEnabled ? 'var(--accent)' : 'rgba(255,255,255,0.06)';
  loopBtn.style.color = loopEnabled ? '#fff' : 'var(--muted)';
}

if (restartBtn) {
  restartBtn.addEventListener('click', () => {
    pausedTime = 0;
    currentFrameIndex = -1;
    if (!playing) startPlayback();
    else playStartTime = performance.now();
  });
}
if (loopBtn) {
  loopBtn.addEventListener('click', () => {
    loopEnabled = !loopEnabled;
    localStorage.setItem('ladaboard.loopEnabled', JSON.stringify(loopEnabled));
    updateLoopButtonUI();
  });
}
updateLoopButtonUI();

// Event Add Music
// Removed - now handled by individual frame music buttons

// Event Remove Music  
// Removed - now handled by individual frame music buttons

// Fungsi untuk menangani musik saat frame berubah
function handleMusicForFrame(frameIndex){
  const frame = state.frames[frameIndex];
  if (frame.music && frame.music !== currentMusicUrl) {
    if (musicAudio) {
      musicAudio.pause();
      musicAudio = null;
    }
    musicAudio = new Audio(frame.music);
    musicAudio.play();
    currentMusicUrl = frame.music;
  }
}

// Mobile sidebar overlay controls
const openSidebarBtn = document.getElementById('openSidebar');
const mobileBackdrop = document.getElementById('mobileBackdrop');
function openSidebarOverlay(){ document.body.classList.add('sidebar-open'); }
function closeSidebarOverlay(){ document.body.classList.remove('sidebar-open'); }
if (openSidebarBtn) openSidebarBtn.addEventListener('click', openSidebarOverlay);
if (mobileBackdrop) mobileBackdrop.addEventListener('click', closeSidebarOverlay);
window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeSidebarOverlay(); });

// Image transform state for insert tool
let insertImage = null; // HTMLImageElement when active
let insertTransform = {
  x: 512,
  y: 288,
  scaleX: 1,
  scaleY: 1,
  rotation: 0,
  skewX: 0,
  skewY: 0,
  width: 0,
  height: 0,
  dragging: false,
  dragMode: null, // 'move' | 'scale' | 'rotate' | 'skewX' | 'skewY'
  dragModeCorner: null,
  startPointer: {x:0,y:0},
  startState: null
};
let suppressInsertOverlay = false;
const HANDLE = { corner: 14, edge: 12, rotRadius: 8, rotOffset: 28 };

const addImageBtn = document.getElementById('addImageBtn');
const applyImageBtn = document.getElementById('applyImageBtn');
const insertImageInput = document.getElementById('insertImageInput');

function hasActiveInsert() { return !!insertImage; }

function drawTransformedImage(ctx) {
  if (!insertImage) return;
  const cx = insertTransform.x;
  const cy = insertTransform.y;
  const w = insertTransform.width;
  const h = insertTransform.height;

  ctx.save();
  ctx.translate(cx, cy);
  // apply transform matrix: scale, skew, rotate
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.drawImage(insertImage, -w/2, -h/2, w, h);
  ctx.restore();

  // draw handles
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.strokeStyle = '#39f';
  ctx.lineWidth = 1;
  ctx.setLineDash([6,4]);
  ctx.strokeRect(-w/2, -h/2, w, h);
  ctx.setLineDash([]);
  const handle = 10; // pixels in local space
  ctx.fillStyle = '#39f';
  // corners for scale
  [[-w/2,-h/2],[w/2,-h/2],[w/2,h/2],[-w/2,h/2]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-handle/2, hy-handle/2, handle, handle);
  });
  // rotation handle: top center
  ctx.beginPath();
  ctx.arc(0, -h/2-24, 6, 0, Math.PI*2);
  ctx.fill();
  // skew handles: middle of edges
  ctx.fillStyle = '#9cf';
  [[0,-h/2],[w/2,0],[0,h/2],[-w/2,0]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-6, hy-6, 12, 12);
  });
  ctx.restore();
}

function screenToCanvasPoint(e) {
  const r = drawCanvas.getBoundingClientRect();
  return { x:(e.clientX-r.left)*(drawCanvas.width/r.width||1), y:(e.clientY-r.top)*(drawCanvas.height/r.height||1) };
}

function hitHandle(p) {
  if (!insertImage) return null;
  const {x,y,scaleX,scaleY,rotation,skewX,skewY,width,height} = insertTransform;
  let px = p.x - x, py = p.y - y;
  const cos = Math.cos(-rotation), sin = Math.sin(-rotation);
  let rx = px * cos - py * sin;
  let ry = px * sin + py * cos;
  const tanY = Math.tan(skewY), tanX = Math.tan(skewX);
  let sx = rx - tanX * ry;
  let sy = ry - tanY * sx;
  const lx = sx / scaleX;
  const ly = sy / scaleY;

  const w = width, h = height;
  const near = (ax,ay, bx,by, s)=> Math.abs(ax-bx)<=s && Math.abs(ay-by)<=s;
  // corners -> scale
  if (near(lx,ly, -w/2, -h/2, HANDLE.corner)) return {mode:'scale', corner:'tl'};
  if (near(lx,ly,  w/2, -h/2, HANDLE.corner)) return {mode:'scale', corner:'tr'};
  if (near(lx,ly,  w/2,  h/2, HANDLE.corner)) return {mode:'scale', corner:'br'};
  if (near(lx,ly, -w/2,  h/2, HANDLE.corner)) return {mode:'scale', corner:'bl'};
  // rotation handle near top center
  if (Math.hypot(lx-0, ly-(-h/2-HANDLE.rotOffset)) <= HANDLE.rotRadius + 4) return {mode:'rotate'};
  // skew handles mid edges
  if (near(lx,ly, 0, -h/2, HANDLE.edge)) return {mode:'skewY', edge:'top'};
  if (near(lx,ly,  w/2, 0, HANDLE.edge)) return {mode:'skewX', edge:'right'};
  if (near(lx,ly, 0,  h/2, HANDLE.edge)) return {mode:'skewY', edge:'bottom'};
  if (near(lx,ly, -w/2, 0, HANDLE.edge)) return {mode:'skewX', edge:'left'};
  // inside rect -> move
  if (lx>=-w/2 && lx<=w/2 && ly>=-h/2 && ly<=h/2) return {mode:'move'};
  return null;
}

function requestCanvasRedrawWithInsertOverlay() {
  // Repaint base and insert overlay
  redrawPaths();
  if (insertImage) {
    // draw overlay (image + blue handles) on insertCanvas, not the main canvas
    drawTransformedImageOverlay();
  } else {
    // ensure overlay is cleared if not active
    ictx.clearRect(0,0,insertCanvas.width, insertCanvas.height);
  }
}

let prevToolForInsert = null;
addImageBtn?.addEventListener('click', ()=>{
  insertImageInput?.click();
});

insertImageInput?.addEventListener('change', async (e)=>{
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    const img = new Image();
    img.onload = () => {
      insertImage = img;
      prevToolForInsert = tool;
      tool = 'insert';
      insertTransform.width = Math.min(drawCanvas.width * 0.6, img.width);
      insertTransform.height = insertTransform.width * (img.height / img.width);
      insertTransform.x = drawCanvas.width/2;
      insertTransform.y = drawCanvas.height/2;
      insertTransform.scaleX = 1; insertTransform.scaleY = 1;
      insertTransform.rotation = 0; insertTransform.skewX = 0; insertTransform.skewY = 0;
      applyImageBtn.style.display = 'inline-flex';
      requestCanvasRedrawWithInsertOverlay();
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
  // reset file input value so same file can be chosen again later
  e.target.value = '';
});

applyImageBtn?.addEventListener('click', ()=>{
  if (!insertImage) return;
  // permanently draw transformed image onto drawCanvas and push to history
  saveCanvasState();
  // draw current transformed image directly onto base canvas (no handles)
  drawTransformedImageOnly(dctx);
  // clear overlay state and ensure no blue handles get baked
  insertImage = null;
  ictx.clearRect(0,0,insertCanvas.width, insertCanvas.height);
  applyImageBtn.style.display = 'none';
  tool = prevToolForInsert || 'pen';
  prevToolForInsert = null;
  // save state after applying
  saveCanvasState();
  // repaint base to reflect applied image, overlays cleared
  redrawPaths();
});

// also cleanup on cancel/close
const cancelBtn = document.getElementById('cancelDraw');
if (cancelBtn) cancelBtn.addEventListener('click', ()=>{
  insertImage = null;
  applyImageBtn.style.display = 'none';
  tool = prevToolForInsert || tool;
  prevToolForInsert = null;
});

// augment pointer interactions when insert is active
(function attachInsertPointerHandlers(){
  drawCanvas.addEventListener('pointerdown', (e)=>{
  if (!insertImage) return; // let default tools handle
  const p = screenToCanvasPoint(e);
  const hit = hitHandle(p);
  if (!hit) return;
  e.preventDefault();
  insertTransform.dragging = true;
  insertTransform.dragMode = hit.mode;
  insertTransform.dragModeCorner = hit.corner || null;
  insertTransform.startPointer = p;
  insertTransform.startState = JSON.parse(JSON.stringify(insertTransform));
  drawCanvas.setPointerCapture(e.pointerId);
});

// Keep overlay drawing strictly on insertCanvas
ictx && drawTransformedImageOverlay && drawTransformedImageOverlay();

drawCanvas.addEventListener('pointermove', (e)=>{
  if (!insertImage || !insertTransform.dragging) return;
  const p = screenToCanvasPoint(e);
  const dx = p.x - insertTransform.startPointer.x;
  const dy = p.y - insertTransform.startPointer.y;
  const s = insertTransform.startState;
  switch (insertTransform.dragMode) {
    case 'move':
      insertTransform.x = s.x + dx;
      insertTransform.y = s.y + dy;
      break;
    case 'scale': {
      const corner = insertTransform.dragModeCorner || 'br';
      const signX = (corner === 'tr' || corner === 'br') ? 1 : -1;
      const signY = (corner === 'bl' || corner === 'br') ? 1 : -1;
      let factorX = 1 + (dx * signX) / 300;
      let factorY = 1 + (dy * signY) / 300;
      if (e.shiftKey) {
        const delta = Math.abs(dx) > Math.abs(dy) ? dx * signX : dy * signY;
        const f = 1 + delta / 300;
        factorX = f; factorY = f;
      }
      insertTransform.scaleX = Math.max(0.05, s.scaleX * factorX);
      insertTransform.scaleY = Math.max(0.05, s.scaleY * factorY);
      break;
    }
    case 'rotate': {
      const angle0 = Math.atan2(insertTransform.startPointer.y - s.y, insertTransform.startPointer.x - s.x);
      let angle1 = Math.atan2(p.y - s.y, p.x - s.x);
      let newAngle = s.rotation + (angle1 - angle0);
      if (e.shiftKey) {
        const step = Math.PI / 12; // 15°
        newAngle = Math.round(newAngle / step) * step;
      }
      insertTransform.rotation = newAngle;
      break;
    }
    case 'skewX': {
      insertTransform.skewX = s.skewX + dx / 300;
      break;
    }
    case 'skewY': {
      insertTransform.skewY = s.skewY + dy / 300;
      break;
    }
  }
  requestCanvasRedrawWithInsertOverlay();
});

  const stop = (e)=>{
    if (!insertImage) return;
    if (insertTransform.dragging) {
      insertTransform.dragging = false;
      drawCanvas.releasePointerCapture(e.pointerId);
    }
  };
  drawCanvas.addEventListener('pointerup', stop);
  drawCanvas.addEventListener('pointercancel', stop);
})();


// ... existing code ...
function drawTransformedImageOverlay() {
  if (!insertImage) {
    ictx.clearRect(0,0,insertCanvas.width,insertCanvas.height);
    return;
  }
  ictx.clearRect(0,0,insertCanvas.width,insertCanvas.height);
  const ctx = ictx;
  const cx = insertTransform.x;
  const cy = insertTransform.y;
  const w = insertTransform.width;
  const h = insertTransform.height;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.drawImage(insertImage, -w/2, -h/2, w, h);
  ctx.restore();
  // Handles + bbox
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.strokeStyle = '#39f';
  ctx.lineWidth = 1;
  ctx.setLineDash([6,4]);
  ctx.strokeRect(-w/2, -h/2, w, h);
  ctx.setLineDash([]);
  ctx.fillStyle = '#39f';
  const halfCorner = HANDLE.corner / 2;
  [[-w/2,-h/2],[w/2,-h/2],[w/2,h/2],[-w/2,h/2]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-halfCorner, hy-halfCorner, HANDLE.corner, HANDLE.corner);
  });
  ctx.beginPath();
  ctx.arc(0, -h/2-HANDLE.rotOffset, HANDLE.rotRadius, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#9cf';
  const halfEdge = HANDLE.edge / 2;
  [[0,-h/2],[w/2,0],[0,h/2],[-w/2,0]].forEach(([hx,hy])=>{
    ctx.fillRect(hx-halfEdge, hy-halfEdge, HANDLE.edge, HANDLE.edge);
  });
  ctx.restore();
}
// ... existing code ...

// ... existing code ...
function drawTransformedImageOnly(ctx) {
  if (!insertImage) return;
  const cx = insertTransform.x;
  const cy = insertTransform.y;
  const w = insertTransform.width;
  const h = insertTransform.height;
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(insertTransform.rotation);
  ctx.transform(1, Math.tan(insertTransform.skewY), Math.tan(insertTransform.skewX), 1, 0, 0);
  ctx.scale(insertTransform.scaleX, insertTransform.scaleY);
  ctx.drawImage(insertImage, -w/2, -h/2, w, h);
  ctx.restore();
}
// ... existing code ...

// Loading modal helpers
function showLoading(title, sub){
  const m=document.getElementById('exportLoading');
  const t=document.getElementById('exportLoadingTitle');
  const s=document.getElementById('exportLoadingSub');
  if(t) t.textContent=title||'Processing...';
  if(s) s.textContent=sub||'';
  if(m) m.classList.add('open');
}
function updateLoading(sub){
  const s=document.getElementById('exportLoadingSub');
  if(s) s.textContent=sub||'';
}
function hideLoading(){
  const m=document.getElementById('exportLoading');
  if(m) m.classList.remove('open');
}
</script>
</body>
</html>

